(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 2.0.0-beta9-dev
var any, assignment, beingDeclared, cache$, cache$1, collectIdentifiers, concat, concatMap, CS, declarationsNeeded, declarationsNeededRecursive, defaultRules, difference, divMod, dynamicMemberAccess, enabledHelpers, envEnrichments, exports, expr, fn, foldl, foldl1, forceBlock, generateMutatingWalker, generateSoak, genSym, h, hasSoak, helperNames, helpers, inlineHelpers, intersect, isIdentifierName, isScopeBoundary, JS, jsReserved, makeReturn, makeVarDeclaration, map, mapChildNodes, memberAccess, needsCaching, nub, owns, partition, span, stmt, union, usedAsExpression, variableDeclarations;
cache$ = require('./functional-helpers');
any = cache$.any;
concat = cache$.concat;
concatMap = cache$.concatMap;
difference = cache$.difference;
divMod = cache$.divMod;
foldl = cache$.foldl;
foldl1 = cache$.foldl1;
intersect = cache$.intersect;
map = cache$.map;
nub = cache$.nub;
owns = cache$.owns;
partition = cache$.partition;
span = cache$.span;
union = cache$.union;
cache$1 = require('./helpers');
beingDeclared = cache$1.beingDeclared;
usedAsExpression = cache$1.usedAsExpression;
envEnrichments = cache$1.envEnrichments;
CS = require('./nodes');
JS = require('./js-nodes');
exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
jsReserved = [
  'break',
  'case',
  'catch',
  'class',
  'const',
  'continue',
  'debugger',
  'default',
  'delete',
  'do',
  'else',
  'enum',
  'export',
  'extends',
  'false',
  'finally',
  'for',
  'function',
  'if',
  'implements',
  'import',
  'in',
  'instanceof',
  'interface',
  'let',
  'native',
  'new',
  'null',
  'package',
  'private',
  'protected',
  'public',
  'return',
  'static',
  'super',
  'switch',
  'this',
  'throw',
  'true',
  'try',
  'typeof',
  'var',
  'void',
  'while',
  'with',
  'yield',
  'arguments',
  'eval'
];
mapChildNodes = function (node, mapper, reducer, identity, opts) {
  var child, childName;
  if (null == opts)
    opts = {};
  if (null != opts.listReducer)
    opts.listReducer;
  else
    opts.listReducer = reducer;
  if (null != opts.listIdentity)
    opts.listIdentity;
  else
    opts.listIdentity = identity;
  return foldl(identity, function (accum$) {
    for (var i$ = 0, length$ = node.childNodes.length; i$ < length$; ++i$) {
      childName = node.childNodes[i$];
      if (!(null != node[childName]))
        continue;
      accum$.push(in$(childName, node.listMembers) ? foldl(opts.listIdentity, function (accum$1) {
        for (var i$1 = 0, length$1 = node[childName].length; i$1 < length$1; ++i$1) {
          child = node[childName][i$1];
          if (!('undefined' !== typeof child && null != child))
            continue;
          accum$1.push(mapper(child, childName));
        }
        return accum$1;
      }.call(this, []), opts.listReducer) : mapper(node[childName], childName));
    }
    return accum$;
  }.call(this, []), reducer);
};
genSym = function () {
  var genSymCounter;
  genSymCounter = 0;
  return function (pre) {
    return new JS.GenSym(pre, ++genSymCounter);
  };
}();
stmt = function (e) {
  var walk;
  if (!(null != e))
    return e;
  if (e.isStatement) {
    return e;
  } else if (e['instanceof'](JS.SequenceExpression)) {
    walk = function (seq) {
      return concatMap(seq.expressions, function (e) {
        if (e['instanceof'](JS.SequenceExpression)) {
          return walk(e);
        } else {
          return [stmt(e)];
        }
      });
    };
    return new JS.BlockStatement(walk(e));
  } else if (e['instanceof'](JS.ConditionalExpression)) {
    return new JS.IfStatement(expr(e.test), stmt(e.consequent), stmt(e.alternate));
  } else {
    return new JS.ExpressionStatement(e);
  }
};
expr = function (s) {
  var accum, alternate, block, consequent, iife, lastExpression, push;
  if (!(null != s))
    return s;
  if (s.isExpression) {
    return s;
  } else if (s['instanceof'](JS.BlockStatement)) {
    switch (s.body.length) {
    case 0:
      return helpers.undef();
    case 1:
      return expr(s.body[0]);
    default:
      return new JS.SequenceExpression(map(s.body, expr));
    }
  } else if (s['instanceof'](JS.ExpressionStatement)) {
    return s.expression;
  } else if (s['instanceof'](JS.ThrowStatement)) {
    return new JS.CallExpression(new JS.FunctionExpression(null, [], forceBlock(s)), []);
  } else if (s['instanceof'](JS.IfStatement)) {
    consequent = expr(null != s.consequent ? s.consequent : helpers.undef());
    alternate = expr(null != s.alternate ? s.alternate : helpers.undef());
    return new JS.ConditionalExpression(s.test, consequent, alternate);
  } else if (s['instanceof'](JS.ForInStatement, JS.ForStatement, JS.WhileStatement)) {
    accum = genSym('accum');
    push = function (x) {
      return stmt(new JS.CallExpression(memberAccess(accum, 'push'), [x]));
    };
    s.body = forceBlock(s.body);
    if (s.body.body.length) {
      lastExpression = s.body.body.slice(-1)[0];
      if (!lastExpression['instanceof'](JS.ThrowStatement))
        s.body.body[s.body.body.length - 1] = push(expr(lastExpression));
    } else {
      s.body.body.push(push(helpers.undef()));
    }
    block = new JS.BlockStatement([
      s,
      new JS.ReturnStatement(accum)
    ]);
    iife = new JS.FunctionExpression(null, [accum], block);
    return new JS.CallExpression(memberAccess(iife.g(), 'call'), [
      new JS.ThisExpression,
      new JS.ArrayExpression([])
    ]);
  } else if (s['instanceof'](JS.SwitchStatement, JS.TryStatement)) {
    block = new JS.BlockStatement([makeReturn(s)]);
    iife = new JS.FunctionExpression(null, [], block);
    return new JS.CallExpression(memberAccess(iife.g(), 'call'), [new JS.ThisExpression]);
  } else {
    throw new Error('expr: Cannot use a ' + s.type + ' as a value');
  }
};
isScopeBoundary = function (node) {
  return node['instanceof'](JS.FunctionExpression, JS.FunctionDeclaration) && !node.generated;
};
makeReturn = function (node) {
  var stmts;
  if (!(null != node))
    return new JS.ReturnStatement;
  if (node['instanceof'](JS.BlockStatement)) {
    return new JS.BlockStatement([].slice.call(node.body.slice(0, -1)).concat([makeReturn(node.body.slice(-1)[0])]));
  } else if (node['instanceof'](JS.SequenceExpression)) {
    return new JS.SequenceExpression([].slice.call(node.expressions.slice(0, -1)).concat([makeReturn(node.expressions.slice(-1)[0])]));
  } else if (node['instanceof'](JS.IfStatement)) {
    return new JS.IfStatement(node.test, makeReturn(node.consequent), null != node.alternate ? makeReturn(node.alternate) : null);
  } else if (node['instanceof'](JS.SwitchStatement)) {
    return new JS.SwitchStatement(node.discriminant, map(node.cases, makeReturn));
  } else if (node['instanceof'](JS.SwitchCase)) {
    if (!node.consequent.length)
      return node;
    stmts = node.consequent.slice(-1)[0]['instanceof'](JS.BreakStatement) ? node.consequent.slice(0, -1) : node.consequent;
    return new JS.SwitchCase(node.test, [].slice.call(stmts.slice(0, -1)).concat([makeReturn(stmts.slice(-1)[0])]));
  } else if (node['instanceof'](JS.TryStatement)) {
    return new JS.TryStatement(makeReturn(node.block), map(node.handlers, makeReturn), null != node.finalizer ? makeReturn(node.finalizer) : null);
  } else if (node['instanceof'](JS.CatchClause)) {
    return new JS.CatchClause(node.param, makeReturn(node.body));
  } else if (node['instanceof'](JS.ThrowStatement, JS.ReturnStatement, JS.BreakStatement, JS.ContinueStatement, JS.DebuggerStatement)) {
    return node;
  } else if (node['instanceof'](JS.UnaryExpression) && node.operator === 'void') {
    return new JS.ReturnStatement;
  } else {
    return new JS.ReturnStatement(expr(node));
  }
};
generateMutatingWalker = function (fn) {
  return function (node) {
    var args, mapper, reducer;
    args = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
    mapper = function (child, nameInParent) {
      return [
        nameInParent,
        fn.apply(child, args)
      ];
    };
    reducer = function (parent, param$) {
      var cache$2, name, newChild;
      {
        cache$2 = param$;
        name = cache$2[0];
        newChild = cache$2[1];
      }
      parent[name] = newChild;
      return parent;
    };
    return mapChildNodes(node, mapper, reducer, node, {
      listReducer: function (param$, param$1) {
        var _, accum, cache$2, cache$3, name, newChild;
        {
          cache$2 = param$;
          _ = cache$2[0];
          accum = cache$2[1];
        }
        {
          cache$3 = param$1;
          name = cache$3[0];
          newChild = cache$3[1];
        }
        return [
          name,
          accum.concat(newChild)
        ];
      },
      listIdentity: [
        null,
        []
      ]
    });
  };
};
declarationsNeeded = function (node) {
  if (!(null != node))
    return [];
  if (node['instanceof'](JS.AssignmentExpression) && node.operator === '=' && node.left['instanceof'](JS.Identifier)) {
    return [node.left.name];
  } else if (node['instanceof'](JS.ForInStatement) && node.left['instanceof'](JS.Identifier)) {
    return [node.left.name];
  } else {
    return [];
  }
};
declarationsNeededRecursive = function (node) {
  if (!(null != node))
    return [];
  if (isScopeBoundary(node)) {
    return [];
  } else {
    return union(declarationsNeeded(node), mapChildNodes(node, declarationsNeededRecursive, function (a, b) {
      return a.concat(b);
    }, []));
  }
};
variableDeclarations = function (node) {
  if (!(null != node))
    return [];
  if (node['instanceof'](JS.FunctionDeclaration)) {
    return [node.id];
  } else if (isScopeBoundary(node)) {
    return [];
  } else if (node['instanceof'](JS.VariableDeclarator)) {
    return [node.id];
  } else {
    return mapChildNodes(node, variableDeclarations, function (a, b) {
      return a.concat(b);
    }, []);
  }
};
collectIdentifiers = function (node) {
  return nub(function () {
    switch (false) {
    case !!(null != node):
      return [];
    case !node['instanceof'](JS.Identifier):
      return [node.name];
    case !(node['instanceof'](JS.MemberExpression) && !node.computed):
      return collectIdentifiers(node.object);
    default:
      return mapChildNodes(node, collectIdentifiers, function (a, b) {
        return a.concat(b);
      }, []);
    }
  }.call(this));
};
needsCaching = function (node) {
  if (!(null != node))
    return false;
  return envEnrichments(node, []).length > 0 || node['instanceof'](CS.FunctionApplications, CS.DoOp, CS.NewOp, CS.ArrayInitialiser, CS.ObjectInitialiser, CS.RegExp, CS.HeregExp, CS.PreIncrementOp, CS.PostIncrementOp, CS.PreDecrementOp, CS.PostDecrementOp, CS.Range) || mapChildNodes(node, needsCaching, function (a, b) {
    return a || b;
  }, false);
};
forceBlock = function (node) {
  if (!(null != node))
    return new JS.BlockStatement([]);
  node = stmt(node);
  if (node['instanceof'](JS.BlockStatement)) {
    return node;
  } else {
    return new JS.BlockStatement([node]);
  }
};
makeVarDeclaration = function (vars) {
  var decls, v;
  vars.sort(function (a, b) {
    a = a.name.toLowerCase();
    b = b.name.toLowerCase();
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  });
  decls = function (accum$) {
    for (var i$ = 0, length$ = vars.length; i$ < length$; ++i$) {
      v = vars[i$];
      accum$.push(new JS.VariableDeclarator(v));
    }
    return accum$;
  }.call(this, []);
  return new JS.VariableDeclaration('var', decls);
};
isIdentifierName = function (name) {
  return !in$(name, jsReserved) && /^[$_a-z][$_a-z0-9]*$/i.test(name);
};
memberAccess = function (e, member) {
  if (isIdentifierName(member)) {
    return new JS.MemberExpression(false, expr(e), new JS.Identifier(member));
  } else {
    return new JS.MemberExpression(true, expr(e), new JS.Literal(member));
  }
};
dynamicMemberAccess = function (e, index) {
  if (index['instanceof'](JS.Literal) && typeof index.value === 'string') {
    return memberAccess(e, index.value);
  } else {
    return new JS.MemberExpression(true, expr(e), expr(index));
  }
};
assignment = function (assignee, expression, valueUsed) {
  var alternate, assignments, consequent, e, elements, i, index, m, numElements, p, propName, restName, size, test;
  if (null == valueUsed)
    valueUsed = false;
  assignments = [];
  expression = expr(expression);
  switch (false) {
  case !assignee.rest:
  case !assignee['instanceof'](JS.ArrayExpression):
    e = expression;
    if (valueUsed || assignee.elements.length > 1) {
      e = genSym('cache');
      assignments.push(new JS.AssignmentExpression('=', e, expression));
    }
    elements = assignee.elements;
    for (var i$ = 0, length$ = elements.length; i$ < length$; ++i$) {
      m = elements[i$];
      i = i$;
      if (m.rest)
        break;
      assignments.push(assignment(m, dynamicMemberAccess(e, new JS.Literal(i)), valueUsed));
    }
    if (elements.length > 0) {
      if (elements.slice(-1)[0].rest) {
        numElements = elements.length;
        restName = elements[numElements - 1] = elements[numElements - 1].expression;
        test = new JS.BinaryExpression('<=', new JS.Literal(numElements), memberAccess(e, 'length'));
        consequent = helpers.slice(e, new JS.Literal(numElements - 1));
        alternate = new JS.ArrayExpression([]);
        assignments.push(stmt(new JS.AssignmentExpression('=', restName, new JS.ConditionalExpression(test, consequent, alternate))));
      } else if (any(elements, function (p) {
          return p.rest;
        })) {
        restName = index = null;
        for (var i$1 = 0, length$1 = elements.length; i$1 < length$1; ++i$1) {
          p = elements[i$1];
          i = i$1;
          if (!p.rest)
            continue;
          restName = p.expression;
          index = i;
          break;
        }
        elements.splice(index, 1);
        numElements = elements.length;
        size = genSym('size');
        assignments.push(new JS.AssignmentExpression('=', size, memberAccess(e, 'length')));
        test = new JS.BinaryExpression('>', size, new JS.Literal(numElements));
        consequent = helpers.slice(e, new JS.Literal(index), new JS.BinaryExpression('-', size, new JS.Literal(numElements - index)));
        assignments.push(new JS.AssignmentExpression('=', restName, new JS.ConditionalExpression(test, consequent, new JS.ArrayExpression([]))));
        for (var i$2 = 0, length$2 = elements.slice(index).length; i$2 < length$2; ++i$2) {
          p = elements.slice(index)[i$2];
          i = i$2;
          assignments.push(stmt(new JS.AssignmentExpression('=', p, new JS.MemberExpression(true, e, new JS.BinaryExpression('-', size, new JS.Literal(numElements - index - i))))));
        }
      }
      if (any(elements, function (p) {
          return p.rest;
        }))
        throw new Error('Positional destructuring assignments may not have more than one rest operator');
    }
    break;
  case !assignee['instanceof'](JS.ObjectExpression):
    e = expression;
    if (valueUsed || assignee.properties.length > 1) {
      e = genSym('cache');
      assignments.push(new JS.AssignmentExpression('=', e, expression));
    }
    for (var i$3 = 0, length$3 = assignee.properties.length; i$3 < length$3; ++i$3) {
      m = assignee.properties[i$3];
      propName = m.key['instanceof'](JS.Identifier) ? new JS.Literal(m.key.name) : m.key;
      assignments.push(assignment(m.value, dynamicMemberAccess(e, propName), valueUsed));
    }
    break;
  case !assignee['instanceof'](JS.Identifier, JS.GenSym, JS.MemberExpression):
    assignments.push(new JS.AssignmentExpression('=', assignee, expr(expression)));
    break;
  default:
    throw new Error('compile: assignment: unassignable assignee: ' + assignee.type);
  }
  switch (assignments.length) {
  case 0:
    if (e === expression) {
      return helpers.undef();
    } else {
      return expression;
    }
  case 1:
    return assignments[0];
  default:
    return new JS.SequenceExpression(valueUsed ? [].slice.call(assignments).concat([e]) : assignments);
  }
};
hasSoak = function (node) {
  switch (false) {
  case !node['instanceof'](CS.SoakedFunctionApplication, CS.SoakedMemberAccessOp, CS.SoakedProtoMemberAccessOp, CS.SoakedDynamicMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp):
    return true;
  case !node['instanceof'](CS.FunctionApplication):
    return hasSoak(node['function']);
  case !node['instanceof'](CS.MemberAccessOps):
    return hasSoak(node.expression);
  default:
    return false;
  }
};
generateSoak = function () {
  var fn;
  fn = function (node) {
    var cache$2, cache$3, cache$4, cache$5, cache$6, ctor, e, memberName, sym, tests, typeofTest;
    switch (false) {
    case !node['instanceof'](CS.MemberAccessOp, CS.ProtoMemberAccessOp):
      cache$2 = fn(node.expression);
      tests = cache$2[0];
      e = cache$2[1];
      return [
        tests,
        new node.constructor(e, node.memberName)
      ];
    case !node['instanceof'](CS.DynamicMemberAccessOp, CS.DynamicProtoMemberAccessOp):
      cache$3 = fn(node.expression);
      tests = cache$3[0];
      e = cache$3[1];
      return [
        tests,
        new node.constructor(e, node.indexingExpr)
      ];
    case !node['instanceof'](CS.FunctionApplication):
      cache$4 = fn(node['function']);
      tests = cache$4[0];
      e = cache$4[1];
      return [
        tests,
        new CS.FunctionApplication(e, node['arguments'])
      ];
    case !node['instanceof'](CS.SoakedFunctionApplication):
      cache$5 = fn(node['function']);
      tests = cache$5[0];
      e = cache$5[1];
      typeofTest = function (e) {
        return new CS.EQOp(new CS.String('function'), new CS.TypeofOp(e));
      };
      if (needsCaching(e)) {
        sym = new CS.GenSym('cache');
        return [
          [].slice.call(tests).concat([typeofTest(new CS.AssignOp(sym, e))]),
          new CS.FunctionApplication(sym, node['arguments'])
        ];
      } else {
        return [
          [].slice.call(tests).concat([typeofTest(e)]),
          new CS.FunctionApplication(e, node['arguments'])
        ];
      }
    case !node['instanceof'](CS.SoakedMemberAccessOp, CS.SoakedProtoMemberAccessOp, CS.SoakedDynamicMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp):
      memberName = function () {
        switch (false) {
        case !node['instanceof'](CS.SoakedMemberAccessOp, CS.SoakedProtoMemberAccessOp):
          return 'memberName';
        case !node['instanceof'](CS.SoakedDynamicMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp):
          return 'indexingExpr';
        }
      }.call(this);
      ctor = function () {
        switch (false) {
        case !node['instanceof'](CS.SoakedMemberAccessOp):
          return CS.MemberAccessOp;
        case !node['instanceof'](CS.SoakedProtoMemberAccessOp):
          return CS.ProtoMemberAccessOp;
        case !node['instanceof'](CS.SoakedDynamicMemberAccessOp):
          return CS.DynamicMemberAccessOp;
        case !node['instanceof'](CS.SoakedDynamicProtoMemberAccessOp):
          return CS.DynamicProtoMemberAccessOp;
        }
      }.call(this);
      cache$6 = fn(node.expression);
      tests = cache$6[0];
      e = cache$6[1];
      if (needsCaching(e)) {
        sym = new CS.GenSym('cache');
        return [
          [].slice.call(tests).concat([new CS.UnaryExistsOp(new CS.AssignOp(sym, e))]),
          new ctor(sym, node[memberName])
        ];
      } else {
        return [
          [].slice.call(tests).concat([new CS.UnaryExistsOp(e)]),
          new ctor(e, node[memberName])
        ];
      }
    default:
      return [
        [],
        node
      ];
    }
  };
  return function (node) {
    var cache$2, e, tests;
    cache$2 = fn(node);
    tests = cache$2[0];
    e = cache$2[1];
    return new CS.Conditional(foldl1(tests, function (memo, t) {
      return new CS.LogicalAndOp(memo, t);
    }), e);
  };
}();
helperNames = {};
helpers = {
  'extends': function () {
    var block, child, ctor, f, key, parent, protoAccess;
    protoAccess = function (e) {
      return memberAccess(e, 'prototype');
    };
    child = new JS.Identifier('child');
    parent = new JS.Identifier('parent');
    ctor = new JS.Identifier('ctor');
    key = new JS.Identifier('key');
    block = [
      new JS.ForInStatement(new JS.VariableDeclaration('var', [new JS.VariableDeclarator(key, null)]), parent, new JS.IfStatement(helpers.isOwn(parent, key), f = stmt(new JS.AssignmentExpression('=', new JS.MemberExpression(true, child, key), new JS.MemberExpression(true, parent, key))))),
      new JS.FunctionDeclaration(ctor, [], new JS.BlockStatement([stmt(new JS.AssignmentExpression('=', memberAccess(new JS.ThisExpression, 'constructor'), child))])),
      new JS.AssignmentExpression('=', protoAccess(ctor), protoAccess(parent)),
      new JS.AssignmentExpression('=', protoAccess(child), new JS.NewExpression(ctor, [])),
      new JS.AssignmentExpression('=', memberAccess(child, '__super__'), protoAccess(parent)),
      new JS.ReturnStatement(child)
    ];
    return new JS.FunctionDeclaration(helperNames['extends'], [
      child,
      parent
    ], new JS.BlockStatement(map(block, stmt)));
  },
  construct: function () {
    var args, block, child, ctor, fn, result;
    child = new JS.Identifier('child');
    ctor = new JS.Identifier('ctor');
    fn = new JS.Identifier('fn');
    args = new JS.Identifier('args');
    result = new JS.Identifier('result');
    block = [
      new JS.VariableDeclaration('var', [new JS.VariableDeclarator(fn, new JS.FunctionExpression(null, [], new JS.BlockStatement([])))]),
      new JS.AssignmentExpression('=', memberAccess(fn, 'prototype'), memberAccess(ctor, 'prototype')),
      new JS.VariableDeclaration('var', [
        new JS.VariableDeclarator(child, new JS.NewExpression(fn, [])),
        new JS.VariableDeclarator(result, new JS.CallExpression(memberAccess(ctor, 'apply'), [
          child,
          args
        ]))
      ]),
      new JS.ReturnStatement(new JS.ConditionalExpression(new JS.BinaryExpression('===', result, new JS.CallExpression(new JS.Identifier('Object'), [result])), result, child))
    ];
    return new JS.FunctionDeclaration(helperNames.construct, [
      ctor,
      args
    ], new JS.BlockStatement(map(block, stmt)));
  },
  isOwn: function () {
    var args, functionBody, hop, params;
    hop = memberAccess(new JS.ObjectExpression([]), 'hasOwnProperty');
    params = args = [
      new JS.Identifier('o'),
      new JS.Identifier('p')
    ];
    functionBody = [new JS.CallExpression(memberAccess(hop, 'call'), args)];
    return new JS.FunctionDeclaration(helperNames.isOwn, params, makeReturn(new JS.BlockStatement(map(functionBody, stmt))));
  },
  'in': function () {
    var functionBody, i, length, list, loopBody, member, varDeclaration;
    member = new JS.Identifier('member');
    list = new JS.Identifier('list');
    i = new JS.Identifier('i');
    length = new JS.Identifier('length');
    varDeclaration = new JS.VariableDeclaration('var', [
      new JS.VariableDeclarator(i, new JS.Literal(0)),
      new JS.VariableDeclarator(length, memberAccess(list, 'length'))
    ]);
    loopBody = new JS.IfStatement(new JS.LogicalExpression('&&', new JS.BinaryExpression('in', i, list), new JS.BinaryExpression('===', new JS.MemberExpression(true, list, i), member)), new JS.ReturnStatement(new JS.Literal(true)));
    functionBody = [
      new JS.ForStatement(varDeclaration, new JS.BinaryExpression('<', i, length), new JS.UpdateExpression('++', true, i), loopBody),
      new JS.Literal(false)
    ];
    return new JS.FunctionDeclaration(helperNames['in'], [
      member,
      list
    ], makeReturn(new JS.BlockStatement(map(functionBody, stmt))));
  }
};
enabledHelpers = [];
for (h in helpers) {
  if (!isOwn$(helpers, h))
    continue;
  fn = helpers[h];
  helperNames[h] = genSym(h);
  helpers[h] = function (h, fn) {
    return function () {
      enabledHelpers.push(fn());
      return (helpers[h] = function () {
        return new JS.CallExpression(helperNames[h], arguments);
      }).apply(this, arguments);
    };
  }(h, fn);
}
inlineHelpers = {
  exp: function () {
    return new JS.CallExpression(memberAccess(new JS.Identifier('Math'), 'pow'), arguments);
  },
  undef: function () {
    return new JS.UnaryExpression('void', new JS.Literal(0));
  },
  slice: function () {
    return new JS.CallExpression(memberAccess(memberAccess(new JS.ArrayExpression([]), 'slice'), 'call'), arguments);
  }
};
for (h in inlineHelpers) {
  if (!isOwn$(inlineHelpers, h))
    continue;
  fn = inlineHelpers[h];
  helpers[h] = fn;
}
exports.Compiler = function () {
  Compiler.compile = function (this$) {
    return function () {
      var cache$2;
      return (cache$2 = new this$()).compile.apply(cache$2, [].slice.call(arguments));
    };
  }(Compiler);
  defaultRules = [
    [
      CS.Program,
      function (param$) {
        var block, body, cache$2, cache$3, decls, fnDeclHelpers, inScope, options, otherHelpers, pkg, program;
        {
          cache$2 = param$;
          body = cache$2.body;
          inScope = cache$2.inScope;
          options = cache$2.options;
        }
        if (!(null != body))
          return new JS.Program([]);
        block = stmt(body);
        block = block['instanceof'](JS.BlockStatement) ? block.body : [block];
        cache$3 = partition(enabledHelpers, function (helper) {
          return helper['instanceof'](JS.FunctionDeclaration);
        });
        fnDeclHelpers = cache$3[0];
        otherHelpers = cache$3[1];
        [].push.apply(block, fnDeclHelpers);
        [].unshift.apply(block, otherHelpers);
        decls = nub(concatMap(block, declarationsNeededRecursive));
        if (decls.length && !options.bare)
          block = [stmt(new JS.UnaryExpression('void', new JS.CallExpression(memberAccess(new JS.FunctionExpression(null, [], new JS.BlockStatement(block)), 'call'), [new JS.ThisExpression])))];
        pkg = require('./../package.json');
        program = new JS.Program(block);
        program.leadingComments = [{
            type: 'Line',
            value: ' Generated by CoffeeScript ' + pkg.version
          }];
        return program;
      }
    ],
    [
      CS.Block,
      function (param$) {
        var statements;
        statements = param$.statements;
        switch (statements.length) {
        case 0:
          return new JS.EmptyStatement;
        case 1:
          return new stmt(statements[0]);
        default:
          return new JS.BlockStatement(concatMap(statements, function (s) {
            if (s['instanceof'](JS.BlockStatement)) {
              return map(s.body, stmt);
            } else if (s['instanceof'](JS.SequenceExpression)) {
              return map(s.expressions, stmt);
            } else {
              return [stmt(s)];
            }
          }));
        }
      }
    ],
    [
      CS.SeqOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.SequenceExpression([
          left,
          right
        ]);
      }
    ],
    [
      CS.Conditional,
      function (param$) {
        var ancestry, cache$2, condition;
        var alternate, consequent;
        {
          cache$2 = param$;
          condition = cache$2.condition;
          consequent = cache$2.consequent;
          alternate = cache$2.alternate;
          ancestry = cache$2.ancestry;
        }
        if (null != alternate) {
          if (!(null != consequent))
            throw new Error('Conditional with non-null alternate requires non-null consequent');
          if (!alternate['instanceof'](JS.IfStatement))
            alternate = forceBlock(alternate);
        }
        if (null != alternate || (null != ancestry[0] ? ancestry[0]['instanceof'](CS.Conditional) : void 0))
          consequent = forceBlock(consequent);
        return new JS.IfStatement(expr(condition), stmt(consequent), alternate);
      }
    ],
    [
      CS.ForIn,
      function (param$) {
        var block, body, cache$2, compile, e, filter, i, increment, k, keyAssignee, length, op, step, target, update, valAssignee, varDeclaration;
        {
          cache$2 = param$;
          valAssignee = cache$2.valAssignee;
          keyAssignee = cache$2.keyAssignee;
          target = cache$2.target;
          step = cache$2.step;
          filter = cache$2.filter;
          body = cache$2.body;
          compile = cache$2.compile;
        }
        i = genSym('i');
        length = genSym('length');
        block = forceBlock(body);
        if (!block.body.length)
          block.body.push(stmt(helpers.undef()));
        increment = null != this.step && !(this.step['instanceof'](CS.Int) && this.step.data === 1) ? function (x) {
          return new JS.AssignmentExpression('+=', x, step);
        } : function (x) {
          return new JS.UpdateExpression('++', true, x);
        };
        if (this.target['instanceof'](CS.Range) && (this.target.left['instanceof'](CS.Int) || this.target.left['instanceof'](CS.UnaryNegateOp) && this.target.left.expression['instanceof'](CS.Int)) && (this.target.right['instanceof'](CS.Int) || this.target.right['instanceof'](CS.UnaryNegateOp) && this.target.right.expression['instanceof'](CS.Int))) {
          varDeclaration = new JS.VariableDeclaration('var', [new JS.VariableDeclarator(i, compile(this.target.left))]);
          update = increment(i);
          if (null != this.filter)
            block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', filter), new JS.ContinueStatement)));
          if (null != keyAssignee) {
            k = genSym('k');
            varDeclaration.declarations.unshift(new JS.VariableDeclarator(k, new JS.Literal(0)));
            update = new JS.SequenceExpression([
              increment(k),
              update
            ]);
            block.body.unshift(stmt(new JS.AssignmentExpression('=', keyAssignee, k)));
          }
          if (null != valAssignee)
            block.body.unshift(stmt(new JS.AssignmentExpression('=', valAssignee, i)));
          op = this.target.isInclusive ? '<=' : '<';
          return new JS.ForStatement(varDeclaration, new JS.BinaryExpression(op, i, compile(this.target.right)), update, block);
        }
        e = needsCaching(this.target) ? genSym('cache') : target;
        varDeclaration = new JS.VariableDeclaration('var', [
          new JS.VariableDeclarator(i, new JS.Literal(0)),
          new JS.VariableDeclarator(length, memberAccess(e, 'length'))
        ]);
        if (!(e === target))
          varDeclaration.declarations.unshift(new JS.VariableDeclarator(e, target));
        if (null != this.filter)
          block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', filter), new JS.ContinueStatement)));
        if (null != keyAssignee)
          block.body.unshift(stmt(assignment(keyAssignee, i)));
        if (null != valAssignee)
          block.body.unshift(stmt(assignment(valAssignee, new JS.MemberExpression(true, e, i))));
        return new JS.ForStatement(varDeclaration, new JS.BinaryExpression('<', i, length), increment(i), block);
      }
    ],
    [
      CS.ForOf,
      function (param$) {
        var block, body, cache$2, e, filter, keyAssignee, right, target, valAssignee;
        {
          cache$2 = param$;
          keyAssignee = cache$2.keyAssignee;
          valAssignee = cache$2.valAssignee;
          target = cache$2.target;
          filter = cache$2.filter;
          body = cache$2.body;
        }
        block = forceBlock(body);
        if (!block.body.length)
          block.body.push(stmt(helpers.undef()));
        e = this.isOwn && needsCaching(this.target) ? genSym('cache') : expr(target);
        if (null != this.filter)
          block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', filter), new JS.ContinueStatement)));
        if (null != valAssignee)
          block.body.unshift(stmt(assignment(valAssignee, new JS.MemberExpression(true, e, keyAssignee))));
        if (this.isOwn)
          block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', helpers.isOwn(e, keyAssignee)), new JS.ContinueStatement)));
        right = e === target ? e : new JS.AssignmentExpression('=', e, target);
        return new JS.ForInStatement(keyAssignee, right, block);
      }
    ],
    [
      CS.While,
      function (param$) {
        var body, cache$2, condition;
        {
          cache$2 = param$;
          condition = cache$2.condition;
          body = cache$2.body;
        }
        return new JS.WhileStatement(expr(condition), forceBlock(body));
      }
    ],
    [
      CS.Switch,
      function (param$) {
        var alternate, c, cache$2;
        var cases, expression;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          cases = cache$2.cases;
          alternate = cache$2.alternate;
        }
        cases = concat(cases);
        if (!(null != expression)) {
          expression = new JS.Literal(false);
          for (var i$ = 0, length$ = cases.length; i$ < length$; ++i$) {
            c = cases[i$];
            c.test = new JS.UnaryExpression('!', c.test);
          }
        }
        if (null != alternate)
          cases.push(new JS.SwitchCase(null, [stmt(alternate)]));
        for (var i$1 = 0, length$1 = cases.slice(0, -1).length; i$1 < length$1; ++i$1) {
          c = cases.slice(0, -1)[i$1];
          if (!((null != c.consequent ? c.consequent.length : void 0) > 0))
            continue;
          c.consequent.push(new JS.BreakStatement);
        }
        return new JS.SwitchStatement(expression, cases);
      }
    ],
    [
      CS.SwitchCase,
      function (param$) {
        var block, cache$2, cases, conditions, consequent;
        {
          cache$2 = param$;
          conditions = cache$2.conditions;
          consequent = cache$2.consequent;
        }
        cases = map(conditions, function (c) {
          return new JS.SwitchCase(c, []);
        });
        block = stmt(consequent);
        block = null != block ? block['instanceof'](JS.BlockStatement) ? block.body : [block] : [];
        cases[cases.length - 1].consequent = block;
        return cases;
      }
    ],
    [
      CS.Try,
      function (param$) {
        var body, cache$2, catchAssignee, catchBlock, catchBody, e, finallyBlock, finallyBody, handlers;
        {
          cache$2 = param$;
          body = cache$2.body;
          catchAssignee = cache$2.catchAssignee;
          catchBody = cache$2.catchBody;
          finallyBody = cache$2.finallyBody;
        }
        finallyBlock = null != this.finallyBody ? forceBlock(finallyBody) : null;
        if (null != this.catchBody || !(null != this.finallyBody)) {
          e = genSym('e');
          catchBlock = forceBlock(catchBody);
          if (null != catchAssignee)
            catchBlock.body.unshift(stmt(assignment(catchAssignee, e)));
          handlers = [new JS.CatchClause(e, catchBlock)];
        } else {
          handlers = [];
        }
        return new JS.TryStatement(forceBlock(body), handlers, finallyBlock);
      }
    ],
    [
      CS.Throw,
      function (param$) {
        var expression;
        expression = param$.expression;
        return new JS.ThrowStatement(expression);
      }
    ],
    [
      CS.Range,
      function (param$) {
        var accum, ancestry, body, cache$2, condition, conditionAlternate, conditionConsequent, conditionTest, i, left, left_, range, rawLeft, rawRight, right, right_, update, vars;
        {
          cache$2 = param$;
          left_ = cache$2.left;
          right_ = cache$2.right;
          ancestry = cache$2.ancestry;
        }
        if ((this.left['instanceof'](CS.Int) || this.left['instanceof'](CS.UnaryNegateOp) && this.left.expression['instanceof'](CS.Int)) && (this.right['instanceof'](CS.Int) || this.right['instanceof'](CS.UnaryNegateOp) && this.right.expression['instanceof'](CS.Int))) {
          rawLeft = this.left['instanceof'](CS.UnaryNegateOp) ? -this.left.expression.data : this.left.data;
          rawRight = this.right['instanceof'](CS.UnaryNegateOp) ? -this.right.expression.data : this.right.data;
          if (Math.abs(rawLeft - rawRight) <= 20) {
            range = this.isInclusive ? function () {
              var accum$;
              accum$ = [];
              for (var i$ = rawLeft; rawLeft <= rawRight ? i$ <= rawRight : i$ >= rawRight; rawLeft <= rawRight ? ++i$ : --i$)
                accum$.push(i$);
              return accum$;
            }.apply(this, arguments) : function () {
              var accum$;
              accum$ = [];
              for (var i$ = rawLeft; rawLeft <= rawRight ? i$ < rawRight : i$ > rawRight; rawLeft <= rawRight ? ++i$ : --i$)
                accum$.push(i$);
              return accum$;
            }.apply(this, arguments);
            return new JS.ArrayExpression(map(range, function (n) {
              if (n < 0) {
                return new JS.UnaryExpression('-', new JS.Literal(-n));
              } else {
                return new JS.Literal(n);
              }
            }));
          }
        }
        accum = genSym('accum');
        body = [stmt(new JS.AssignmentExpression('=', accum, new JS.ArrayExpression([])))];
        if (needsCaching(left_)) {
          left = genSym('from');
          body.push(stmt(new JS.AssignmentExpression('=', left, left_)));
        } else {
          left = left_;
        }
        if (needsCaching(right_)) {
          right = genSym('to');
          body.push(stmt(new JS.AssignmentExpression('=', right, right_)));
        } else {
          right = right_;
        }
        i = genSym('i');
        vars = new JS.VariableDeclaration('var', [new JS.VariableDeclarator(i, left)]);
        conditionTest = new JS.BinaryExpression('<=', left, right);
        conditionConsequent = new JS.BinaryExpression(this.isInclusive ? '<=' : '<', i, right);
        conditionAlternate = new JS.BinaryExpression(this.isInclusive ? '>=' : '>', i, right);
        condition = new JS.ConditionalExpression(conditionTest, conditionConsequent, conditionAlternate);
        update = new JS.ConditionalExpression(conditionTest, new JS.UpdateExpression('++', true, i), new JS.UpdateExpression('--', true, i));
        body.push(new JS.ForStatement(vars, condition, update, stmt(new JS.CallExpression(memberAccess(accum, 'push'), [i]))));
        body.push(new JS.ReturnStatement(accum));
        if (any(ancestry, function (ancestor) {
            return ancestor['instanceof'](CS.Functions);
          })) {
          return new JS.CallExpression(memberAccess(new JS.FunctionExpression(null, [], new JS.BlockStatement(body)), 'apply'), [
            new JS.ThisExpression,
            new JS.Identifier('arguments')
          ]);
        } else {
          return new JS.CallExpression(memberAccess(new JS.FunctionExpression(null, [], new JS.BlockStatement(body)), 'call'), [new JS.ThisExpression]);
        }
      }
    ],
    [
      CS.ArrayInitialiser,
      function () {
        var groupMembers;
        groupMembers = function (members) {
          var cache$2, cache$3, sliced, ys, zs;
          if (members.length === 0) {
            return [];
          } else {
            cache$2 = span(members, function (x) {
              return !x.spread;
            });
            ys = cache$2[0];
            zs = cache$2[1];
            if (ys.length === 0) {
              sliced = helpers.slice(zs[0].expression);
              cache$3 = [
                sliced,
                zs.slice(1)
              ];
              ys = cache$3[0];
              zs = cache$3[1];
              cache$3;
            } else {
              ys = new JS.ArrayExpression(map(ys, expr));
            }
            return [ys].concat(groupMembers(zs));
          }
        };
        return function (param$) {
          var cache$2, compile, grouped, members;
          {
            cache$2 = param$;
            members = cache$2.members;
            compile = cache$2.compile;
          }
          if (any(members, function (m) {
              return m.spread;
            })) {
            grouped = map(groupMembers(members), expr);
            if (grouped.length <= 1) {
              return grouped[0];
            } else {
              return new JS.CallExpression(memberAccess(grouped[0], 'concat'), grouped.slice(1));
            }
          } else {
            return new JS.ArrayExpression(map(members, expr));
          }
        };
      }()
    ],
    [
      CS.Spread,
      function (param$) {
        var expression;
        expression = param$.expression;
        return {
          spread: true,
          expression: expr(expression)
        };
      }
    ],
    [
      CS.ObjectInitialiser,
      function (param$) {
        var members;
        members = param$.members;
        return new JS.ObjectExpression(members);
      }
    ],
    [
      CS.ObjectInitialiserMember,
      function (param$) {
        var cache$2, expression, keyName;
        var key;
        {
          cache$2 = param$;
          key = cache$2.key;
          expression = cache$2.expression;
        }
        keyName = this.key.data;
        key = isIdentifierName(keyName) ? new JS.Identifier(keyName) : new JS.Literal(keyName);
        return new JS.Property(key, expr(expression));
      }
    ],
    [
      CS.DefaultParam,
      function (param$) {
        var cache$2, d, param;
        {
          cache$2 = param$;
          param = cache$2.param;
          d = cache$2['default'];
        }
        return {
          param: param,
          'default': d
        };
      }
    ],
    [
      CS.Function,
      CS.BoundFunction,
      function () {
        var handleParam;
        handleParam = function (param, original, block, inScope) {
          var decls, p;
          switch (false) {
          case !original['instanceof'](CS.Rest):
            return param;
          case !original['instanceof'](CS.Identifier):
            return param;
          case !original['instanceof'](CS.MemberAccessOps, CS.ObjectInitialiser, CS.ArrayInitialiser):
            p = genSym('param');
            decls = map(intersect(inScope, beingDeclared(original)), function (i) {
              return new JS.Identifier(i);
            });
            block.body.unshift(stmt(assignment(param, p)));
            if (decls.length)
              block.body.unshift(makeVarDeclaration(decls));
            return p;
          case !original['instanceof'](CS.DefaultParam):
            p = handleParam.call(this, param.param, original.param, block, inScope);
            block.body.unshift(new JS.IfStatement(new JS.BinaryExpression('==', new JS.Literal(null), p), stmt(assignment(p, param['default']))));
            return p;
          default:
            throw new Error('Unsupported parameter type: ' + original.className);
          }
        };
        return function (param$) {
          var alternate, ancestry, block, cache$2, consequent, i, index, inScope, last, newThis, numArgs, numParams, p, parameters_, paramName, performedRewrite, pIndex, reassignments, rewriteThis, test;
          var body, parameters;
          {
            cache$2 = param$;
            parameters = cache$2.parameters;
            body = cache$2.body;
            ancestry = cache$2.ancestry;
            inScope = cache$2.inScope;
          }
          if (!(null != ancestry[0] ? ancestry[0]['instanceof'](CS.Constructor) : void 0))
            body = makeReturn(body);
          block = forceBlock(body);
          last = block.body.slice(-1)[0];
          if ((null != last ? last['instanceof'](JS.ReturnStatement) : void 0) && !(null != last.argument))
            block.body = block.body.slice(0, -1);
          parameters_ = parameters.length === 0 ? [] : (pIndex = parameters.length, function (accum$) {
            while (pIndex--) {
              accum$.push(handleParam.call(this, parameters[pIndex], this.parameters[pIndex], block, inScope));
            }
            return accum$;
          }.call(this, []));
          parameters = parameters_.reverse();
          if (parameters.length > 0) {
            if (parameters.slice(-1)[0].rest) {
              paramName = parameters.pop().expression;
              numParams = parameters.length;
              test = new JS.BinaryExpression('>', memberAccess(new JS.Identifier('arguments'), 'length'), new JS.Literal(numParams));
              consequent = helpers.slice(new JS.Identifier('arguments'), new JS.Literal(numParams));
              alternate = new JS.ArrayExpression([]);
              if (paramName['instanceof'](JS.Identifier) && in$(paramName.name, inScope))
                block.body.unshift(makeVarDeclaration([paramName]));
              block.body.unshift(stmt(new JS.AssignmentExpression('=', paramName, new JS.ConditionalExpression(test, consequent, alternate))));
            } else if (any(parameters, function (p) {
                return p.rest;
              })) {
              paramName = index = null;
              for (var i$ = 0, length$ = parameters.length; i$ < length$; ++i$) {
                p = parameters[i$];
                i = i$;
                if (!p.rest)
                  continue;
                paramName = p.expression;
                index = i;
                break;
              }
              parameters.splice(index, 1);
              numParams = parameters.length;
              numArgs = genSym('numArgs');
              reassignments = new JS.IfStatement(new JS.BinaryExpression('>', new JS.AssignmentExpression('=', numArgs, memberAccess(new JS.Identifier('arguments'), 'length')), new JS.Literal(numParams)), new JS.BlockStatement([stmt(new JS.AssignmentExpression('=', paramName, helpers.slice(new JS.Identifier('arguments'), new JS.Literal(index), new JS.BinaryExpression('-', numArgs, new JS.Literal(numParams - index)))))]), new JS.BlockStatement([stmt(new JS.AssignmentExpression('=', paramName, new JS.ArrayExpression([])))]));
              for (var i$1 = 0, length$1 = parameters.slice(index).length; i$1 < length$1; ++i$1) {
                p = parameters.slice(index)[i$1];
                i = i$1;
                reassignments.consequent.body.push(stmt(new JS.AssignmentExpression('=', p, new JS.MemberExpression(true, new JS.Identifier('arguments'), new JS.BinaryExpression('-', numArgs, new JS.Literal(numParams - index - i))))));
              }
              if (paramName['instanceof'](JS.Identifier) && in$(paramName.name, inScope))
                block.body.unshift(makeVarDeclaration([paramName]));
              block.body.unshift(reassignments);
            }
            if (any(parameters, function (p) {
                return p.rest;
              }))
              throw new Error('Parameter lists may not have more than one rest operator');
          }
          performedRewrite = false;
          if (this['instanceof'](CS.BoundFunction)) {
            newThis = genSym('this');
            rewriteThis = generateMutatingWalker(function () {
              if (this['instanceof'](JS.ThisExpression)) {
                performedRewrite = true;
                return newThis;
              } else if (this['instanceof'](JS.FunctionExpression, JS.FunctionDeclaration)) {
                return this;
              } else {
                return rewriteThis(this);
              }
            });
            rewriteThis(block);
          }
          fn = new JS.FunctionExpression(null, parameters, block);
          if (performedRewrite) {
            return new JS.CallExpression(new JS.FunctionExpression(null, [newThis], new JS.BlockStatement([new JS.ReturnStatement(fn)])), [new JS.ThisExpression]);
          } else {
            return fn;
          }
        };
      }()
    ],
    [
      CS.Rest,
      function (param$) {
        var expression;
        expression = param$.expression;
        return {
          rest: true,
          expression: expression,
          isExpression: true,
          isStatement: true
        };
      }
    ],
    [
      CS.Class,
      function (param$) {
        var _, args, block, body, c, cache$2, compile, ctorBody, ctorIndex, ctorRef, i, iife, instance, member, memberName, nameAssignee, params, parent, parentRef, protoAssignOp, protoMember, ps, rewriteThis;
        var ctor, name;
        {
          cache$2 = param$;
          nameAssignee = cache$2.nameAssignee;
          parent = cache$2.parent;
          name = cache$2.name;
          ctor = cache$2.ctor;
          body = cache$2.body;
          compile = cache$2.compile;
        }
        args = [];
        params = [];
        parentRef = genSym('super');
        block = forceBlock(body);
        if (name['instanceof'](JS.Identifier) && in$(name.name, jsReserved))
          name = genSym(name.name);
        if (null != ctor) {
          for (var i$ = 0, length$ = block.body.length; i$ < length$; ++i$) {
            c = block.body[i$];
            i = i$;
            if (!c['instanceof'](JS.FunctionDeclaration))
              continue;
            ctorIndex = i;
            break;
          }
          block.body.splice(ctorIndex, 1, ctor);
        } else {
          ctorBody = new JS.BlockStatement([]);
          if (null != parent)
            ctorBody.body.push(stmt(new JS.CallExpression(memberAccess(parentRef, 'apply'), [
              new JS.ThisExpression,
              new JS.Identifier('arguments')
            ])));
          ctor = new JS.FunctionDeclaration(name, [], ctorBody);
          ctorIndex = 0;
          block.body.unshift(ctor);
        }
        ctor.id = name;
        if (null != this.ctor && !this.ctor.expression['instanceof'](CS.Functions)) {
          ctorRef = genSym('externalCtor');
          ctor.body.body.push(makeReturn(new JS.CallExpression(memberAccess(ctorRef, 'apply'), [
            new JS.ThisExpression,
            new JS.Identifier('arguments')
          ])));
          block.body.splice(ctorIndex, 0, stmt(new JS.AssignmentExpression('=', ctorRef, expr(compile(this.ctor.expression)))));
        }
        if (this.boundMembers.length > 0) {
          instance = genSym('instance');
          for (var i$1 = 0, length$1 = this.boundMembers.length; i$1 < length$1; ++i$1) {
            protoAssignOp = this.boundMembers[i$1];
            memberName = protoAssignOp.assignee.data.toString();
            ps = function (accum$) {
              for (var i$2 = 0, length$2 = protoAssignOp.expression.parameters.length; i$2 < length$2; ++i$2) {
                _ = protoAssignOp.expression.parameters[i$2];
                accum$.push(genSym());
              }
              return accum$;
            }.call(this, []);
            member = memberAccess(new JS.ThisExpression, memberName);
            protoMember = memberAccess(memberAccess(name, 'prototype'), memberName);
            fn = new JS.FunctionExpression(null, ps, new JS.BlockStatement([makeReturn(new JS.CallExpression(memberAccess(protoMember, 'apply'), [
                instance,
                new JS.Identifier('arguments')
              ]))]));
            ctor.body.body.unshift(stmt(new JS.AssignmentExpression('=', member, fn)));
          }
          ctor.body.body.unshift(stmt(new JS.AssignmentExpression('=', instance, new JS.ThisExpression)));
        }
        if (null != parent) {
          params.push(parentRef);
          args.push(parent);
          block.body.unshift(stmt(helpers['extends'](name, parentRef)));
        }
        block.body.push(new JS.ReturnStatement(new JS.ThisExpression));
        rewriteThis = generateMutatingWalker(function () {
          if (this['instanceof'](JS.ThisExpression)) {
            return name;
          } else if (this['instanceof'](JS.FunctionExpression, JS.FunctionDeclaration)) {
            return this;
          } else {
            return rewriteThis(this);
          }
        });
        rewriteThis(block);
        iife = new JS.CallExpression(new JS.FunctionExpression(null, params, block).g(), args);
        if (null != nameAssignee) {
          return assignment(nameAssignee, iife);
        } else {
          return iife;
        }
      }
    ],
    [
      CS.Constructor,
      function (param$) {
        var expression, tmpName;
        expression = param$.expression;
        tmpName = genSym('class');
        if (this.expression['instanceof'](CS.Functions)) {
          return new JS.FunctionDeclaration(tmpName, expression.params, forceBlock(expression.body));
        } else {
          return new JS.FunctionDeclaration(tmpName, [], new JS.BlockStatement([]));
        }
      }
    ],
    [
      CS.ClassProtoAssignOp,
      function (param$) {
        var assignee, cache$2, compile, expression, protoMember;
        {
          cache$2 = param$;
          assignee = cache$2.assignee;
          expression = cache$2.expression;
          compile = cache$2.compile;
        }
        if (this.expression['instanceof'](CS.BoundFunction)) {
          return compile(new CS.ClassProtoAssignOp(this.assignee, new CS.Function(this.expression.parameters, this.expression.body)));
        } else {
          protoMember = memberAccess(memberAccess(new JS.ThisExpression, 'prototype'), this.assignee.data);
          return new JS.AssignmentExpression('=', protoMember, expression);
        }
      }
    ],
    [
      CS.AssignOp,
      function (param$) {
        var ancestry, assignee, cache$2, expression;
        {
          cache$2 = param$;
          assignee = cache$2.assignee;
          expression = cache$2.expression;
          ancestry = cache$2.ancestry;
        }
        return assignment(assignee, expression, usedAsExpression(this, ancestry));
      }
    ],
    [
      CS.CompoundAssignOp,
      function (param$) {
        var assignee, cache$2, condition, expression, inScope, op;
        {
          cache$2 = param$;
          assignee = cache$2.assignee;
          expression = cache$2.expression;
          inScope = cache$2.inScope;
        }
        op = function () {
          switch (this.op) {
          case CS.LogicalAndOp.prototype.className:
            return '&&';
          case CS.LogicalOrOp.prototype.className:
            return '||';
          case CS.ExistsOp.prototype.className:
            return '?';
          case CS.BitOrOp.prototype.className:
            return '|';
          case CS.BitXorOp.prototype.className:
            return '^';
          case CS.BitAndOp.prototype.className:
            return '&';
          case CS.LeftShiftOp.prototype.className:
            return '<<';
          case CS.SignedRightShiftOp.prototype.className:
            return '>>';
          case CS.UnsignedRightShiftOp.prototype.className:
            return '>>>';
          case CS.PlusOp.prototype.className:
            return '+';
          case CS.SubtractOp.prototype.className:
            return '-';
          case CS.MultiplyOp.prototype.className:
            return '*';
          case CS.DivideOp.prototype.className:
            return '/';
          case CS.RemOp.prototype.className:
            return '%';
          case CS.ExpOp.prototype.className:
            return '**';
          default:
            throw new Error('Unrecognised compound assignment operator');
          }
        }.call(this);
        if ((op === '&&' || op === '||' || op === '?') && assignee['instanceof'](JS.Identifier) && !in$(assignee.name, inScope))
          throw new Error('the variable "' + assignee.name + '" can\'t be assigned with ?= because it has not been defined.');
        switch (op) {
        case '&&':
        case '||':
          return new JS.LogicalExpression(op, assignee, new JS.AssignmentExpression('=', assignee, expr(expression)));
        case '?':
          condition = new JS.BinaryExpression('!=', new JS.Literal(null), assignee);
          return new JS.ConditionalExpression(condition, assignee, new JS.AssignmentExpression('=', assignee, expr(expression)));
        case '**':
          return new JS.AssignmentExpression('=', assignee, helpers.exp(assignee, expr(expression)));
        default:
          return new JS.AssignmentExpression('' + op + '=', assignee, expr(expression));
        }
      }
    ],
    [
      CS.ChainedComparisonOp,
      function (param$) {
        var cache$2, compile, expression, left, lhs;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          compile = cache$2.compile;
        }
        if (!this.expression.left['instanceof'](CS.ComparisonOps))
          return expression;
        left = expression.left.right;
        lhs = compile(new CS.ChainedComparisonOp(this.expression.left));
        if (needsCaching(this.expression.left.right)) {
          left = genSym('cache');
          if (this.expression.left.left['instanceof'](CS.ComparisonOps)) {
            lhs.right.right = new JS.AssignmentExpression('=', left, lhs.right.right);
          } else {
            lhs.right = new JS.AssignmentExpression('=', left, lhs.right);
          }
        }
        return new JS.LogicalExpression('&&', lhs, new JS.BinaryExpression(expression.operator, left, expression.right));
      }
    ],
    [
      CS.FunctionApplication,
      function (param$) {
        var args, cache$2, compile, context, lhs;
        var fn;
        {
          cache$2 = param$;
          fn = cache$2['function'];
          args = cache$2['arguments'];
          compile = cache$2.compile;
        }
        if (any(args, function (m) {
            return m.spread;
          })) {
          lhs = this['function'];
          context = new CS.Null;
          if (needsCaching(this['function'])) {
            context = new CS.GenSym('cache');
            lhs = this['function']['instanceof'](CS.StaticMemberAccessOps) ? new this['function'].constructor(new CS.AssignOp(context, lhs.expression), this['function'].memberName) : this['function']['instanceof'](CS.DynamicMemberAccessOps) ? new this['function'].constructor(new CS.AssignOp(context, lhs.expression), this['function'].indexingExpr) : new CS.AssignOp(context, lhs);
          } else if (lhs['instanceof'](CS.MemberAccessOps)) {
            context = lhs.expression;
          }
          if (this['function']['instanceof'](CS.ProtoMemberAccessOp, CS.DynamicProtoMemberAccessOp)) {
            context = new CS.MemberAccessOp(context, 'prototype');
          } else if (this['function']['instanceof'](CS.SoakedProtoMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp)) {
            context = new CS.SoakedMemberAccessOp(context, 'prototype');
          }
          return compile(new CS.FunctionApplication(new CS.MemberAccessOp(lhs, 'apply'), [
            context,
            new CS.ArrayInitialiser(this['arguments'])
          ]));
        } else if (hasSoak(this)) {
          return compile(generateSoak(this));
        } else {
          return new JS.CallExpression(expr(fn), map(args, expr));
        }
      }
    ],
    [
      CS.SoakedFunctionApplication,
      function (param$) {
        var compile;
        compile = param$.compile;
        return compile(generateSoak(this));
      }
    ],
    [
      CS.NewOp,
      function (param$) {
        var args, cache$2, compile, ctor;
        {
          cache$2 = param$;
          ctor = cache$2.ctor;
          args = cache$2['arguments'];
          compile = cache$2.compile;
        }
        if (any(args, function (m) {
            return m.spread;
          })) {
          return helpers.construct(ctor, compile(new CS.ArrayInitialiser(this['arguments'])));
        } else {
          return new JS.NewExpression(ctor, map(args, expr));
        }
      }
    ],
    [
      CS.HeregExp,
      function (param$) {
        var args, expression, flag, flags;
        expression = param$.expression;
        args = [expression];
        if (flags = function (accum$) {
            for (var cache$2 = [
                  'g',
                  'i',
                  'm',
                  'y'
                ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
              flag = cache$2[i$];
              if (!this.flags[flag])
                continue;
              accum$.push(flag);
            }
            return accum$;
          }.call(this, []).join(''))
          args.push(new JS.Literal(flags));
        return new JS.NewExpression(new JS.Identifier('RegExp'), args);
      }
    ],
    [
      CS.RegExp,
      function () {
        var flag, flags, re;
        flags = function (accum$) {
          for (var cache$2 = [
                'g',
                'i',
                'm',
                'y'
              ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
            flag = cache$2[i$];
            if (!this.flags[flag])
              continue;
            accum$.push(flag);
          }
          return accum$;
        }.call(this, []).join('');
        re = new RegExp(this.data, flags);
        return new JS.Literal(re);
      }
    ],
    [
      CS.ConcatOp,
      function (param$) {
        var ancestry, cache$2, left, leftmost, plusOp, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
          ancestry = cache$2.ancestry;
        }
        plusOp = new JS.BinaryExpression('+', expr(left), expr(right));
        if (!ancestry[0]['instanceof'](CS.ConcatOp)) {
          leftmost = plusOp;
          while (null != (null != leftmost.left ? leftmost.left.left : void 0)) {
            leftmost = leftmost.left;
          }
          if (!(leftmost.left['instanceof'](JS.Literal) && 'string' === typeof leftmost.left.value))
            leftmost.left = new JS.BinaryExpression('+', new JS.Literal(''), leftmost.left);
        }
        return plusOp;
      }
    ],
    [
      CS.MemberAccessOp,
      CS.SoakedMemberAccessOp,
      function (param$) {
        var access, cache$2, compile, expression, offset;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          compile = cache$2.compile;
        }
        if (hasSoak(this)) {
          return expr(compile(generateSoak(this)));
        } else {
          access = memberAccess(expression, this.memberName);
          if (this.raw) {
            access.property.raw = this.memberName;
            access.property.line = this.line;
            offset = this.raw.length - this.memberName.length;
            access.property.column = this.column + offset - 1;
            access.property.offset = this.offset + offset - 1;
            this.column += this.expression.raw.length;
            this.offset += this.expression.raw.length;
          }
          return access;
        }
      }
    ],
    [
      CS.ProtoMemberAccessOp,
      CS.SoakedProtoMemberAccessOp,
      function (param$) {
        var cache$2, compile, expression;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          compile = cache$2.compile;
        }
        if (hasSoak(this)) {
          return expr(compile(generateSoak(this)));
        } else {
          return memberAccess(memberAccess(expression, 'prototype'), this.memberName);
        }
      }
    ],
    [
      CS.DynamicMemberAccessOp,
      CS.SoakedDynamicMemberAccessOp,
      function (param$) {
        var cache$2, compile, expression, indexingExpr;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          indexingExpr = cache$2.indexingExpr;
          compile = cache$2.compile;
        }
        if (hasSoak(this)) {
          return expr(compile(generateSoak(this)));
        } else {
          return dynamicMemberAccess(expression, indexingExpr);
        }
      }
    ],
    [
      CS.DynamicProtoMemberAccessOp,
      CS.SoakedDynamicProtoMemberAccessOp,
      function (param$) {
        var cache$2, compile, expression, indexingExpr;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          indexingExpr = cache$2.indexingExpr;
          compile = cache$2.compile;
        }
        if (hasSoak(this)) {
          return expr(compile(generateSoak(this)));
        } else {
          return dynamicMemberAccess(memberAccess(expression, 'prototype'), indexingExpr);
        }
      }
    ],
    [
      CS.Slice,
      function (param$) {
        var args, cache$2, expression, left, right;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          left = cache$2.left;
          right = cache$2.right;
        }
        args = null != left ? [left] : null != right ? [new JS.Literal(0)] : [];
        if (null != right)
          args.push(this.isInclusive ? right['instanceof'](JS.Literal) && typeof right.data === 'number' ? new JS.Literal(right.data + 1) : new JS.LogicalExpression('||', new JS.BinaryExpression('+', new JS.UnaryExpression('+', right), new JS.Literal(1)), new JS.Literal(9e9)) : right);
        return new JS.CallExpression(memberAccess(expression, 'slice'), args);
      }
    ],
    [
      CS.ExistsOp,
      function (param$) {
        var ancestry, cache$2, condition, e, inScope, node;
        var left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
          ancestry = cache$2.ancestry;
          inScope = cache$2.inScope;
        }
        left = expr(left);
        right = expr(right);
        e = needsCaching(this.left) ? genSym('cache') : left;
        condition = new JS.BinaryExpression('!=', new JS.Literal(null), e);
        if (e['instanceof'](JS.Identifier) && !in$(e.name, inScope))
          condition = new JS.LogicalExpression('&&', new JS.BinaryExpression('!==', new JS.Literal('undefined'), new JS.UnaryExpression('typeof', e)), condition);
        node = new JS.ConditionalExpression(condition, e, right);
        if (e === left) {
          return node;
        } else {
          return new JS.SequenceExpression([
            new JS.AssignmentExpression('=', e, left),
            node
          ]);
        }
      }
    ],
    [
      CS.UnaryExistsOp,
      function (param$) {
        var cache$2, expression, inScope, nullTest, typeofTest;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          inScope = cache$2.inScope;
        }
        nullTest = new JS.BinaryExpression('!=', new JS.Literal(null), expression);
        if (expression['instanceof'](JS.Identifier) && !in$(expression.name, inScope)) {
          typeofTest = new JS.BinaryExpression('!==', new JS.Literal('undefined'), new JS.UnaryExpression('typeof', expression));
          return new JS.LogicalExpression('&&', typeofTest, nullTest);
        } else {
          return nullTest;
        }
      }
    ],
    [
      CS.DoOp,
      function () {
        var deriveArgsFromParams;
        deriveArgsFromParams = function (params) {
          var args, index, param;
          return args = function (accum$) {
            for (var i$ = 0, length$ = params.length; i$ < length$; ++i$) {
              param = params[i$];
              index = i$;
              accum$.push(function () {
                switch (false) {
                case !param['instanceof'](CS.DefaultParam):
                  params[index] = param.param;
                  return param['default'];
                case !param['instanceof'](CS.Identifier, CS.MemberAccessOp):
                  return param;
                default:
                  return helpers.undef();
                }
              }.call(this));
            }
            return accum$;
          }.call(this, []);
        };
        return function (param$) {
          var args, cache$2, compile, expression;
          {
            cache$2 = param$;
            expression = cache$2.expression;
            compile = cache$2.compile;
          }
          args = [];
          if (this.expression['instanceof'](CS.AssignOp) && this.expression.expression['instanceof'](CS.Functions)) {
            args = deriveArgsFromParams(this.expression.expression.parameters);
          } else if (this.expression['instanceof'](CS.Functions)) {
            args = deriveArgsFromParams(this.expression.parameters);
          }
          return compile(new CS.FunctionApplication(this.expression, args));
        };
      }()
    ],
    [
      CS.Return,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.ReturnStatement(expr(e));
      }
    ],
    [
      CS.Break,
      function () {
        return new JS.BreakStatement;
      }
    ],
    [
      CS.Continue,
      function () {
        return new JS.ContinueStatement;
      }
    ],
    [
      CS.Debugger,
      function () {
        return new JS.DebuggerStatement;
      }
    ],
    [
      CS.ExpOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return helpers.exp(expr(left), expr(right));
      }
    ],
    [
      CS.DivideOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('/', expr(left), expr(right));
      }
    ],
    [
      CS.MultiplyOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('*', expr(left), expr(right));
      }
    ],
    [
      CS.RemOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('%', expr(left), expr(right));
      }
    ],
    [
      CS.PlusOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('+', expr(left), expr(right));
      }
    ],
    [
      CS.SubtractOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('-', expr(left), expr(right));
      }
    ],
    [
      CS.OfOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('in', expr(left), expr(right));
      }
    ],
    [
      CS.InOp,
      function (param$) {
        var cache$2, comparisons, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        if (right['instanceof'](JS.ArrayExpression) && right.elements.length < 5) {
          switch (right.elements.length) {
          case 0:
            if (needsCaching(this.left)) {
              return new JS.SequenceExpression([
                left,
                new JS.Literal(false)
              ]);
            } else {
              return new JS.Literal(false);
            }
          case 1:
            return new JS.BinaryExpression('===', left, right.elements[0]);
          default:
            if (needsCaching(this.left)) {
              return helpers['in'](expr(left), expr(right));
            } else {
              comparisons = map(right.elements, function (e) {
                return new JS.BinaryExpression('===', left, e);
              });
              return foldl1(comparisons, function (l, r) {
                return new JS.LogicalExpression('||', l, r);
              });
            }
          }
        } else {
          return helpers['in'](expr(left), expr(right));
        }
      }
    ],
    [
      CS.ExtendsOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return helpers['extends'](expr(left), expr(right));
      }
    ],
    [
      CS.InstanceofOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('instanceof', expr(left), expr(right));
      }
    ],
    [
      CS.LogicalAndOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.LogicalExpression('&&', expr(left), expr(right));
      }
    ],
    [
      CS.LogicalOrOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.LogicalExpression('||', expr(left), expr(right));
      }
    ],
    [
      CS.EQOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('===', expr(left), expr(right));
      }
    ],
    [
      CS.NEQOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('!==', expr(left), expr(right));
      }
    ],
    [
      CS.GTEOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('>=', expr(left), expr(right));
      }
    ],
    [
      CS.GTOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('>', expr(left), expr(right));
      }
    ],
    [
      CS.LTEOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('<=', expr(left), expr(right));
      }
    ],
    [
      CS.LTOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('<', expr(left), expr(right));
      }
    ],
    [
      CS.BitAndOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('&', expr(left), expr(right));
      }
    ],
    [
      CS.BitOrOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('|', expr(left), expr(right));
      }
    ],
    [
      CS.BitXorOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('^', expr(left), expr(right));
      }
    ],
    [
      CS.LeftShiftOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('<<', expr(left), expr(right));
      }
    ],
    [
      CS.SignedRightShiftOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('>>', expr(left), expr(right));
      }
    ],
    [
      CS.UnsignedRightShiftOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('>>>', expr(left), expr(right));
      }
    ],
    [
      CS.PreDecrementOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UpdateExpression('--', true, expr(e));
      }
    ],
    [
      CS.PreIncrementOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UpdateExpression('++', true, expr(e));
      }
    ],
    [
      CS.PostDecrementOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UpdateExpression('--', false, expr(e));
      }
    ],
    [
      CS.PostIncrementOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UpdateExpression('++', false, expr(e));
      }
    ],
    [
      CS.UnaryPlusOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UnaryExpression('+', expr(e));
      }
    ],
    [
      CS.UnaryNegateOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UnaryExpression('-', expr(e));
      }
    ],
    [
      CS.LogicalNotOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UnaryExpression('!', expr(e));
      }
    ],
    [
      CS.BitNotOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UnaryExpression('~', expr(e));
      }
    ],
    [
      CS.TypeofOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UnaryExpression('typeof', expr(e));
      }
    ],
    [
      CS.DeleteOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UnaryExpression('delete', expr(e));
      }
    ],
    [
      CS.Identifier,
      function () {
        return new JS.Identifier(this.data);
      }
    ],
    [
      CS.GenSym,
      function () {
        var memos, symbols;
        symbols = [];
        memos = [];
        return function () {
          var memo;
          if (in$(this, symbols)) {
            return memos[symbols.indexOf(this)];
          } else {
            symbols.push(this);
            memos.push(memo = genSym(this.data));
            return memo;
          }
        };
      }()
    ],
    [
      CS.Bool,
      CS.Int,
      CS.Float,
      CS.String,
      function () {
        return new JS.Literal(this.data);
      }
    ],
    [
      CS.Null,
      function () {
        return new JS.Literal(null);
      }
    ],
    [
      CS.Undefined,
      function () {
        return helpers.undef();
      }
    ],
    [
      CS.This,
      function () {
        return new JS.ThisExpression;
      }
    ],
    [
      CS.JavaScript,
      function () {
        return new JS.CallExpression(new JS.Identifier('eval'), [new JS.Literal(this.data)]);
      }
    ]
  ];
  function Compiler() {
    var cache$2, ctor, ctors, handler, size$;
    this.rules = {};
    for (var i$ = 0, length$ = defaultRules.length; i$ < length$; ++i$) {
      {
        cache$2 = defaultRules[i$];
        size$ = cache$2.length;
        ctors = size$ > 1 ? [].slice.call(cache$2, 0, size$ - 1) : [];
        handler = cache$2[size$ - 1];
      }
      for (var i$1 = 0, length$1 = ctors.length; i$1 < length$1; ++i$1) {
        ctor = ctors[i$1];
        this.addRule(ctor, handler);
      }
    }
  }
  Compiler.prototype.addRule = function (ctor, handler) {
    this.rules[ctor.prototype.className] = handler;
    return this;
  };
  Compiler.prototype.compile = function () {
    var defaultRule, generateSymbols, walk;
    walk = function (fn, inScope, ancestry, options) {
      var child, childName, children, jsNode, member;
      if ((null != ancestry[0] ? ancestry[0]['instanceof'](CS.Function, CS.BoundFunction) : void 0) && this === ancestry[0].body)
        inScope = union(inScope, concatMap(ancestry[0].parameters, beingDeclared));
      ancestry.unshift(this);
      children = {};
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        childName = this.childNodes[i$];
        if (!(null != this[childName]))
          continue;
        children[childName] = in$(childName, this.listMembers) ? function (accum$) {
          for (var i$1 = 0, length$1 = this[childName].length; i$1 < length$1; ++i$1) {
            member = this[childName][i$1];
            jsNode = walk.call(member, fn, inScope, ancestry);
            inScope = union(inScope, envEnrichments(member, inScope));
            accum$.push(jsNode);
          }
          return accum$;
        }.call(this, []) : (child = this[childName], jsNode = walk.call(child, fn, inScope, ancestry), inScope = union(inScope, envEnrichments(child, inScope)), jsNode);
      }
      children.inScope = inScope;
      children.ancestry = ancestry;
      children.options = options;
      children.compile = function (node) {
        return walk.call(node, fn, inScope, ancestry);
      };
      ancestry.shift();
      jsNode = fn.call(this, children);
      jsNode.raw = this.raw;
      jsNode.line = this.line;
      jsNode.column = this.column - 1;
      jsNode.offset = this.offset;
      return jsNode;
    };
    generateSymbols = function () {
      var format, generateChildSymbols, generatedSymbols, generateName;
      generatedSymbols = {};
      format = function (pre, counter) {
        var cache$2, div, mod;
        if (pre) {
          return '' + pre + '$' + (counter || '');
        } else if (counter < 26) {
          return String.fromCharCode(97 + counter);
        } else {
          cache$2 = divMod(counter, 26);
          div = cache$2[0];
          mod = cache$2[1];
          return format(pre, div - 1) + format(pre, mod);
        }
      };
      generateName = function (node, param$) {
        var cache$2, formatted, nsCounters, usedSymbols;
        {
          cache$2 = param$;
          usedSymbols = cache$2.usedSymbols;
          nsCounters = cache$2.nsCounters;
        }
        if (owns(generatedSymbols, node.uniqueId)) {
          return generatedSymbols[node.uniqueId];
        } else {
          nsCounters[node.ns] = owns(nsCounters, node.ns) ? 1 + nsCounters[node.ns] : 0;
          while (in$(formatted = format(node.ns, nsCounters[node.ns]), usedSymbols)) {
            ++nsCounters[node.ns];
          }
          return generatedSymbols[node.uniqueId] = formatted;
        }
      };
      generateChildSymbols = generateMutatingWalker(function (state) {
        var alreadyDeclared, cache$2, declaredSymbols, declNames, decls, k, newNode, nsCounters, nsCounters_, params, undeclared, usedSymbols, v;
        state.declaredSymbols = union(state.declaredSymbols, declarationsNeeded(this));
        cache$2 = state;
        declaredSymbols = cache$2.declaredSymbols;
        usedSymbols = cache$2.usedSymbols;
        nsCounters = cache$2.nsCounters;
        newNode = this['instanceof'](JS.GenSym) ? (newNode = new JS.Identifier(generateName(this, state)), usedSymbols.push(newNode.name), newNode) : isScopeBoundary(this) ? (params = concatMap(this.params, collectIdentifiers), nsCounters_ = {}, function (accum$) {
          for (k in nsCounters) {
            if (!isOwn$(nsCounters, k))
              continue;
            v = nsCounters[k];
            accum$.push(nsCounters_[k] = v);
          }
          return accum$;
        }.call(this, []), newNode = generateChildSymbols(this, {
          declaredSymbols: union(declaredSymbols, params),
          usedSymbols: union(usedSymbols, params),
          nsCounters: nsCounters_
        }), newNode.body = forceBlock(newNode.body), undeclared = declarationsNeededRecursive(this.body), undeclared = difference(undeclared, map(variableDeclarations(this.body), function (id) {
          return id.name;
        })), alreadyDeclared = union(declaredSymbols, concatMap(this.params, collectIdentifiers)), declNames = nub(difference(undeclared, alreadyDeclared)), decls = map(declNames, function (name) {
          return new JS.Identifier(name);
        }), decls.length > 0 ? newNode.body.body.unshift(makeVarDeclaration(decls)) : void 0, newNode) : generateChildSymbols(this, state);
        state.declaredSymbols = union(declaredSymbols, declarationsNeededRecursive(newNode));
        return newNode;
      });
      return function (jsAST, state) {
        var inScope, needed, program;
        inScope = (null != state.declaredSymbols ? state.declaredSymbols : []).slice();
        program = generateChildSymbols(jsAST, state);
        if (program['instanceof'](JS.Program)) {
          needed = nub(difference(concatMap(program.body, declarationsNeededRecursive), inScope));
          if (needed.length > 0)
            program.body.unshift(makeVarDeclaration(needed.map(function (n) {
              return new JS.Identifier(n);
            })));
        }
        return program;
      };
    }();
    defaultRule = function () {
      throw new Error('compile: Non-exhaustive patterns in case: ' + this.className);
    };
    return function (ast, options) {
      var inScope, jsAST, rules;
      if (null == options)
        options = {};
      if (null != options.bare)
        options.bare;
      else
        options.bare = false;
      rules = this.rules;
      inScope = null != options.inScope ? options.inScope : [];
      jsAST = walk.call(ast, function () {
        return (null != rules[this.className] ? rules[this.className] : defaultRule).apply(this, arguments);
      }, inScope, [], options);
      return generateSymbols(jsAST, {
        declaredSymbols: inScope,
        usedSymbols: union(jsReserved.slice(), collectIdentifiers(jsAST)),
        nsCounters: {}
      });
    };
  }();
  return Compiler;
}();
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}
function isOwn$(o, p) {
  return {}.hasOwnProperty.call(o, p);
}

},{"./../package.json":30,"./functional-helpers":2,"./helpers":3,"./js-nodes":4,"./nodes":6}],2:[function(require,module,exports){
// Generated by CoffeeScript 2.0.0-beta9-dev
var concat, foldl, map, nub, span;
this.any = function (list, fn) {
  var e;
  for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
    e = list[i$];
    if (fn(e))
      return true;
  }
  return false;
};
this.all = function (list, fn) {
  var e;
  for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
    e = list[i$];
    if (!fn(e))
      return false;
  }
  return true;
};
this.foldl = foldl = function (memo, list, fn) {
  var i;
  for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
    i = list[i$];
    memo = fn(memo, i);
  }
  return memo;
};
this.foldl1 = function (list, fn) {
  return foldl(list[0], list.slice(1), fn);
};
this.map = map = function (list, fn) {
  var e;
  return function (accum$) {
    for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
      e = list[i$];
      accum$.push(fn(e));
    }
    return accum$;
  }.call(this, []);
};
this.concat = concat = function (list) {
  var cache$;
  return (cache$ = []).concat.apply(cache$, [].slice.call(list));
};
this.concatMap = function (list, fn) {
  return concat(map(list, fn));
};
this.intersect = function (listA, listB) {
  var a;
  return function (accum$) {
    for (var i$ = 0, length$ = listA.length; i$ < length$; ++i$) {
      a = listA[i$];
      if (!in$(a, listB))
        continue;
      accum$.push(a);
    }
    return accum$;
  }.call(this, []);
};
this.difference = function (listA, listB) {
  var a;
  return function (accum$) {
    for (var i$ = 0, length$ = listA.length; i$ < length$; ++i$) {
      a = listA[i$];
      if (!!in$(a, listB))
        continue;
      accum$.push(a);
    }
    return accum$;
  }.call(this, []);
};
this.nub = nub = function (list) {
  var i, result;
  result = [];
  for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
    i = list[i$];
    if (!!in$(i, result))
      continue;
    result.push(i);
  }
  return result;
};
this.union = function (listA, listB) {
  var b;
  return listA.concat(function (accum$) {
    for (var cache$ = nub(listB), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
      b = cache$[i$];
      if (!!in$(b, listA))
        continue;
      accum$.push(b);
    }
    return accum$;
  }.call(this, []));
};
this.flip = function (fn) {
  return function (b, a) {
    return fn.call(this, a, b);
  };
};
this.owns = function (hop) {
  return function (a, b) {
    return hop.call(a, b);
  };
}({}.hasOwnProperty);
this.span = span = function (list, f) {
  var cache$, ys, zs;
  if (list.length === 0) {
    return [
      [],
      []
    ];
  } else if (f(list[0])) {
    cache$ = span(list.slice(1), f);
    ys = cache$[0];
    zs = cache$[1];
    return [
      [list[0]].concat([].slice.call(ys)),
      zs
    ];
  } else {
    return [
      [],
      list
    ];
  }
};
this.divMod = function (a, b) {
  var c, div, mod;
  c = a % b;
  mod = c < 0 ? c + b : c;
  div = Math.floor(a / b);
  return [
    div,
    mod
  ];
};
this.partition = function (list, fn) {
  var item, result;
  result = [
    [],
    []
  ];
  for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
    item = list[i$];
    result[+!fn(item)].push(item);
  }
  return result;
};
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

},{}],3:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 2.0.0-beta9-dev
var beingDeclared, cache$, cleanMarkers, colourise, COLOURS, concat, concatMap, CS, difference, envEnrichments, envEnrichments_, foldl, humanReadable, map, nub, numberLines, pointToErrorLocation, SUPPORTS_COLOUR, usedAsExpression, usedAsExpression_;
cache$ = require('./functional-helpers');
concat = cache$.concat;
concatMap = cache$.concatMap;
difference = cache$.difference;
foldl = cache$.foldl;
map = cache$.map;
nub = cache$.nub;
CS = require('./nodes');
COLOURS = {
  red: '\x1B[31m',
  green: '\x1B[32m',
  yellow: '\x1B[33m',
  blue: '\x1B[34m',
  magenta: '\x1B[35m',
  cyan: '\x1B[36m'
};
SUPPORTS_COLOUR = ('undefined' !== typeof process && null != process && null != process.stderr ? process.stderr.isTTY : void 0) && !process.env.NODE_DISABLE_COLORS;
colourise = function (colour, str) {
  if (SUPPORTS_COLOUR) {
    return '' + COLOURS[colour] + str + '\x1B[39m';
  } else {
    return str;
  }
};
this.numberLines = numberLines = function (input, startLine) {
  var currLine, i, line, lines, numbered, pad, padSize;
  if (null == startLine)
    startLine = 1;
  lines = input.split('\n');
  padSize = ('' + (lines.length + startLine - 1)).length;
  numbered = function (accum$) {
    for (var i$ = 0, length$ = lines.length; i$ < length$; ++i$) {
      line = lines[i$];
      i = i$;
      currLine = '' + (i + startLine);
      pad = Array(padSize + 1).join('0').slice(currLine.length);
      accum$.push('' + pad + currLine + ' : ' + lines[i]);
    }
    return accum$;
  }.call(this, []);
  return numbered.join('\n');
};
cleanMarkers = function (str) {
  return str.replace(/[\uEFEF\uEFFE\uEFFF]/g, '');
};
this.humanReadable = humanReadable = function (str) {
  return str.replace(/\uEFEF/g, '(INDENT)').replace(/\uEFFE/g, '(DEDENT)').replace(/\uEFFF/g, '(TERM)');
};
this.formatParserError = function (input, e) {
  var found, message, realColumn, unicode;
  realColumn = cleanMarkers(('' + input.split('\n')[e.line - 1] + '\n').slice(0, e.column)).length;
  if (!(null != e.found))
    return 'Syntax error on line ' + e.line + ', column ' + realColumn + ': unexpected end of input';
  found = JSON.stringify(humanReadable(e.found));
  found = found.replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"');
  unicode = e.found.charCodeAt(0).toString(16).toUpperCase();
  unicode = '\\u' + '0000'.slice(unicode.length) + unicode;
  message = 'Syntax error on line ' + e.line + ', column ' + realColumn + ": unexpected '" + found + "' (" + unicode + ')';
  return '' + message + '\n' + pointToErrorLocation(input, e.line, realColumn);
};
this.pointToErrorLocation = pointToErrorLocation = function (source, line, column, numLinesOfContext) {
  var currentLineOffset, lines, numberedLines, padSize, postLines, preLines, startLine;
  if (null == numLinesOfContext)
    numLinesOfContext = 3;
  lines = source.split('\n');
  if (!lines[lines.length - 1])
    lines.pop();
  currentLineOffset = line - 1;
  startLine = currentLineOffset - numLinesOfContext;
  if (startLine < 0)
    startLine = 0;
  preLines = lines.slice(startLine, +currentLineOffset + 1 || 9e9);
  preLines[preLines.length - 1] = colourise('yellow', preLines[preLines.length - 1]);
  postLines = lines.slice(currentLineOffset + 1, +(currentLineOffset + numLinesOfContext) + 1 || 9e9);
  numberedLines = numberLines(cleanMarkers([].slice.call(preLines).concat([].slice.call(postLines)).join('\n')), startLine + 1).split('\n');
  preLines = numberedLines.slice(0, preLines.length);
  postLines = numberedLines.slice(preLines.length);
  column = cleanMarkers(('' + lines[currentLineOffset] + '\n').slice(0, column)).length;
  padSize = (currentLineOffset + 1 + postLines.length).toString(10).length;
  return [].slice.call(preLines).concat(['' + colourise('red', Array(padSize + 1).join('^')) + ' : ' + Array(column).join(' ') + colourise('red', '^')], [].slice.call(postLines)).join('\n');
};
this.beingDeclared = beingDeclared = function (assignment) {
  switch (false) {
  case !!(null != assignment):
    return [];
  case !assignment['instanceof'](CS.Identifiers):
    return [assignment.data];
  case !assignment['instanceof'](CS.Rest):
    return beingDeclared(assignment.expression);
  case !assignment['instanceof'](CS.MemberAccessOps):
    return [];
  case !assignment['instanceof'](CS.DefaultParam):
    return beingDeclared(assignment.param);
  case !assignment['instanceof'](CS.ArrayInitialiser):
    return concatMap(assignment.members, beingDeclared);
  case !assignment['instanceof'](CS.ObjectInitialiser):
    return concatMap(assignment.vals(), beingDeclared);
  default:
    throw new Error('beingDeclared: Non-exhaustive patterns in case: ' + assignment.className);
  }
};
this.declarationsFor = function (node, inScope) {
  var vars;
  vars = envEnrichments(node, inScope);
  return foldl(new CS.Undefined().g(), vars, function (expr, v) {
    return new CS.AssignOp(new CS.Identifier(v).g(), expr).g();
  });
};
usedAsExpression_ = function (ancestors) {
  var grandparent, parent;
  parent = ancestors[0];
  grandparent = ancestors[1];
  switch (false) {
  case !!(null != parent):
    return true;
  case !parent['instanceof'](CS.Program, CS.Class):
    return false;
  case !parent['instanceof'](CS.SeqOp):
    return this === parent.right && usedAsExpression(parent, ancestors.slice(1));
  case !(parent['instanceof'](CS.Block) && parent.statements.indexOf(this) !== parent.statements.length - 1):
    return false;
  case !(parent['instanceof'](CS.Functions) && parent.body === this && null != grandparent && grandparent['instanceof'](CS.Constructor)):
    return false;
  default:
    return true;
  }
};
this.usedAsExpression = usedAsExpression = function (node, ancestors) {
  return usedAsExpression_.call(node, ancestors);
};
envEnrichments_ = function (inScope) {
  var possibilities;
  if (null == inScope)
    inScope = [];
  possibilities = nub(function () {
    switch (false) {
    case !this['instanceof'](CS.AssignOp):
      return concat([
        beingDeclared(this.assignee),
        envEnrichments(this.expression)
      ]);
    case !this['instanceof'](CS.Class):
      return concat([
        beingDeclared(this.nameAssignee),
        envEnrichments(this.parent)
      ]);
    case !this['instanceof'](CS.ForIn, CS.ForOf):
      return concat([
        beingDeclared(this.keyAssignee),
        beingDeclared(this.valAssignee),
        envEnrichments(this.target),
        envEnrichments(this.step),
        envEnrichments(this.filter),
        envEnrichments(this.body)
      ]);
    case !this['instanceof'](CS.Try):
      return concat([
        beingDeclared(this.catchAssignee),
        envEnrichments(this.body),
        envEnrichments(this.catchBody),
        envEnrichments(this.finallyBody)
      ]);
    case !this['instanceof'](CS.Functions):
      return [];
    default:
      return concatMap(this.childNodes, function (this$) {
        return function (child) {
          if (in$(child, this$.listMembers)) {
            return concatMap(this$[child], function (m) {
              return envEnrichments(m, inScope);
            });
          } else {
            return envEnrichments(this$[child], inScope);
          }
        };
      }(this));
    }
  }.call(this));
  return difference(possibilities, inScope);
};
this.envEnrichments = envEnrichments = function (node) {
  var args;
  args = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
  if (null != node) {
    return envEnrichments_.apply(node, args);
  } else {
    return [];
  }
};
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

}).call(this,require("JkpR2F"))
},{"./functional-helpers":2,"./nodes":6,"JkpR2F":34}],4:[function(require,module,exports){
// Generated by CoffeeScript 2.0.0-beta9-dev
var ArrayExpression, AssignmentExpression, BinaryExpression, BlockStatement, cache$, cache$1, CallExpression, createNode, ctor, difference, exports, FunctionDeclaration, FunctionExpression, GenSym, handleLists, handlePrimitives, Identifier, isStatement, Literal, LogicalExpression, MemberExpression, NewExpression, node, nodeData, Nodes, ObjectExpression, params, Program, SequenceExpression, SwitchCase, SwitchStatement, TryStatement, UnaryExpression, UpdateExpression, VariableDeclaration;
difference = require('./functional-helpers').difference;
exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
createNode = function (type, props) {
  return function (super$) {
    extends$(class$, super$);
    function class$() {
      var i, prop;
      for (var i$ = 0, length$ = props.length; i$ < length$; ++i$) {
        prop = props[i$];
        i = i$;
        this[prop] = arguments[i];
      }
    }
    class$.prototype.type = type;
    class$.prototype.childNodes = props;
    return class$;
  }(Nodes);
};
this.Nodes = Nodes = function () {
  function Nodes() {
  }
  Nodes.prototype.listMembers = [];
  Nodes.prototype['instanceof'] = function () {
    var ctor, ctors;
    ctors = arguments.length > 0 ? [].slice.call(arguments, 0) : [];
    for (var i$ = 0, length$ = ctors.length; i$ < length$; ++i$) {
      ctor = ctors[i$];
      if (!(this.type === ctor.prototype.type))
        continue;
      return true;
    }
    return false;
  };
  Nodes.prototype.toBasicObject = function () {
    var child, obj, p;
    obj = { type: this.type };
    if (null != this.leadingComments)
      obj.leadingComments = this.leadingComments;
    for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
      child = this.childNodes[i$];
      if (in$(child, this.listMembers)) {
        obj[child] = function (accum$) {
          for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
            p = this[child][i$1];
            accum$.push('undefined' !== typeof p && null != p ? p.toBasicObject() : void 0);
          }
          return accum$;
        }.call(this, []);
      } else {
        obj[child] = null != this[child] ? this[child].toBasicObject() : void 0;
      }
    }
    if (null != this.line && null != this.column)
      obj.loc = {
        start: {
          line: this.line,
          column: this.column
        }
      };
    if (null != this.offset)
      obj.range = [
        this.offset,
        null != this.raw ? this.offset + this.raw.length : void 0
      ];
    if (null != this.raw)
      obj.raw = this.raw;
    return obj;
  };
  return Nodes;
}();
nodeData = [
  [
    'ArrayExpression',
    false,
    ['elements']
  ],
  [
    'AssignmentExpression',
    false,
    [
      'operator',
      'left',
      'right'
    ]
  ],
  [
    'BinaryExpression',
    false,
    [
      'operator',
      'left',
      'right'
    ]
  ],
  [
    'BlockStatement',
    true,
    ['body']
  ],
  [
    'BreakStatement',
    true,
    ['label']
  ],
  [
    'CallExpression',
    false,
    [
      'callee',
      'arguments'
    ]
  ],
  [
    'CatchClause',
    true,
    [
      'param',
      'body'
    ]
  ],
  [
    'ConditionalExpression',
    false,
    [
      'test',
      'consequent',
      'alternate'
    ]
  ],
  [
    'ContinueStatement',
    true,
    ['label']
  ],
  [
    'DebuggerStatement',
    true,
    []
  ],
  [
    'DoWhileStatement',
    true,
    [
      'body',
      'test'
    ]
  ],
  [
    'EmptyStatement',
    true,
    []
  ],
  [
    'ExpressionStatement',
    true,
    ['expression']
  ],
  [
    'ForInStatement',
    true,
    [
      'left',
      'right',
      'body'
    ]
  ],
  [
    'ForStatement',
    true,
    [
      'init',
      'test',
      'update',
      'body'
    ]
  ],
  [
    'FunctionDeclaration',
    true,
    [
      'id',
      'params',
      'body'
    ]
  ],
  [
    'FunctionExpression',
    false,
    [
      'id',
      'params',
      'body'
    ]
  ],
  [
    'GenSym',
    false,
    [
      'ns',
      'uniqueId'
    ]
  ],
  [
    'Identifier',
    false,
    ['name']
  ],
  [
    'IfStatement',
    true,
    [
      'test',
      'consequent',
      'alternate'
    ]
  ],
  [
    'LabeledStatement',
    true,
    [
      'label',
      'body'
    ]
  ],
  [
    'Literal',
    false,
    ['value']
  ],
  [
    'LogicalExpression',
    false,
    [
      'operator',
      'left',
      'right'
    ]
  ],
  [
    'MemberExpression',
    false,
    [
      'computed',
      'object',
      'property'
    ]
  ],
  [
    'NewExpression',
    false,
    [
      'callee',
      'arguments'
    ]
  ],
  [
    'ObjectExpression',
    false,
    ['properties']
  ],
  [
    'Program',
    true,
    ['body']
  ],
  [
    'Property',
    true,
    [
      'key',
      'value'
    ]
  ],
  [
    'ReturnStatement',
    true,
    ['argument']
  ],
  [
    'SequenceExpression',
    false,
    ['expressions']
  ],
  [
    'SwitchCase',
    true,
    [
      'test',
      'consequent'
    ]
  ],
  [
    'SwitchStatement',
    true,
    [
      'discriminant',
      'cases'
    ]
  ],
  [
    'ThisExpression',
    false,
    []
  ],
  [
    'ThrowStatement',
    true,
    ['argument']
  ],
  [
    'TryStatement',
    true,
    [
      'block',
      'handlers',
      'finalizer'
    ]
  ],
  [
    'UnaryExpression',
    false,
    [
      'operator',
      'argument'
    ]
  ],
  [
    'UpdateExpression',
    false,
    [
      'operator',
      'prefix',
      'argument'
    ]
  ],
  [
    'VariableDeclaration',
    true,
    [
      'kind',
      'declarations'
    ]
  ],
  [
    'VariableDeclarator',
    true,
    [
      'id',
      'init'
    ]
  ],
  [
    'WhileStatement',
    true,
    [
      'test',
      'body'
    ]
  ],
  [
    'WithStatement',
    true,
    [
      'object',
      'body'
    ]
  ]
];
for (var i$ = 0, length$ = nodeData.length; i$ < length$; ++i$) {
  {
    cache$ = nodeData[i$];
    node = cache$[0];
    isStatement = cache$[1];
    params = cache$[2];
  }
  exports[node] = ctor = createNode(node, params);
  ctor.prototype.isStatement = isStatement;
  ctor.prototype.isExpression = !isStatement;
}
cache$1 = exports;
Program = cache$1.Program;
BlockStatement = cache$1.BlockStatement;
Literal = cache$1.Literal;
Identifier = cache$1.Identifier;
FunctionExpression = cache$1.FunctionExpression;
CallExpression = cache$1.CallExpression;
SequenceExpression = cache$1.SequenceExpression;
ArrayExpression = cache$1.ArrayExpression;
BinaryExpression = cache$1.BinaryExpression;
UnaryExpression = cache$1.UnaryExpression;
NewExpression = cache$1.NewExpression;
VariableDeclaration = cache$1.VariableDeclaration;
ObjectExpression = cache$1.ObjectExpression;
MemberExpression = cache$1.MemberExpression;
UpdateExpression = cache$1.UpdateExpression;
AssignmentExpression = cache$1.AssignmentExpression;
LogicalExpression = cache$1.LogicalExpression;
GenSym = cache$1.GenSym;
FunctionDeclaration = cache$1.FunctionDeclaration;
VariableDeclaration = cache$1.VariableDeclaration;
SwitchStatement = cache$1.SwitchStatement;
SwitchCase = cache$1.SwitchCase;
TryStatement = cache$1.TryStatement;
handlePrimitives = function (ctor, primitives) {
  ctor.prototype.childNodes = difference(ctor.prototype.childNodes, primitives);
  return ctor.prototype.toBasicObject = function () {
    var obj, primitive;
    obj = Nodes.prototype.toBasicObject.call(this);
    for (var i$1 = 0, length$1 = primitives.length; i$1 < length$1; ++i$1) {
      primitive = primitives[i$1];
      obj[primitive] = this[primitive];
    }
    return obj;
  };
};
handlePrimitives(AssignmentExpression, ['operator']);
handlePrimitives(BinaryExpression, ['operator']);
handlePrimitives(LogicalExpression, ['operator']);
handlePrimitives(GenSym, [
  'ns',
  'uniqueId'
]);
handlePrimitives(Identifier, ['name']);
handlePrimitives(Literal, ['value']);
handlePrimitives(MemberExpression, ['computed']);
handlePrimitives(UnaryExpression, ['operator']);
handlePrimitives(UpdateExpression, [
  'operator',
  'prefix'
]);
handlePrimitives(VariableDeclaration, ['kind']);
handleLists = function (ctor, listProps) {
  return ctor.prototype.listMembers = listProps;
};
handleLists(ArrayExpression, ['elements']);
handleLists(BlockStatement, ['body']);
handleLists(CallExpression, ['arguments']);
handleLists(FunctionDeclaration, ['params']);
handleLists(FunctionExpression, ['params']);
handleLists(NewExpression, ['arguments']);
handleLists(ObjectExpression, ['properties']);
handleLists(Program, ['body']);
handleLists(SequenceExpression, ['expressions']);
handleLists(SwitchCase, ['consequent']);
handleLists(SwitchStatement, ['cases']);
handleLists(TryStatement, ['handlers']);
handleLists(VariableDeclaration, ['declarations']);
FunctionDeclaration.prototype.generated = FunctionExpression.prototype.generated = false;
FunctionDeclaration.prototype.g = FunctionExpression.prototype.g = function () {
  this.generated = true;
  return this;
};
function isOwn$(o, p) {
  return {}.hasOwnProperty.call(o, p);
}
function extends$(child, parent) {
  for (var key in parent)
    if (isOwn$(parent, key))
      child[key] = parent[key];
  function ctor() {
    this.constructor = child;
  }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

},{"./functional-helpers":2}],5:[function(require,module,exports){
// Generated by CoffeeScript 2.0.0-beta9-dev
var CoffeeScript, Compiler, cscodegen, escodegen, escodegenFormat, ext, formatParserError, Nodes, Optimiser, Parser, pkg, Preprocessor;
formatParserError = require('./helpers').formatParserError;
Nodes = require('./nodes');
Preprocessor = require('./preprocessor').Preprocessor;
Parser = require('./parser');
Optimiser = require('./optimiser').Optimiser;
Compiler = require('./compiler').Compiler;
cscodegen = function () {
  try {
    return require('cscodegen');
  } catch (e$) {
    return;
  }
}.call(this);
escodegen = function () {
  try {
    return require('escodegen');
  } catch (e$1) {
    return;
  }
}.call(this);
pkg = require('./../package.json');
escodegenFormat = {
  indent: {
    style: '  ',
    base: 0
  },
  renumber: true,
  hexadecimal: true,
  quotes: 'auto',
  parentheses: false
};
CoffeeScript = {
  CoffeeScript: CoffeeScript,
  Compiler: Compiler,
  Optimiser: Optimiser,
  Parser: Parser,
  Preprocessor: Preprocessor,
  Nodes: Nodes,
  VERSION: pkg.version,
  parse: function (coffee, options) {
    var e, parsed, preprocessed;
    if (null == options)
      options = {};
    try {
      preprocessed = Preprocessor.process(coffee, { literate: options.literate });
      parsed = Parser.parse(preprocessed, {
        raw: options.raw,
        inputSource: options.inputSource
      });
      if (options.optimise) {
        return Optimiser.optimise(parsed);
      } else {
        return parsed;
      }
    } catch (e$2) {
      e = e$2;
      if (!(e instanceof Parser.SyntaxError))
        throw e;
      throw new Error(formatParserError(preprocessed, e));
    }
  },
  compile: function (csAst, options) {
    return Compiler.compile(csAst, options).toBasicObject();
  },
  cs: function (csAst, options) {
  },
  jsWithSourceMap: function (jsAst, name, options) {
    var targetName;
    if (null == name)
      name = 'unknown';
    if (null == options)
      options = {};
    if (!(null != escodegen))
      throw new Error('escodegen not found: run `npm install escodegen`');
    if (!{}.hasOwnProperty.call(jsAst, 'type'))
      jsAst = jsAst.toBasicObject();
    targetName = options.sourceMapFile || options.sourceMap && options.output.match(/^.*[\\\/]([^\\\/]+)$/)[1];
    return escodegen.generate(jsAst, {
      comment: !options.compact,
      sourceMapWithCode: true,
      sourceMap: name,
      file: targetName || 'unknown',
      format: options.compact ? escodegen.FORMAT_MINIFY : null != options.format ? options.format : escodegenFormat
    });
  },
  js: function (jsAst, options) {
    return this.jsWithSourceMap(jsAst, null, options).code;
  },
  sourceMap: function (jsAst, name, options) {
    return this.jsWithSourceMap(jsAst, name, options).map;
  },
  cs2js: function (input, options) {
    var csAST, jsAST;
    if (null == options)
      options = {};
    if (null != options.optimise)
      options.optimise;
    else
      options.optimise = true;
    csAST = CoffeeScript.parse(input, options);
    jsAST = CoffeeScript.compile(csAST, { bare: options.bare });
    return CoffeeScript.js(jsAST, { compact: options.compact || options.minify });
  }
};
module.exports = CoffeeScript;
if (null != (null != require.extensions ? require.extensions['.node'] : void 0)) {
  CoffeeScript.register = function () {
    return require('./register');
  };
  for (var cache$ = [
        '.coffee',
        '.litcoffee'
      ], i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
    ext = cache$[i$];
    if (null != require.extensions[ext])
      require.extensions[ext];
    else
      require.extensions[ext] = function () {
        throw new Error('Use CoffeeScript.register() or require the coffee-script-redux/register module to require ' + ext + ' files.');
      };
  }
}

},{"./../package.json":30,"./compiler":1,"./helpers":3,"./nodes":6,"./optimiser":7,"./parser":8,"./preprocessor":9,"./register":10,"cscodegen":13,"escodegen":14}],6:[function(require,module,exports){
// Generated by CoffeeScript 2.0.0-beta9-dev
var ArrayInitialiser, Block, Bool, cache$, cache$1, Class, CompoundAssignOp, concat, concatMap, Conditional, createNodes, difference, exports, ForOf, FunctionApplications, Functions, GenSym, handleLists, handlePrimitives, HeregExp, Identifier, Identifiers, map, NegatedConditional, NewOp, Nodes, nub, ObjectInitialiser, Primitives, Range, RegExp, RegExps, Slice, StaticMemberAccessOps, Super, Switch, SwitchCase, union, While;
cache$ = require('./functional-helpers');
map = cache$.map;
concat = cache$.concat;
concatMap = cache$.concatMap;
difference = cache$.difference;
nub = cache$.nub;
union = cache$.union;
exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
createNodes = function (subclasses, superclasses) {
  var className, specs;
  if (null == superclasses)
    superclasses = [];
  for (className in subclasses) {
    if (!isOwn$(subclasses, className))
      continue;
    specs = subclasses[className];
    (function (className) {
      var externalCtor$, isCategory, klass, params, superclass;
      superclass = null != superclasses[0] ? superclasses[0] : function () {
      };
      isCategory = 'undefined' !== typeof specs && null != specs && specs.length === 2;
      params = 'undefined' !== typeof specs && null != specs ? function () {
        switch (specs.length) {
        case 0:
          return [];
        case 1:
        case 2:
          return specs[0];
        }
      }.call(this) : null;
      if (null != params)
        params;
      else
        params = null != superclass.prototype.childNodes ? superclass.prototype.childNodes : [];
      klass = function (super$) {
        extends$(class$, super$);
        externalCtor$ = isCategory ? function () {
        } : function () {
          var i, param;
          for (var i$ = 0, length$ = params.length; i$ < length$; ++i$) {
            param = params[i$];
            i = i$;
            this[param] = arguments[i];
          }
          if (null != this.initialise)
            this.initialise.apply(this, arguments);
          return this;
        };
        function class$() {
          return externalCtor$.apply(this, arguments);
        }
        class$.prototype.className = className;
        class$.superclasses = superclasses;
        return class$;
      }(superclass);
      if (null != ('undefined' !== typeof specs && null != specs ? specs[0] : void 0))
        klass.prototype.childNodes = specs[0];
      if (isCategory)
        createNodes(specs[1], [klass].concat([].slice.call(superclasses)));
      return exports[className] = klass;
    }(className));
  }
};
createNodes({
  Nodes: [
    [],
    {
      BinOps: [
        [
          'left',
          'right'
        ],
        {
          AssignOps: [
            [
              'assignee',
              'expression'
            ],
            {
              AssignOp: null,
              ClassProtoAssignOp: null,
              CompoundAssignOp: [[
                  'op',
                  'assignee',
                  'expression'
                ]]
            }
          ],
          BitOps: [
            null,
            {
              BitAndOp: null,
              BitOrOp: null,
              BitXorOp: null,
              LeftShiftOp: null,
              SignedRightShiftOp: null,
              UnsignedRightShiftOp: null
            }
          ],
          ComparisonOps: [
            null,
            {
              EQOp: null,
              GTEOp: null,
              GTOp: null,
              LTEOp: null,
              LTOp: null,
              NEQOp: null
            }
          ],
          ConcatOp: null,
          ExistsOp: null,
          ExtendsOp: null,
          InOp: null,
          InstanceofOp: null,
          LogicalOps: [
            null,
            {
              LogicalAndOp: null,
              LogicalOrOp: null
            }
          ],
          MathsOps: [
            null,
            {
              ExpOp: null,
              DivideOp: null,
              MultiplyOp: null,
              RemOp: null,
              SubtractOp: null
            }
          ],
          OfOp: null,
          PlusOp: null,
          Range: [[
              'isInclusive',
              'left',
              'right'
            ]],
          SeqOp: null
        }
      ],
      Statements: [
        [],
        {
          Break: null,
          Continue: null,
          Debugger: null,
          Return: [['expression']],
          Throw: [['expression']]
        }
      ],
      UnaryOps: [
        ['expression'],
        {
          BitNotOp: null,
          DeleteOp: null,
          DoOp: null,
          LogicalNotOp: null,
          NewOp: [[
              'ctor',
              'arguments'
            ]],
          PreDecrementOp: null,
          PreIncrementOp: null,
          PostDecrementOp: null,
          PostIncrementOp: null,
          TypeofOp: null,
          UnaryExistsOp: null,
          UnaryNegateOp: null,
          UnaryPlusOp: null
        }
      ],
      MemberAccessOps: [
        null,
        {
          StaticMemberAccessOps: [
            [
              'expression',
              'memberName'
            ],
            {
              MemberAccessOp: null,
              ProtoMemberAccessOp: null,
              SoakedMemberAccessOp: null,
              SoakedProtoMemberAccessOp: null
            }
          ],
          DynamicMemberAccessOps: [
            [
              'expression',
              'indexingExpr'
            ],
            {
              DynamicMemberAccessOp: null,
              DynamicProtoMemberAccessOp: null,
              SoakedDynamicMemberAccessOp: null,
              SoakedDynamicProtoMemberAccessOp: null
            }
          ]
        }
      ],
      ChainedComparisonOp: [['expression']],
      FunctionApplications: [
        [
          'function',
          'arguments'
        ],
        {
          FunctionApplication: null,
          SoakedFunctionApplication: null
        }
      ],
      Super: [['arguments']],
      Program: [['body']],
      Block: [['statements']],
      Conditional: [[
          'condition',
          'consequent',
          'alternate'
        ]],
      ForIn: [[
          'valAssignee',
          'keyAssignee',
          'target',
          'step',
          'filter',
          'body'
        ]],
      ForOf: [[
          'isOwn',
          'keyAssignee',
          'valAssignee',
          'target',
          'filter',
          'body'
        ]],
      Switch: [[
          'expression',
          'cases',
          'alternate'
        ]],
      SwitchCase: [[
          'conditions',
          'consequent'
        ]],
      Try: [[
          'body',
          'catchAssignee',
          'catchBody',
          'finallyBody'
        ]],
      While: [[
          'condition',
          'body'
        ]],
      ArrayInitialiser: [['members']],
      ObjectInitialiser: [['members']],
      ObjectInitialiserMember: [[
          'key',
          'expression'
        ]],
      Class: [[
          'nameAssignee',
          'parent',
          'ctor',
          'body',
          'boundMembers'
        ]],
      Constructor: [['expression']],
      Functions: [
        [
          'parameters',
          'body'
        ],
        {
          Function: null,
          BoundFunction: null
        }
      ],
      DefaultParam: [[
          'param',
          'default'
        ]],
      Identifiers: [
        ['data'],
        {
          Identifier: null,
          GenSym: null
        }
      ],
      Null: null,
      Primitives: [
        ['data'],
        {
          Bool: null,
          JavaScript: null,
          Numbers: [
            null,
            {
              Int: null,
              Float: null
            }
          ],
          String: null
        }
      ],
      RegExps: [
        null,
        {
          RegExp: [[
              'data',
              'flags'
            ]],
          HeregExp: [[
              'expression',
              'flags'
            ]]
        }
      ],
      This: null,
      Undefined: null,
      Slice: [[
          'expression',
          'isInclusive',
          'left',
          'right'
        ]],
      Rest: [['expression']],
      Spread: [['expression']]
    }
  ]
});
cache$1 = exports;
Nodes = cache$1.Nodes;
Primitives = cache$1.Primitives;
CompoundAssignOp = cache$1.CompoundAssignOp;
StaticMemberAccessOps = cache$1.StaticMemberAccessOps;
Range = cache$1.Range;
ArrayInitialiser = cache$1.ArrayInitialiser;
ObjectInitialiser = cache$1.ObjectInitialiser;
NegatedConditional = cache$1.NegatedConditional;
Conditional = cache$1.Conditional;
Identifier = cache$1.Identifier;
ForOf = cache$1.ForOf;
Functions = cache$1.Functions;
While = cache$1.While;
Class = cache$1.Class;
Block = cache$1.Block;
NewOp = cache$1.NewOp;
Bool = cache$1.Bool;
FunctionApplications = cache$1.FunctionApplications;
RegExps = cache$1.RegExps;
RegExp = cache$1.RegExp;
HeregExp = cache$1.HeregExp;
Super = cache$1.Super;
Slice = cache$1.Slice;
Switch = cache$1.Switch;
Identifiers = cache$1.Identifiers;
SwitchCase = cache$1.SwitchCase;
GenSym = cache$1.GenSym;
Nodes.fromBasicObject = function (obj) {
  return exports[obj.type].fromBasicObject(obj);
};
Nodes.prototype.listMembers = [];
Nodes.prototype.toBasicObject = function () {
  var child, obj, p;
  obj = { type: this.className };
  if (null != this.line)
    obj.line = this.line;
  if (null != this.column)
    obj.column = this.column;
  if (null != this.raw) {
    obj.raw = this.raw;
    if (null != this.offset)
      obj.range = [
        this.offset,
        this.offset + this.raw.length
      ];
  }
  for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
    child = this.childNodes[i$];
    if (in$(child, this.listMembers)) {
      obj[child] = function (accum$) {
        for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
          p = this[child][i$1];
          accum$.push(p.toBasicObject());
        }
        return accum$;
      }.call(this, []);
    } else {
      obj[child] = null != this[child] ? this[child].toBasicObject() : void 0;
    }
  }
  return obj;
};
Nodes.prototype.fold = function (memo, fn) {
  var child, p;
  for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
    child = this.childNodes[i$];
    if (in$(child, this.listMembers)) {
      memo = function (accum$) {
        for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
          p = this[child][i$1];
          accum$.push(p.fold(memo, fn));
        }
        return accum$;
      }.call(this, []);
    } else {
      memo = this[child].fold(memo, fn);
    }
  }
  return fn(memo, this);
};
Nodes.prototype.clone = function () {
  var ctor, k, n, v;
  ctor = function () {
  };
  ctor.prototype = this.constructor.prototype;
  n = new ctor;
  for (k in this) {
    if (!isOwn$(this, k))
      continue;
    v = this[k];
    n[k] = v;
  }
  return n;
};
Nodes.prototype['instanceof'] = function () {
  var ctor, ctors, superclasses;
  ctors = arguments.length > 0 ? [].slice.call(arguments, 0) : [];
  superclasses = map(this.constructor.superclasses, function (c) {
    return c.prototype.className;
  });
  for (var i$ = 0, length$ = ctors.length; i$ < length$; ++i$) {
    ctor = ctors[i$];
    if (!in$(ctor.prototype.className, [this.className].concat([].slice.call(superclasses))))
      continue;
    return true;
  }
  return false;
};
Nodes.prototype.r = function (param$) {
  this.raw = param$;
  return this;
};
Nodes.prototype.p = function (param$, param$1, param$2) {
  this.line = param$;
  this.column = param$1;
  this.offset = param$2;
  return this;
};
Nodes.prototype.generated = false;
Nodes.prototype.g = function () {
  this.generated = true;
  return this;
};
handlePrimitives = function (ctor) {
  var primitives;
  primitives = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
  ctor.prototype.childNodes = difference(ctor.prototype.childNodes, primitives);
  return ctor.prototype.toBasicObject = function () {
    var obj, primitive;
    obj = Nodes.prototype.toBasicObject.call(this);
    for (var i$ = 0, length$ = primitives.length; i$ < length$; ++i$) {
      primitive = primitives[i$];
      obj[primitive] = this[primitive];
    }
    return obj;
  };
};
handlePrimitives(Class, 'boundMembers');
handlePrimitives(CompoundAssignOp, 'op');
handlePrimitives(ForOf, 'isOwn');
handlePrimitives(HeregExp, 'flags');
handlePrimitives(Identifiers, 'data');
handlePrimitives(Primitives, 'data');
handlePrimitives(Range, 'isInclusive');
handlePrimitives(RegExp, 'data', 'flags');
handlePrimitives(Slice, 'isInclusive');
handlePrimitives(StaticMemberAccessOps, 'memberName');
handleLists = function (ctor) {
  var listProps;
  listProps = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
  return ctor.prototype.listMembers = listProps;
};
handleLists(ArrayInitialiser, 'members');
handleLists(Block, 'statements');
handleLists(Functions, 'parameters');
handleLists(FunctionApplications, 'arguments');
handleLists(NewOp, 'arguments');
handleLists(ObjectInitialiser, 'members');
handleLists(Super, 'arguments');
handleLists(Switch, 'cases');
handleLists(SwitchCase, 'conditions');
Block.wrap = function (s) {
  return new Block(null != s ? [s] : []).r(s.raw).p(s.line, s.column);
};
Class.prototype.initialise = function () {
  if (null != this.boundMembers)
    this.boundMembers;
  else
    this.boundMembers = [];
  this.name = new GenSym('class');
  if (null != this.nameAssignee)
    return this.name = function () {
      switch (false) {
      case !this.nameAssignee['instanceof'](Identifier):
        return new Identifier(this.nameAssignee.data);
      case !this.nameAssignee['instanceof'](StaticMemberAccessOps):
        return new Identifier(this.nameAssignee.memberName);
      default:
        return this.name;
      }
    }.call(this);
};
Class.prototype.childNodes.push('name');
ObjectInitialiser.prototype.keys = function () {
  return map(this.members, function (m) {
    return m.key;
  });
};
ObjectInitialiser.prototype.vals = function () {
  return map(this.members, function (m) {
    return m.expression;
  });
};
RegExps.prototype.initialise = function (_, flags) {
  var flag;
  this.flags = {};
  for (var cache$2 = [
        'g',
        'i',
        'm',
        'y'
      ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
    flag = cache$2[i$];
    this.flags[flag] = in$(flag, flags);
  }
};
exports.NegatedConditional = function (super$) {
  extends$(NegatedConditional, super$);
  function NegatedConditional() {
    Conditional.apply(this, arguments);
  }
  return NegatedConditional;
}(Conditional);
exports.NegatedWhile = function (super$1) {
  extends$(NegatedWhile, super$1);
  function NegatedWhile() {
    While.apply(this, arguments);
  }
  return NegatedWhile;
}(While);
exports.Loop = function (super$2) {
  extends$(Loop, super$2);
  function Loop(body) {
    While.call(this, new Bool(true).g(), body);
  }
  return Loop;
}(While);
function isOwn$(o, p) {
  return {}.hasOwnProperty.call(o, p);
}
function extends$(child, parent) {
  for (var key in parent)
    if (isOwn$(parent, key))
      child[key] = parent[key];
  function ctor() {
    this.constructor = child;
  }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

},{"./functional-helpers":2}],7:[function(require,module,exports){
(function (global){
// Generated by CoffeeScript 2.0.0-beta9-dev
var all, any, beingDeclared, cache$, cache$1, concat, concatMap, CS, declarationsFor, defaultRules, difference, envEnrichments, exports, foldl, foldl1, isFalsey, isTruthy, makeDispatcher, mayHaveSideEffects, union, usedAsExpression;
cache$ = require('./functional-helpers');
all = cache$.all;
any = cache$.any;
concat = cache$.concat;
concatMap = cache$.concatMap;
difference = cache$.difference;
foldl = cache$.foldl;
foldl1 = cache$.foldl1;
union = cache$.union;
cache$1 = require('./helpers');
beingDeclared = cache$1.beingDeclared;
declarationsFor = cache$1.declarationsFor;
usedAsExpression = cache$1.usedAsExpression;
envEnrichments = cache$1.envEnrichments;
CS = require('./nodes');
exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
makeDispatcher = function (defaultValue, handlers, defaultHandler) {
  var cache$2, ctor, ctors, handler, handlers_, size$;
  if (null == defaultHandler)
    defaultHandler = function () {
    };
  handlers_ = {};
  for (var i$ = 0, length$ = handlers.length; i$ < length$; ++i$) {
    {
      cache$2 = handlers[i$];
      size$ = cache$2.length;
      ctors = size$ > 1 ? [].slice.call(cache$2, 0, size$ - 1) : [];
      handler = cache$2[size$ - 1];
    }
    for (var i$1 = 0, length$1 = ctors.length; i$1 < length$1; ++i$1) {
      ctor = ctors[i$1];
      handlers_[ctor.prototype.className] = handler;
    }
  }
  return function (node) {
    var args;
    args = arguments.length > 1 ? [].slice.call(arguments, 1) : [];
    if (!(null != node))
      return defaultValue;
    handler = Object.prototype.hasOwnProperty.call(handlers_, node.className) ? handlers_[node.className] : defaultHandler;
    return handler.apply(node, args);
  };
};
isTruthy = makeDispatcher(false, [
  [
    CS.ArrayInitialiser,
    CS.Class,
    CS.DeleteOp,
    CS.ForIn,
    CS.ForOf,
    CS.Function,
    CS.BoundFunction,
    CS.HeregExp,
    CS.ObjectInitialiser,
    CS.Range,
    CS.RegExp,
    CS.Slice,
    CS.TypeofOp,
    CS.While,
    function () {
      return true;
    }
  ],
  [
    CS.AssignOp,
    function () {
      return isTruthy(this.expression);
    }
  ],
  [
    CS.Block,
    function () {
      if (this.statements.length === 0) {
        return false;
      } else {
        return isTruthy(this.statements[this.statements.length - 1]);
      }
    }
  ],
  [
    CS.Bool,
    CS.Float,
    CS.Int,
    CS.String,
    function () {
      return !!this.data;
    }
  ],
  [
    CS.Conditional,
    function () {
      return isTruthy(this.condition) && isTruthy(this.consequent) || isFalsey(this.condition) && isTruthy(this.alternate);
    }
  ],
  [
    CS.LogicalAndOp,
    function () {
      return isTruthy(this.left) && isTruthy(this.right);
    }
  ],
  [
    CS.LogicalNotOp,
    function () {
      return isFalsey(this.expression);
    }
  ],
  [
    CS.LogicalOrOp,
    function () {
      return isTruthy(this.left) || isTruthy(this.right);
    }
  ],
  [
    CS.Program,
    function () {
      return isTruthy(this.body);
    }
  ],
  [
    CS.SeqOp,
    function () {
      return isTruthy(this.right);
    }
  ],
  [
    CS.Switch,
    function () {
      return all(this.cases, isTruthy) && (null != this.alternate ? isTruthy(this.alternate) : true);
    }
  ],
  [
    CS.SwitchCase,
    function () {
      return isTruthy(this.consequent);
    }
  ],
  [
    CS.UnaryExistsOp,
    function () {
      return isTruthy(this.expression) || this.expression['instanceof'](CS.Int, CS.Float, CS.String, CS.UnaryPlusOp, CS.UnaryNegateOp, CS.LogicalNotOp);
    }
  ]
], function () {
  return false;
});
isFalsey = makeDispatcher(false, [
  [
    CS.Null,
    CS.Undefined,
    function () {
      return true;
    }
  ],
  [
    CS.AssignOp,
    function () {
      return isFalsey(this.expression);
    }
  ],
  [
    CS.Block,
    function () {
      if (this.statements.length === 0) {
        return true;
      } else {
        return isFalsey(this.statements[this.statements.length - 1]);
      }
    }
  ],
  [
    CS.Bool,
    CS.Float,
    CS.Int,
    CS.String,
    function () {
      return !this.data;
    }
  ],
  [
    CS.Conditional,
    function () {
      return isTruthy(this.condition) && isFalsey(this.consequent) || isFalsey(this.condition) && isFalsey(this.alternate);
    }
  ],
  [
    CS.LogicalAndOp,
    function () {
      return isFalsey(this.left) || isFalsey(this.right);
    }
  ],
  [
    CS.LogicalNotOp,
    function () {
      return isTruthy(this.expression);
    }
  ],
  [
    CS.LogicalOrOp,
    function () {
      return isFalsey(this.left) && isFalsey(this.right);
    }
  ],
  [
    CS.Program,
    function () {
      return isFalsey(this.body);
    }
  ],
  [
    CS.SeqOp,
    function () {
      return isFalsey(this.right);
    }
  ],
  [
    CS.Switch,
    function () {
      return all(this.cases, isFalsey) && (null != this.alternate ? isFalsey(this.alternate) : true);
    }
  ],
  [
    CS.SwitchCase,
    function () {
      return isFalsey(this.block);
    }
  ],
  [
    CS.UnaryExistsOp,
    function () {
      return this.expression['instanceof'](CS.Null, CS.Undefined);
    }
  ]
], function () {
  return false;
});
mayHaveSideEffects = makeDispatcher(false, [
  [
    CS.Function,
    CS.BoundFunction,
    CS.Null,
    CS.RegExp,
    CS.This,
    CS.Undefined,
    function () {
      return false;
    }
  ],
  [
    CS.Break,
    CS.Continue,
    CS.Debugger,
    CS.DeleteOp,
    CS.NewOp,
    CS.Return,
    CS.Super,
    CS.PreDecrementOp,
    CS.PreIncrementOp,
    CS.PostDecrementOp,
    CS.PostIncrementOp,
    CS.ClassProtoAssignOp,
    CS.Constructor,
    CS.Throw,
    CS.JavaScript,
    CS.ExtendsOp,
    function () {
      return true;
    }
  ],
  [
    CS.Class,
    function (inScope) {
      return mayHaveSideEffects(this.parent, inScope) || null != this.nameAssignee && (this.name || beingDeclared(this.nameAssignee).length > 0);
    }
  ],
  [
    CS.Conditional,
    function (inScope) {
      return mayHaveSideEffects(this.condition, inScope) || !isFalsey(this.condition) && mayHaveSideEffects(this.consequent, inScope) || !isTruthy(this.condition) && mayHaveSideEffects(this.alternate, inScope);
    }
  ],
  [
    CS.DoOp,
    function (inScope) {
      var args, newScope, p;
      if (!this.expression['instanceof'](CS.Functions))
        return true;
      newScope = difference(inScope, concatMap(this.expression.parameters, beingDeclared));
      args = function (accum$) {
        for (var i$ = 0, length$ = this.expression.parameters.length; i$ < length$; ++i$) {
          p = this.expression.parameters[i$];
          accum$.push(p['instanceof'](CS.AssignOp) ? p.expression : p);
        }
        return accum$;
      }.call(this, []);
      if (any(args, function (a) {
          return mayHaveSideEffects(a, newScope);
        }))
        return true;
      return mayHaveSideEffects(this.expression.body, newScope);
    }
  ],
  [
    CS.ExistsOp,
    function (inScope) {
      if (mayHaveSideEffects(this.left, inScope))
        return true;
      if (this.left['instanceof'](CS.Undefined, CS.Null))
        return false;
      return mayHaveSideEffects(this.right, inScope);
    }
  ],
  [
    CS.FunctionApplication,
    CS.SoakedFunctionApplication,
    function (inScope) {
      var newScope;
      if (!this['function']['instanceof'](CS.Function, CS.BoundFunction))
        return true;
      newScope = difference(inScope, concatMap(this['function'].parameters, beingDeclared));
      if (any(this['arguments'], function (a) {
          return mayHaveSideEffects(a, newScope);
        }))
        return true;
      return mayHaveSideEffects(this['function'].body, newScope);
    }
  ],
  [
    CS.LogicalAndOp,
    function (inScope) {
      if (mayHaveSideEffects(this.left, inScope))
        return true;
      if (isFalsey(this.left))
        return false;
      return mayHaveSideEffects(this.right, inScope);
    }
  ],
  [
    CS.LogicalOrOp,
    function (inScope) {
      if (mayHaveSideEffects(this.left, inScope))
        return true;
      if (isTruthy(this.left))
        return false;
      return mayHaveSideEffects(this.right, inScope);
    }
  ],
  [
    CS.While,
    function (inScope) {
      return mayHaveSideEffects(this.condition, inScope) || !isFalsey(this.condition) && mayHaveSideEffects(this.body, inScope);
    }
  ],
  [
    CS.AssignOp,
    CS.ClassProtoAssignOp,
    CS.CompoundAssignOp,
    function (inScope) {
      return true;
    }
  ],
  [
    CS.Bool,
    CS.Float,
    CS.Identifier,
    CS.Int,
    CS.String,
    function () {
      return false;
    }
  ]
], function (inScope) {
  return any(this.childNodes, function (this$) {
    return function (child) {
      if (in$(child, this$.listMembers)) {
        return any(this$[child], function (m) {
          return mayHaveSideEffects(m, inScope);
        });
      } else {
        return mayHaveSideEffects(this$[child], inScope);
      }
    };
  }(this));
});
exports.Optimiser = function () {
  Optimiser.optimise = function (this$) {
    return function () {
      var cache$2;
      return (cache$2 = new this$()).optimise.apply(cache$2, [].slice.call(arguments));
    };
  }(Optimiser);
  Optimiser.isTruthy = isTruthy;
  Optimiser.isFalsey = isFalsey;
  Optimiser.mayHaveSideEffects = mayHaveSideEffects;
  defaultRules = [
    [
      CS.Program,
      function () {
        if (!(null != this.body) || mayHaveSideEffects(this.body, [])) {
          return this;
        } else {
          return new CS.Program(null);
        }
      }
    ],
    [
      CS.Block,
      function (param$) {
        var inScope;
        inScope = param$.inScope;
        switch (this.statements.length) {
        case 0:
          return new CS.Undefined().g();
        case 1:
          return this.statements[0];
        default:
          return foldl(this.statements[0], this.statements.slice(1), function (expr, s) {
            return new CS.SeqOp(expr, s);
          });
        }
      }
    ],
    [
      CS.SeqOp,
      function (param$) {
        var ancestry, cache$2, canDropLast, inScope;
        {
          cache$2 = param$;
          inScope = cache$2.inScope;
          ancestry = cache$2.ancestry;
        }
        canDropLast = !usedAsExpression(this, ancestry);
        if (this.left['instanceof'](CS.Undefined)) {
          return this.right;
        } else if (this.left['instanceof'](CS.Return, CS.Throw)) {
          return this.left;
        } else if (mayHaveSideEffects(this.left, inScope)) {
          if (mayHaveSideEffects(this.right, inScope)) {
            return this;
          } else if (!canDropLast) {
            return this;
          } else if (this.right['instanceof'](CS.Undefined)) {
            return this.left;
          } else {
            return new CS.SeqOp(this.left, declarationsFor(this.right, union(inScope, envEnrichments(this.left, inScope))));
          }
        } else if (this.right['instanceof'](CS.Identifier) && this.right.data === 'eval' && ((null != ancestry[0] ? ancestry[0]['instanceof'](CS.FunctionApplication) : void 0) && ancestry[0]['function'] === this || (null != ancestry[0] ? ancestry[0]['instanceof'](CS.DoOp) : void 0) && ancestry[0].expression === this)) {
          if (this.left['instanceof'](CS.Int) && (0 <= this.left.data && this.left.data <= 9)) {
            return this;
          } else if (mayHaveSideEffects(this.left, inScope)) {
            return this;
          } else {
            return new CS.SeqOp(new CS.Int(0).g(), this.right);
          }
        } else if (mayHaveSideEffects(this.right, inScope)) {
          return new CS.SeqOp(declarationsFor(this.left, inScope), this.right);
        } else if (canDropLast) {
          return declarationsFor(this, inScope);
        } else {
          return this.right;
        }
      }
    ],
    [
      CS.AssignOp,
      function () {
        if (!this.expression['instanceof'](CS.SeqOp))
          return this;
        return new CS.SeqOp(this.expression.left, new CS.AssignOp(this.assignee, this.expression.right));
      }
    ],
    [
      CS.While,
      function (param$) {
        var inScope;
        inScope = param$.inScope;
        if (isFalsey(this.condition)) {
          return new CS.Block([
            mayHaveSideEffects(this.condition, inScope) ? new CS.SeqOp(this.condition, declarationsFor(this.body)) : null != this.body ? declarationsFor(this.body, inScope) : new CS.Undefined,
            new CS.ArrayInitialiser([])
          ]);
        } else if (isTruthy(this.condition)) {
          if (mayHaveSideEffects(this.condition, inScope)) {
            return this;
          } else if (null != this.body) {
            if (this instanceof CS.Loop) {
              return this;
            } else {
              return new CS.Loop(this.body).g();
            }
          } else {
            return new CS.ArrayInitialiser([]);
          }
        } else {
          return this;
        }
      }
    ],
    [
      CS.Conditional,
      function (param$) {
        var block, cache$2, cache$3, decls, inScope, removedBlock;
        inScope = param$.inScope;
        if (isFalsey(this.condition)) {
          cache$2 = [
            this.consequent,
            this.alternate
          ];
          removedBlock = cache$2[0];
          block = cache$2[1];
          cache$2;
        } else if (isTruthy(this.condition)) {
          cache$3 = [
            this.consequent,
            this.alternate
          ];
          block = cache$3[0];
          removedBlock = cache$3[1];
          cache$3;
        } else {
          return this;
        }
        decls = declarationsFor(removedBlock, inScope);
        block = null != block ? new CS.SeqOp(decls, block) : decls;
        if (mayHaveSideEffects(this.condition, inScope))
          block = new CS.SeqOp(this.condition, block);
        return block;
      }
    ],
    [
      CS.ForIn,
      function (param$) {
        var inScope;
        inScope = param$.inScope;
        if (!(this.target['instanceof'](CS.ArrayInitialiser) && this.target.members.length === 0))
          return this;
        return new CS.SeqOp(declarationsFor(this, inScope), new CS.ArrayInitialiser([]).g());
      }
    ],
    [
      CS.ForOf,
      function (param$) {
        var inScope;
        inScope = param$.inScope;
        if (!(this.isOwn && this.target['instanceof'](CS.ObjectInitialiser) && this.target.members.length === 0))
          return this;
        return new CS.SeqOp(declarationsFor(this, inScope), new CS.ArrayInitialiser([]).g());
      }
    ],
    [
      CS.ForIn,
      CS.ForOf,
      function (param$) {
        var inScope;
        inScope = param$.inScope;
        if (!isFalsey(this.filter))
          return this;
        return new CS.SeqOp(declarationsFor(this, inScope), new CS.ArrayInitialiser([]).g());
      }
    ],
    [
      CS.ForIn,
      function () {
        if (!isTruthy(this.filter))
          return this;
        return new CS.ForIn(this.valAssignee, this.keyAssignee, this.target, this.step, null, this.body);
      }
    ],
    [
      CS.ForOf,
      function () {
        if (!isTruthy(this.filter))
          return this;
        return new CS.ForOf(this.isOwn, this.keyAssignee, this.valAssignee, this.target, null, this.body);
      }
    ],
    [
      CS.ArrayInitialiser,
      function (param$) {
        var ancestry, cache$2, inScope;
        {
          cache$2 = param$;
          inScope = cache$2.inScope;
          ancestry = cache$2.ancestry;
        }
        if (usedAsExpression(this, ancestry)) {
          return this;
        } else {
          return foldl(new CS.Undefined().g(), this.members, function (expr, m) {
            return new CS.SeqOp(expr, m);
          });
        }
      }
    ],
    [
      CS.ExistsOp,
      function () {
        if (this.left['instanceof'](CS.Null, CS.Undefined)) {
          return this.right;
        } else {
          return this;
        }
      }
    ],
    [
      CS.UnaryExistsOp,
      function () {
        if (this.expression['instanceof'](CS.Null, CS.Undefined)) {
          return new CS.Bool(false).g();
        } else {
          return this;
        }
      }
    ],
    [
      CS.LogicalNotOp,
      function (param$) {
        var inScope;
        inScope = param$.inScope;
        switch (false) {
        case !this.expression['instanceof'](CS.Int, CS.Float, CS.String, CS.Bool):
          return new CS.Bool(!this.expression.data).g();
        case !this.expression['instanceof'](CS.Functions):
          return new CS.Bool(false).g();
        case !this.expression['instanceof'](CS.Null, CS.Undefined):
          return new CS.Bool(true).g();
        case !this.expression['instanceof'](CS.ArrayInitialiser, CS.ObjectInitialiser):
          if (mayHaveSideEffects(this.expression, inScope)) {
            return this;
          } else {
            return new CS.SeqOp(declarationsFor(this.expression, inScope), new CS.Bool(false).g());
          }
        case !this.expression['instanceof'](CS.LogicalNotOp):
          if (this.expression.expression['instanceof'](CS.LogicalNotOp)) {
            return this.expression.expression;
          } else {
            return this;
          }
        default:
          return this;
        }
      }
    ],
    [
      CS.TypeofOp,
      function () {
        switch (false) {
        case !this.expression['instanceof'](CS.Int, CS.Float, CS.UnaryNegateOp, CS.UnaryPlusOp):
          return new CS.String('number').g();
        case !this.expression['instanceof'](CS.String):
          return new CS.String('string').g();
        case !this.expression['instanceof'](CS.Functions):
          return new CS.String('function').g();
        case !this.expression['instanceof'](CS.Undefined):
          return new CS.String('undefined').g();
        default:
          return this;
        }
      }
    ],
    [
      CS.SeqOp,
      function (param$) {
        var ancestry;
        ancestry = param$.ancestry;
        if (!((null != ancestry[0] ? ancestry[0]['instanceof'](CS.Functions) : void 0) && ancestry[0].body === this))
          return this;
        if (this.right['instanceof'](CS.Return) && null != this.right.expression) {
          return new CS.SeqOp(this.left, this.right.expression);
        } else if (this.right['instanceof'](CS.Undefined)) {
          return new CS.SeqOp(this.left, new CS.Return);
        } else {
          return this;
        }
      }
    ],
    [
      CS.Function,
      CS.BoundFunction,
      function () {
        if (!(null != this.block && (this.block['instanceof'](CS.Undefined) || this.block['instanceof'](CS.Return) && !(null != this.block.expression))))
          return this;
        return new this.constructor(this.parameters, null);
      }
    ],
    [
      CS.Return,
      function () {
        if (null != this.expression ? this.expression['instanceof'](CS.Undefined) : void 0) {
          return new CS.Return;
        } else {
          return this;
        }
      }
    ],
    [
      CS.Slice,
      function () {
        if ((null != this.left ? this.left['instanceof'](CS.Int, CS.String) : void 0) && +this.left.data === 0) {
          return new CS.Slice(this.expression, this.isInclusive, null, this.right);
        } else if (this.isInclusive && (null != this.right ? this.right['instanceof'](CS.UnaryNegateOp) : void 0) && this.right.expression['instanceof'](CS.Int) && this.right.expression.data === 1) {
          return new CS.Slice(this.expression, true, this.left, null);
        } else {
          return this;
        }
      }
    ]
  ];
  function Optimiser() {
    var cache$2, ctor, ctors, handler, size$;
    this.rules = {};
    for (var i$ = 0, length$ = defaultRules.length; i$ < length$; ++i$) {
      {
        cache$2 = defaultRules[i$];
        size$ = cache$2.length;
        ctors = size$ > 1 ? [].slice.call(cache$2, 0, size$ - 1) : [];
        handler = cache$2[size$ - 1];
      }
      for (var i$1 = 0, length$1 = ctors.length; i$1 < length$1; ++i$1) {
        ctor = ctors[i$1];
        this.addRule(ctor.prototype.className, handler);
      }
    }
  }
  Optimiser.prototype.addRule = function (ctor, handler) {
    (null != this.rules[ctor] ? this.rules[ctor] : this.rules[ctor] = []).push(handler);
    return this;
  };
  Optimiser.prototype.optimise = function () {
    var walk;
    walk = function (fn, inScope, ancestry) {
      var childName, member, n, p, replacementNode;
      if (null == inScope)
        inScope = [];
      if (null == ancestry)
        ancestry = [];
      ancestry.unshift(this);
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        childName = this.childNodes[i$];
        if (!(null != this[childName]))
          continue;
        if (in$(childName, this.listMembers)) {
          for (var i$1 = 0, length$1 = this[childName].length; i$1 < length$1; ++i$1) {
            member = this[childName][i$1];
            n = i$1;
            while (this[childName][n] !== walk.call(this[childName][n] = fn.call(this[childName][n], {
                inScope: inScope,
                ancestry: ancestry
              }), fn, inScope, ancestry)) {
            }
            inScope = union(inScope, envEnrichments(this[childName][n], inScope));
          }
        } else {
          while (this[childName] !== walk.call(this[childName] = fn.call(this[childName], {
              inScope: inScope,
              ancestry: ancestry
            }), fn, inScope, ancestry)) {
          }
          inScope = union(inScope, envEnrichments(this[childName], inScope));
        }
      }
      ancestry.shift();
      replacementNode = fn.call(this, {
        inScope: inScope,
        ancestry: ancestry
      });
      if (this !== replacementNode) {
        while (replacementNode !== walk.call(replacementNode = fn.call(replacementNode, {
            inScope: inScope,
            ancestry: ancestry
          }), fn, inScope, ancestry)) {
        }
        for (var cache$2 = [
              'raw',
              'line',
              'column',
              'offset'
            ], i$2 = 0, length$2 = cache$2.length; i$2 < length$2; ++i$2) {
          p = cache$2[i$2];
          replacementNode[p] = this[p];
        }
      }
      return replacementNode;
    };
    return function (ast) {
      var rules;
      rules = this.rules;
      return walk.call(ast, function (param$) {
        var ancestry, memo, rule;
        ancestry = param$.ancestry;
        if (!(null != this) || this === global)
          throw new Error('Optimiser rules must produce a node. `null` is not a node.');
        if (in$(this, ancestry))
          return this;
        memo = this;
        for (var cache$2 = null != rules[memo.className] ? rules[memo.className] : [], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
          rule = cache$2[i$];
          memo = rule.apply(memo, arguments);
          if (memo !== this)
            break;
        }
        return memo;
      });
    };
  }();
  return Optimiser;
}();
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./functional-helpers":2,"./helpers":3,"./nodes":6}],8:[function(require,module,exports){
module.exports = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { program: peg$parseprogram },
        peg$startRuleFunction  = peg$parseprogram,

        peg$c0 = peg$FAILED,
        peg$c1 = null,
        peg$c2 = function(leader, b) {return rp(new CS.Program(b));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c3 = [],
        peg$c4 = function(s) {return s;
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c5 = function(s, ss) {return rp(new CS.Block([s].concat([].slice.call(ss))));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c6 = void 0,
        peg$c7 = ";",
        peg$c8 = { type: "literal", value: ";", description: "\";\"" },
        peg$c9 = function(e) {return e;
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c10 = function(left, right) {if (!right)
          return left;
        return rp(new CS.SeqOp(left, right));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c11 = function(expr, postfixes) {return foldl(function (expr, postfixContainer) {
          var indicator, postfix;
          postfix = postfixContainer[1];
          indicator = postfix.type;
          switch (indicator) {
          case 'if':
            return rp(new CS.Conditional(postfix.cond, expr, null));
          case 'unless':
            return rp(new CS.NegatedConditional(new CS.LogicalNotOp(postfix.cond).g(), expr, null));
          case 'while':
            return rp(new CS.While(postfix.cond, expr));
          case 'until':
            return rp(new CS.NegatedWhile(new CS.LogicalNotOp(postfix.cond).g(), expr));
          case 'for-in':
            return rp(new CS.ForIn(postfix.val, postfix.key, postfix.list, postfix.step, postfix.filter, expr));
          case 'for-of':
            return rp(new CS.ForOf(postfix.own, postfix.key, postfix.val, postfix.obj, postfix.filter, expr));
          }
        }, expr, postfixes);
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c12 = function(kw, e) {return {
          type: kw,
          cond: e
        };
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c13 = ",",
        peg$c14 = { type: "literal", value: ",", description: "\",\"" },
        peg$c15 = function(a) {return a;
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c16 = function(val, key) {return [
          val,
          key
        ];
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c17 = function(valKey, list, step, filter) {var cache$, key, val;
        cache$ = null != valKey ? valKey : [
          null,
          null
        ];
        val = cache$[0];
        key = cache$[1];
        if (null != step)
          step;
        else
          step = new CS.Int(1).r('1').g();
        return {
          type: 'for-in',
          val: val,
          key: key,
          list: list,
          step: step,
          filter: filter
        };
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c18 = function(own, key, val, obj, filter) {return {
          type: 'for-of',
          own: Boolean(own),
          key: key,
          val: val,
          obj: obj,
          filter: filter
        };
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c19 = "=",
        peg$c20 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c21 = function(left, right) {return rp(new CS.AssignOp(left, right));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c22 = "?",
        peg$c23 = { type: "literal", value: "?", description: "\"?\"" },
        peg$c24 = function(left, op, right) {return rp(new CS.CompoundAssignOp(constructorLookup[op].prototype.className, left, right));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c25 = "&&",
        peg$c26 = { type: "literal", value: "&&", description: "\"&&\"" },
        peg$c27 = "||",
        peg$c28 = { type: "literal", value: "||", description: "\"||\"" },
        peg$c29 = "**",
        peg$c30 = { type: "literal", value: "**", description: "\"**\"" },
        peg$c31 = /^[?&\^|*\/%]/,
        peg$c32 = { type: "class", value: "[?&\\^|*\\/%]", description: "[?&\\^|*\\/%]" },
        peg$c33 = "+",
        peg$c34 = { type: "literal", value: "+", description: "\"+\"" },
        peg$c35 = "-",
        peg$c36 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c37 = "<<",
        peg$c38 = { type: "literal", value: "<<", description: "\"<<\"" },
        peg$c39 = ">>>",
        peg$c40 = { type: "literal", value: ">>>", description: "\">>>\"" },
        peg$c41 = ">>",
        peg$c42 = { type: "literal", value: ">>", description: "\">>\"" },
        peg$c43 = "?=",
        peg$c44 = { type: "literal", value: "?=", description: "\"?=\"" },
        peg$c45 = function(left, right) {return rp(new CS.CompoundAssignOp(constructorLookup['?'].prototype.className, left, right));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c46 = function(o, e) {return [
          o,
          e
        ];
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c47 = function(left, rights) {var cache$, cache$1, expr, op;
        switch (rights.length) {
        case 0:
          return left;
        case 1:
          cache$ = rights[0];
          op = cache$[0];
          expr = cache$[1];
          return rp(new constructorLookup[op](left, expr));
        default:
          return rp(foldBinaryExpr((cache$1 = [left]).concat.apply(cache$1, [].slice.call(rights))));
        }
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c48 = "<=",
        peg$c49 = { type: "literal", value: "<=", description: "\"<=\"" },
        peg$c50 = ">=",
        peg$c51 = { type: "literal", value: ">=", description: "\">=\"" },
        peg$c52 = "<",
        peg$c53 = { type: "literal", value: "<", description: "\"<\"" },
        peg$c54 = ">",
        peg$c55 = { type: "literal", value: ">", description: "\">\"" },
        peg$c56 = "==",
        peg$c57 = { type: "literal", value: "==", description: "\"==\"" },
        peg$c58 = "!=",
        peg$c59 = { type: "literal", value: "!=", description: "\"!=\"" },
        peg$c60 = function(op) {return 'not ' + op;
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c61 = function(e) {return rp(new CS.DoOp(e));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c62 = function(o) {return o;
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c63 = function(ops, e) {return rp(foldr(function (e, op) {
          return new prefixConstructorLookup[op](e);
        }, e, ops));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c64 = "++",
        peg$c65 = { type: "literal", value: "++", description: "\"++\"" },
        peg$c66 = "--",
        peg$c67 = { type: "literal", value: "--", description: "\"--\"" },
        peg$c68 = "!",
        peg$c69 = { type: "literal", value: "!", description: "\"!\"" },
        peg$c70 = "~",
        peg$c71 = { type: "literal", value: "~", description: "\"~\"" },
        peg$c72 = function(a, f) {return rp(new CS.AssignOp(a, f));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c73 = function(e, ops) {return rp(foldl(function (e, op) {
          return new postfixConstructorLookup[op](e);
        }, e, ops));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c74 = "[..]",
        peg$c75 = { type: "literal", value: "[..]", description: "\"[..]\"" },
        peg$c76 = "(",
        peg$c77 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c78 = ")",
        peg$c79 = { type: "literal", value: ")", description: "\")\"" },
        peg$c80 = function(soaked, a) {return rp({
          op: soaked ? CS.SoakedFunctionApplication : CS.FunctionApplication,
          operands: [null != a ? a : []]
        });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c81 = function(e, es) {return [e].concat([].slice.call(es));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c82 = /^[+-\/]/,
        peg$c83 = { type: "class", value: "[+-\\/]", description: "[+-\\/]" },
        peg$c84 = function(e, es, obj) {es.unshift(e);
        if (null != obj)
          es.push(obj);
        return es;
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c85 = function(o) {return [o];
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c86 = function(fn, accesses, secondaryArgs) {var cache$, list, secondaryCtor, soaked;
        if (null != accesses)
          fn = createMemberExpression(fn, accesses);
        if (null != secondaryArgs) {
          cache$ = secondaryArgs;
          soaked = cache$[0];
          list = cache$[1];
          secondaryCtor = soaked ? CS.SoakedFunctionApplication : CS.FunctionApplication;
          fn = rp(new secondaryCtor(fn, list));
        }
        return fn;
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c87 = function(as) {return as;
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c88 = function(as, bs) {return [].slice.call(as).concat([].slice.call(null != bs ? bs : []));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c89 = function(e) {return rp(new CS.NewOp(e, []));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c90 = function(e, args) {return rp(new CS.NewOp(e, args.operands[0]));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c91 = function(e, accesses) {return createMemberExpression(e, accesses);
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c92 = function(e, args) {return rp(new CS.NewOp(e, args));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c93 = function(e, accesses) {var acc;
        acc = foldl(function (memo, a) {
          return memo.concat(a);
        }, [], accesses);
        return createMemberExpression(e, acc);
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c94 = ".",
        peg$c95 = { type: "literal", value: ".", description: "\".\"" },
        peg$c96 = function(e) {return rp({
          op: CS.MemberAccessOp,
          operands: [e]
        });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c97 = "?.",
        peg$c98 = { type: "literal", value: "?.", description: "\"?.\"" },
        peg$c99 = function(e) {return rp({
          op: CS.SoakedMemberAccessOp,
          operands: [e]
        });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c100 = "[",
        peg$c101 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c102 = "]",
        peg$c103 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c104 = function(e) {return rp({
          op: CS.DynamicMemberAccessOp,
          operands: [e]
        });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c105 = "?[",
        peg$c106 = { type: "literal", value: "?[", description: "\"?[\"" },
        peg$c107 = function(e) {return rp({
          op: CS.SoakedDynamicMemberAccessOp,
          operands: [e]
        });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c108 = "::",
        peg$c109 = { type: "literal", value: "::", description: "\"::\"" },
        peg$c110 = function(e) {return rp({
          op: CS.ProtoMemberAccessOp,
          operands: [e]
        });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c111 = "::[",
        peg$c112 = { type: "literal", value: "::[", description: "\"::[\"" },
        peg$c113 = function(e) {return rp({
          op: CS.DynamicProtoMemberAccessOp,
          operands: [e]
        });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c114 = "?::",
        peg$c115 = { type: "literal", value: "?::", description: "\"?::\"" },
        peg$c116 = function(e) {return rp({
          op: CS.SoakedProtoMemberAccessOp,
          operands: [e]
        });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c117 = "?::[",
        peg$c118 = { type: "literal", value: "?::[", description: "\"?::[\"" },
        peg$c119 = function(e) {return rp({
          op: CS.SoakedDynamicProtoMemberAccessOp,
          operands: [e]
        });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c120 = "..",
        peg$c121 = { type: "literal", value: "..", description: "\"..\"" },
        peg$c122 = function(left, exclusive, right) {return rp({
          op: CS.Slice,
          operands: [
            !exclusive,
            left,
            right
          ]
        });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c123 = "@",
        peg$c124 = { type: "literal", value: "@", description: "\"@\"" },
        peg$c125 = function() {return rp(new CS.This);
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c126 = function(e) {return r(e.clone());
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c127 = function(a, m) {return rp(new CS.MemberAccessOp(a, m));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c128 = "`",
        peg$c129 = { type: "literal", value: "`", description: "\"`\"" },
        peg$c130 = /^[^`]/,
        peg$c131 = { type: "class", value: "[^`]", description: "[^`]" },
        peg$c132 = function(d) {return rp(new CS.JavaScript(d));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c133 = "...",
        peg$c134 = { type: "literal", value: "...", description: "\"...\"" },
        peg$c135 = function(e) {return rp(new CS.Spread(e));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c136 = function(kw, cond, body, elseClause) {switch (kw) {
        case 'if':
          return rp(new CS.Conditional(cond, body.block, elseClause));
        case 'unless':
          return rp(new CS.NegatedConditional(new CS.LogicalNotOp(cond).g(), body.block, elseClause));
        }
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c137 = function(b) {return { block: b };
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c138 = function(s) {return { block: s };
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c139 = function() {return { block: null };
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c140 = function(b) {return b;
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c141 = function(kw, cond, body) {switch (kw) {
        case 'while':
          return rp(new CS.While(cond, body.block));
        case 'until':
          return rp(new CS.NegatedWhile(new CS.LogicalNotOp(cond).g(), body.block));
        }
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c142 = function(body) {return rp(new CS.Loop(body.block));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c143 = function(body, c, f) {return rp(new CS.Try(body.block, null != (null != c ? c.assignee : void 0) ? null != c ? c.assignee : void 0 : null, null != (null != c ? c.block : void 0) ? null != c ? c.block : void 0 : null, null != (null != f ? f.block : void 0) ? null != f ? f.block : void 0 : null));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c144 = function(e, body) {return r({
          block: null != body ? body.block : new CS.Block([]),
          assignee: e
        });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c145 = function(body) {return r({ block: null != (null != body ? body.block : void 0) ? null != body ? body.block : void 0 : null });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c146 = function(name, parent, body) {var boundMembers, ctor, m, stmts;
        ctor = null;
        boundMembers = [];
        stmts = null != body ? null != body.statements ? body.statements : [body] : [];
        for (var i$ = 0, length$ = stmts.length; i$ < length$; ++i$) {
          m = stmts[i$];
          if (m['instanceof'](CS.Constructor)) {
            ctor = m;
          } else if (m['instanceof'](CS.ClassProtoAssignOp) && m.expression['instanceof'](CS.BoundFunction)) {
            boundMembers.push(m);
          }
        }
        return rp(new CS.Class(name, parent, ctor, body, boundMembers));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c147 = function(key) {return key['instanceof'](CS.String, CS.Identifier) && key.data === 'constructor';
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c148 = ":",
        peg$c149 = { type: "literal", value: ":", description: "\":\"" },
        peg$c150 = function(key, fn) {if (fn['instanceof'](CS.BoundFunction))
          fn = c(new CS.Function(fn.parameters, fn.body).r(fn.raw), fn);
        return rp(new CS.Constructor(fn));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c151 = function(e) {return r({ expr: e });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c152 = function(key, e) {return rp(new CS.AssignOp(key, e.expr));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c153 = function(key, e) {return rp(new CS.ClassProtoAssignOp(key, e.expr));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c154 = function(own, key, val, obj, filter, body) {return rp(new CS.ForOf(Boolean(own), key, val, obj, filter, body.block));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c155 = function(valKey, list, step, filter, body) {var cache$, key, val;
        cache$ = null != valKey ? valKey : [
          null,
          null
        ];
        val = cache$[0];
        key = cache$[1];
        if (null != step)
          step;
        else
          step = new CS.Int(1).r('1').g();
        return rp(new CS.ForIn(val, key, list, step, filter, body.block));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c156 = function(e, body) {return rp(new CS.Switch(e, body.cases, null != body['else'] ? body['else'] : null));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c157 = function(b) {return r({
          cases: b.cases,
          'else': b['else']
        });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c158 = function(c) {return r({ cases: [c] });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c159 = function() {return r({ cases: [] });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c160 = function(c) {return c;
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c161 = function(c, cs, elseClause) {return r({
          cases: [c].concat([].slice.call(cs)),
          'else': elseClause
        });
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c162 = function(conditions, body) {return rp(new CS.SwitchCase(conditions, body.block));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c163 = function(c, cs) {return [c].concat([].slice.call(cs));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c164 = function(p) {return p;
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c165 = "->",
        peg$c166 = { type: "literal", value: "->", description: "\"->\"" },
        peg$c167 = "=>",
        peg$c168 = { type: "literal", value: "=>", description: "\"=>\"" },
        peg$c169 = function(params, arrow, body) {var constructor;
        constructor = function () {
          switch (arrow) {
          case '->':
            return CS.Function;
          case '=>':
            return CS.BoundFunction;
          }
        }.call(this);
        return rp(new constructor(null != params ? params : [], body));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c170 = function(param, default_) {return rp(new CS.DefaultParam(param, default_));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c171 = function(a, rest) {return rp(null != rest ? new CS.Rest(a) : a);
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c172 = function(left, exclusiveDot, right) {var inclusive;
        inclusive = !exclusiveDot;
        return rp(new CS.Range(inclusive, left, right));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c173 = function(members) {return rp(new CS.ArrayInitialiser(members));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c174 = function(members) {return members;
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c175 = function(members) {return null != members ? members : [];
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c176 = "{",
        peg$c177 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c178 = "}",
        peg$c179 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c180 = function(members) {return rp(new CS.ObjectInitialiser(members));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c181 = function(v) {var key;
        key = p(new CS.String(v.memberName).g());
        return rp(new CS.ObjectInitialiserMember(key, v));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c182 = function(v) {return rp(new CS.ObjectInitialiserMember(v, v));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c183 = function(i) {return rp(new CS.Identifier(i));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c184 = function(key, val) {return rp(new CS.ObjectInitialiserMember(key, val));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c185 = "__LINE__",
        peg$c186 = { type: "literal", value: "__LINE__", description: "\"__LINE__\"" },
        peg$c187 = function() {return rp(new CS.Int(line()));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c188 = "__FILENAME__",
        peg$c189 = { type: "literal", value: "__FILENAME__", description: "\"__FILENAME__\"" },
        peg$c190 = function() {return rp(new CS.String(null != options.inputSource ? options.inputSource : ''));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c191 = "__DATE__",
        peg$c192 = { type: "literal", value: "__DATE__", description: "\"__DATE__\"" },
        peg$c193 = function() {return rp(new CS.String(new Date().toDateString().slice(4)));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c194 = "__TIME__",
        peg$c195 = { type: "literal", value: "__TIME__", description: "\"__TIME__\"" },
        peg$c196 = function() {return rp(new CS.String(new Date().toTimeString().slice(0, 8)));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c197 = "__DATETIMEMS__",
        peg$c198 = { type: "literal", value: "__DATETIMEMS__", description: "\"__DATETIMEMS__\"" },
        peg$c199 = function() {return rp(new CS.Int(+new Date));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c200 = "__COFFEE_VERSION__",
        peg$c201 = { type: "literal", value: "__COFFEE_VERSION__", description: "\"__COFFEE_VERSION__\"" },
        peg$c202 = function() {return rp(new CS.String(require('../package.json').version));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c203 = function() {return rp(new CS.Bool(true));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c204 = function() {return rp(new CS.Bool(false));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c205 = "0b",
        peg$c206 = { type: "literal", value: "0b", description: "\"0b\"" },
        peg$c207 = function(bs) {return rp(new CS.Int(parseInt(bs, 2)));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c208 = "0o",
        peg$c209 = { type: "literal", value: "0o", description: "\"0o\"" },
        peg$c210 = function(os) {return rp(new CS.Int(parseInt(os, 8)));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c211 = "0x",
        peg$c212 = { type: "literal", value: "0x", description: "\"0x\"" },
        peg$c213 = function(hs) {return rp(new CS.Int(parseInt(hs, 16)));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c214 = /^[eE]/,
        peg$c215 = { type: "class", value: "[eE]", description: "[eE]" },
        peg$c216 = /^[+\-]/,
        peg$c217 = { type: "class", value: "[+\\-]", description: "[+\\-]" },
        peg$c218 = function(base, e, sign, exponent) {return rp(new CS.Float(parseFloat('' + base.data + e + (null != sign ? sign : '') + exponent.data)));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c219 = function(integral, fractional) {if (fractional) {
          return rp(new CS.Float(parseFloat(integral + fractional)));
        } else {
          return rp(new CS.Int(+integral));
        }
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c220 = "0",
        peg$c221 = { type: "literal", value: "0", description: "\"0\"" },
        peg$c222 = /^[1-9]/,
        peg$c223 = { type: "class", value: "[1-9]", description: "[1-9]" },
        peg$c224 = /^[0-9]/,
        peg$c225 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c226 = /^[0-9a-fA-F]/,
        peg$c227 = { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
        peg$c228 = /^[0-7]/,
        peg$c229 = { type: "class", value: "[0-7]", description: "[0-7]" },
        peg$c230 = /^[01]/,
        peg$c231 = { type: "class", value: "[01]", description: "[01]" },
        peg$c232 = "\"\"\"",
        peg$c233 = { type: "literal", value: "\"\"\"", description: "\"\\\"\\\"\\\"\"" },
        peg$c234 = "'",
        peg$c235 = { type: "literal", value: "'", description: "\"'\"" },
        peg$c236 = "\"",
        peg$c237 = { type: "literal", value: "\"", description: "\"\\\"\"" },
        peg$c238 = function(d) {return rp(new CS.String(stripLeadingWhitespace(d.join(''))));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c239 = "'''",
        peg$c240 = { type: "literal", value: "'''", description: "\"'''\"" },
        peg$c241 = "#",
        peg$c242 = { type: "literal", value: "#", description: "\"#\"" },
        peg$c243 = function(d) {return rp(new CS.String(d.join('')));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c244 = /^[^"'\\#]/,
        peg$c245 = { type: "class", value: "[^\"'\\\\#]", description: "[^\"'\\\\#]" },
        peg$c246 = "\\x",
        peg$c247 = { type: "literal", value: "\\x", description: "\"\\\\x\"" },
        peg$c248 = function(h) {return String.fromCharCode(parseInt(h, 16));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c249 = "\\0",
        peg$c250 = { type: "literal", value: "\\0", description: "\"\\\\0\"" },
        peg$c251 = function() {return '\0';
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c252 = function() {throw new SyntaxError(['string data'], 'octal escape sequence', offset(), line(), column());
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c253 = "\\b",
        peg$c254 = { type: "literal", value: "\\b", description: "\"\\\\b\"" },
        peg$c255 = function() {return '\b';
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c256 = "\\t",
        peg$c257 = { type: "literal", value: "\\t", description: "\"\\\\t\"" },
        peg$c258 = function() {return '\t';
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c259 = "\\n",
        peg$c260 = { type: "literal", value: "\\n", description: "\"\\\\n\"" },
        peg$c261 = function() {return '\n';
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c262 = "\\v",
        peg$c263 = { type: "literal", value: "\\v", description: "\"\\\\v\"" },
        peg$c264 = function() {return '\x0B';
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c265 = "\\f",
        peg$c266 = { type: "literal", value: "\\f", description: "\"\\\\f\"" },
        peg$c267 = function() {return '\f';
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c268 = "\\r",
        peg$c269 = { type: "literal", value: "\\r", description: "\"\\\\r\"" },
        peg$c270 = function() {return '\r';
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c271 = "\\",
        peg$c272 = { type: "literal", value: "\\", description: "\"\\\\\"" },
        peg$c273 = { type: "any", description: "any character" },
        peg$c274 = "#{",
        peg$c275 = { type: "literal", value: "#{", description: "\"#{\"" },
        peg$c276 = function(es) {return rp(createInterpolation(stripLeadingWhitespaceInterpolation(es)));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c277 = function(es) {return rp(createInterpolation(es));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c278 = "///",
        peg$c279 = { type: "literal", value: "///", description: "\"///\"" },
        peg$c280 = /^[ \r\n]/,
        peg$c281 = { type: "class", value: "[ \\r\\n]", description: "[ \\r\\n]" },
        peg$c282 = function() {return [rp(new CS.String('').g())];
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c283 = /^[^\\\/#[ \r\n]/,
        peg$c284 = { type: "class", value: "[^\\\\\\/#[ \\r\\n]", description: "[^\\\\\\/#[ \\r\\n]" },
        peg$c285 = function(s) {return [rp(new CS.String(s).g())];
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c286 = /^[gimy]/,
        peg$c287 = { type: "class", value: "[gimy]", description: "[gimy]" },
        peg$c288 = function(es, flags) {var interp;
        if (!isValidRegExpFlags(flags))
          throw new SyntaxError(['regular expression flags'], 'regular expression flags', offset(), line(), column());
        interp = createInterpolation(foldl(function (memo, e) {
          return memo.concat(e);
        }, [], es));
        if (interp instanceof CS.String)
          return p(new CS.RegExp(interp.data, flags));
        return rp(new CS.HeregExp(interp, flags));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c289 = "/",
        peg$c290 = { type: "literal", value: "/", description: "\"/\"" },
        peg$c291 = /^[^\/\\[\n]/,
        peg$c292 = { type: "class", value: "[^\\/\\\\[\\n]", description: "[^\\/\\\\[\\n]" },
        peg$c293 = function(d, flags) {if (!isValidRegExpFlags(flags))
          throw new SyntaxError(['regular expression flags'], 'regular expression flags', offset(), line(), column());
        return rp(new CS.RegExp(d, flags));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c294 = /^[^\\\]\n]/,
        peg$c295 = { type: "class", value: "[^\\\\\\]\\n]", description: "[^\\\\\\]\\n]" },
        peg$c296 = function(h) {return h[0];
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c297 = /^[^\\\/\]]/,
        peg$c298 = { type: "class", value: "[^\\\\\\/\\]]", description: "[^\\\\\\/\\]]" },
        peg$c299 = function(s) {return p(new CS.String(s));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c300 = function(d) {return [p(new CS.String('['))].concat([].slice.call(d), [p(new CS.String(']'))]);
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c301 = function(d) {return [rp(new CS.String(d))];
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c302 = function(s) {return [rp(new CS.String(s))];
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c303 = function(c) {return [rp(new CS.String(c))];
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c304 = function(e) {return [e];
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c305 = function(e) {return rp(new CS.Throw(e));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c306 = function(e) {return rp(new CS.Return(e));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c307 = function() {return rp(new CS.Continue);
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c308 = function() {return rp(new CS.Break);
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c309 = function() {return rp(new CS.Debugger);
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c310 = function() {return rp(new CS.Undefined);
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c311 = function() {return rp(new CS.Null);
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c312 = "arguments",
        peg$c313 = { type: "literal", value: "arguments", description: "\"arguments\"" },
        peg$c314 = "eval",
        peg$c315 = { type: "literal", value: "eval", description: "\"eval\"" },
        peg$c316 = function(i) {return i;
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c317 = function(v) {var key;
        key = rp(new CS.String(v.memberName));
        return rp(new CS.ObjectInitialiserMember(key, v));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c318 = function(i) {return rp(new CS.ObjectInitialiserMember(i, i));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c319 = /^[$_]/,
        peg$c320 = { type: "class", value: "[$_]", description: "[$_]" },
        peg$c321 = "###",
        peg$c322 = { type: "literal", value: "###", description: "\"###\"" },
        peg$c323 = /^[^#]/,
        peg$c324 = { type: "class", value: "[^#]", description: "[^#]" },
        peg$c325 = /^[\t\x0B\f \xA0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/,
        peg$c326 = { type: "class", value: "[\\t\\x0B\\f \\xA0\\uFEFF\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]", description: "[\\t\\x0B\\f \\xA0\\uFEFF\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]" },
        peg$c327 = "\r",
        peg$c328 = { type: "literal", value: "\r", description: "\"\\r\"" },
        peg$c329 = "\n",
        peg$c330 = { type: "literal", value: "\n", description: "\"\\n\"" },
        peg$c331 = "\uEFEF",
        peg$c332 = { type: "literal", value: "\uEFEF", description: "\"\\uEFEF\"" },
        peg$c333 = function(ws) {return ws;
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c334 = "\uEFFE",
        peg$c335 = { type: "literal", value: "\uEFFE", description: "\"\\uEFFE\"" },
        peg$c336 = "\uEFFF",
        peg$c337 = { type: "literal", value: "\uEFFF", description: "\"\\uEFFF\"" },
        peg$c338 = function() {return '';
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c339 = "and",
        peg$c340 = { type: "literal", value: "and", description: "\"and\"" },
        peg$c341 = "break",
        peg$c342 = { type: "literal", value: "break", description: "\"break\"" },
        peg$c343 = "by",
        peg$c344 = { type: "literal", value: "by", description: "\"by\"" },
        peg$c345 = "catch",
        peg$c346 = { type: "literal", value: "catch", description: "\"catch\"" },
        peg$c347 = "continue",
        peg$c348 = { type: "literal", value: "continue", description: "\"continue\"" },
        peg$c349 = "class",
        peg$c350 = { type: "literal", value: "class", description: "\"class\"" },
        peg$c351 = "delete",
        peg$c352 = { type: "literal", value: "delete", description: "\"delete\"" },
        peg$c353 = "debugger",
        peg$c354 = { type: "literal", value: "debugger", description: "\"debugger\"" },
        peg$c355 = "do",
        peg$c356 = { type: "literal", value: "do", description: "\"do\"" },
        peg$c357 = "else",
        peg$c358 = { type: "literal", value: "else", description: "\"else\"" },
        peg$c359 = "extends",
        peg$c360 = { type: "literal", value: "extends", description: "\"extends\"" },
        peg$c361 = "false",
        peg$c362 = { type: "literal", value: "false", description: "\"false\"" },
        peg$c363 = "finally",
        peg$c364 = { type: "literal", value: "finally", description: "\"finally\"" },
        peg$c365 = "for",
        peg$c366 = { type: "literal", value: "for", description: "\"for\"" },
        peg$c367 = "if",
        peg$c368 = { type: "literal", value: "if", description: "\"if\"" },
        peg$c369 = "in",
        peg$c370 = { type: "literal", value: "in", description: "\"in\"" },
        peg$c371 = "instanceof",
        peg$c372 = { type: "literal", value: "instanceof", description: "\"instanceof\"" },
        peg$c373 = "is",
        peg$c374 = { type: "literal", value: "is", description: "\"is\"" },
        peg$c375 = "isnt",
        peg$c376 = { type: "literal", value: "isnt", description: "\"isnt\"" },
        peg$c377 = "loop",
        peg$c378 = { type: "literal", value: "loop", description: "\"loop\"" },
        peg$c379 = "new",
        peg$c380 = { type: "literal", value: "new", description: "\"new\"" },
        peg$c381 = "no",
        peg$c382 = { type: "literal", value: "no", description: "\"no\"" },
        peg$c383 = "not",
        peg$c384 = { type: "literal", value: "not", description: "\"not\"" },
        peg$c385 = "null",
        peg$c386 = { type: "literal", value: "null", description: "\"null\"" },
        peg$c387 = "of",
        peg$c388 = { type: "literal", value: "of", description: "\"of\"" },
        peg$c389 = "off",
        peg$c390 = { type: "literal", value: "off", description: "\"off\"" },
        peg$c391 = "on",
        peg$c392 = { type: "literal", value: "on", description: "\"on\"" },
        peg$c393 = "or",
        peg$c394 = { type: "literal", value: "or", description: "\"or\"" },
        peg$c395 = "own",
        peg$c396 = { type: "literal", value: "own", description: "\"own\"" },
        peg$c397 = "return",
        peg$c398 = { type: "literal", value: "return", description: "\"return\"" },
        peg$c399 = "switch",
        peg$c400 = { type: "literal", value: "switch", description: "\"switch\"" },
        peg$c401 = "then",
        peg$c402 = { type: "literal", value: "then", description: "\"then\"" },
        peg$c403 = "this",
        peg$c404 = { type: "literal", value: "this", description: "\"this\"" },
        peg$c405 = "throw",
        peg$c406 = { type: "literal", value: "throw", description: "\"throw\"" },
        peg$c407 = "true",
        peg$c408 = { type: "literal", value: "true", description: "\"true\"" },
        peg$c409 = "try",
        peg$c410 = { type: "literal", value: "try", description: "\"try\"" },
        peg$c411 = "typeof",
        peg$c412 = { type: "literal", value: "typeof", description: "\"typeof\"" },
        peg$c413 = "undefined",
        peg$c414 = { type: "literal", value: "undefined", description: "\"undefined\"" },
        peg$c415 = "unless",
        peg$c416 = { type: "literal", value: "unless", description: "\"unless\"" },
        peg$c417 = "until",
        peg$c418 = { type: "literal", value: "until", description: "\"until\"" },
        peg$c419 = "when",
        peg$c420 = { type: "literal", value: "when", description: "\"when\"" },
        peg$c421 = "while",
        peg$c422 = { type: "literal", value: "while", description: "\"while\"" },
        peg$c423 = "yes",
        peg$c424 = { type: "literal", value: "yes", description: "\"yes\"" },
        peg$c425 = "super",
        peg$c426 = { type: "literal", value: "super", description: "\"super\"" },
        peg$c427 = "case",
        peg$c428 = { type: "literal", value: "case", description: "\"case\"" },
        peg$c429 = "default",
        peg$c430 = { type: "literal", value: "default", description: "\"default\"" },
        peg$c431 = "function",
        peg$c432 = { type: "literal", value: "function", description: "\"function\"" },
        peg$c433 = "var",
        peg$c434 = { type: "literal", value: "var", description: "\"var\"" },
        peg$c435 = "void",
        peg$c436 = { type: "literal", value: "void", description: "\"void\"" },
        peg$c437 = "with",
        peg$c438 = { type: "literal", value: "with", description: "\"with\"" },
        peg$c439 = "const",
        peg$c440 = { type: "literal", value: "const", description: "\"const\"" },
        peg$c441 = "let",
        peg$c442 = { type: "literal", value: "let", description: "\"let\"" },
        peg$c443 = "enum",
        peg$c444 = { type: "literal", value: "enum", description: "\"enum\"" },
        peg$c445 = "export",
        peg$c446 = { type: "literal", value: "export", description: "\"export\"" },
        peg$c447 = "import",
        peg$c448 = { type: "literal", value: "import", description: "\"import\"" },
        peg$c449 = "native",
        peg$c450 = { type: "literal", value: "native", description: "\"native\"" },
        peg$c451 = "implements",
        peg$c452 = { type: "literal", value: "implements", description: "\"implements\"" },
        peg$c453 = "interface",
        peg$c454 = { type: "literal", value: "interface", description: "\"interface\"" },
        peg$c455 = "package",
        peg$c456 = { type: "literal", value: "package", description: "\"package\"" },
        peg$c457 = "private",
        peg$c458 = { type: "literal", value: "private", description: "\"private\"" },
        peg$c459 = "protected",
        peg$c460 = { type: "literal", value: "protected", description: "\"protected\"" },
        peg$c461 = "public",
        peg$c462 = { type: "literal", value: "public", description: "\"public\"" },
        peg$c463 = "static",
        peg$c464 = { type: "literal", value: "static", description: "\"static\"" },
        peg$c465 = "yield",
        peg$c466 = { type: "literal", value: "yield", description: "\"yield\"" },
        peg$c467 = "\\u",
        peg$c468 = { type: "literal", value: "\\u", description: "\"\\\\u\"" },
        peg$c469 = function(h0, h1, h2, h3) {return String.fromCharCode(parseInt(h0 + h1 + h2 + h3, 16));
        function isOwn$(o, p) {
          return {}.hasOwnProperty.call(o, p);
        }
        function in$(member, list) {
          for (var i = 0, length = list.length; i < length; ++i)
            if (i in list && list[i] === member)
              return true;
          return false;
        }},
        peg$c470 = /^[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0531-\u0556\u10A0-\u10C5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uFF21-\uFF3Aa-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0561-\u0587\u1D00-\u1D2B\u1D62-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7C\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2D00-\u2D25\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D61\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA717-\uA71F\uA770\uA788\uA9CF\uAA70\uAADD\uFF70\uFF9E\uFF9F\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC\u0EDD\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u1100-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BC0-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u2135-\u2138\u2D30-\u2D65\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400\u4DB5\u4E00\u9FCB\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA2D\uFA30-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]/,
        peg$c471 = { type: "class", value: "[A-Z\\xC0-\\xD6\\xD8-\\xDE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017B\\u017D\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019C\\u019D\\u019F\\u01A0\\u01A2\\u01A4\\u01A6\\u01A7\\u01A9\\u01AC\\u01AE\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A\\u023B\\u023D\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u0386\\u0388-\\u038A\\u038C\\u038E\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0531-\\u0556\\u10A0-\\u10C5\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uFF21-\\uFF3Aa-z\\xAA\\xB5\\xBA\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0561-\\u0587\\u1D00-\\u1D2B\\u1D62-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6\\u1FC7\\u1FD0-\\u1FD3\\u1FD6\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6\\u1FF7\\u210A\\u210E\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73\\u2C74\\u2C76-\\u2C7C\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3\\u2CE4\\u2CEC\\u2CEE\\u2D00-\\u2D25\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7FA\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5\\u06E6\\u07F4\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D61\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA717-\\uA71F\\uA770\\uA788\\uA9CF\\uAA70\\uAADD\\uFF70\\uFF9E\\uFF9F\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10D0-\\u10FA\\u1100-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BC0-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u2135-\\u2138\\u2D30-\\u2D65\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FCB\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB\\uAADC\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA2D\\uFA30-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF]", description: "[A-Z\\xC0-\\xD6\\xD8-\\xDE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017B\\u017D\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019C\\u019D\\u019F\\u01A0\\u01A2\\u01A4\\u01A6\\u01A7\\u01A9\\u01AC\\u01AE\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A\\u023B\\u023D\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u0386\\u0388-\\u038A\\u038C\\u038E\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0531-\\u0556\\u10A0-\\u10C5\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uFF21-\\uFF3Aa-z\\xAA\\xB5\\xBA\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0561-\\u0587\\u1D00-\\u1D2B\\u1D62-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6\\u1FC7\\u1FD0-\\u1FD3\\u1FD6\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6\\u1FF7\\u210A\\u210E\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73\\u2C74\\u2C76-\\u2C7C\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3\\u2CE4\\u2CEC\\u2CEE\\u2D00-\\u2D25\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7FA\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5\\u06E6\\u07F4\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D61\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA717-\\uA71F\\uA770\\uA788\\uA9CF\\uAA70\\uAADD\\uFF70\\uFF9E\\uFF9F\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10D0-\\u10FA\\u1100-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BC0-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u2135-\\u2138\\u2D30-\\u2D65\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FCB\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB\\uAADC\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA2D\\uFA30-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF]" },
        peg$c472 = "\uD82C",
        peg$c473 = { type: "literal", value: "\uD82C", description: "\"\\uD82C\"" },
        peg$c474 = /^[\uDC00\uDC01]/,
        peg$c475 = { type: "class", value: "[\\uDC00\\uDC01]", description: "[\\uDC00\\uDC01]" },
        peg$c476 = "\uD808",
        peg$c477 = { type: "literal", value: "\uD808", description: "\"\\uD808\"" },
        peg$c478 = /^[\uDC00-\uDF6E]/,
        peg$c479 = { type: "class", value: "[\\uDC00-\\uDF6E]", description: "[\\uDC00-\\uDF6E]" },
        peg$c480 = "\uD869",
        peg$c481 = { type: "literal", value: "\uD869", description: "\"\\uD869\"" },
        peg$c482 = /^[\uDED6\uDF00]/,
        peg$c483 = { type: "class", value: "[\\uDED6\\uDF00]", description: "[\\uDED6\\uDF00]" },
        peg$c484 = "\uD809",
        peg$c485 = { type: "literal", value: "\uD809", description: "\"\\uD809\"" },
        peg$c486 = /^[\uDC00-\uDC62]/,
        peg$c487 = { type: "class", value: "[\\uDC00-\\uDC62]", description: "[\\uDC00-\\uDC62]" },
        peg$c488 = "\uD835",
        peg$c489 = { type: "literal", value: "\uD835", description: "\"\\uD835\"" },
        peg$c490 = /^[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]/,
        peg$c491 = { type: "class", value: "[\\uDC00-\\uDC19\\uDC34-\\uDC4D\\uDC68-\\uDC81\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB5\\uDCD0-\\uDCE9\\uDD04\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD38\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD6C-\\uDD85\\uDDA0-\\uDDB9\\uDDD4-\\uDDED\\uDE08-\\uDE21\\uDE3C-\\uDE55\\uDE70-\\uDE89\\uDEA8-\\uDEC0\\uDEE2-\\uDEFA\\uDF1C-\\uDF34\\uDF56-\\uDF6E\\uDF90-\\uDFA8\\uDFCA\\uDC1A-\\uDC33\\uDC4E-\\uDC54\\uDC56-\\uDC67\\uDC82-\\uDC9B\\uDCB6-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDCCF\\uDCEA-\\uDD03\\uDD1E-\\uDD37\\uDD52-\\uDD6B\\uDD86-\\uDD9F\\uDDBA-\\uDDD3\\uDDEE-\\uDE07\\uDE22-\\uDE3B\\uDE56-\\uDE6F\\uDE8A-\\uDEA5\\uDEC2-\\uDEDA\\uDEDC-\\uDEE1\\uDEFC-\\uDF14\\uDF16-\\uDF1B\\uDF36-\\uDF4E\\uDF50-\\uDF55\\uDF70-\\uDF88\\uDF8A-\\uDF8F\\uDFAA-\\uDFC2\\uDFC4-\\uDFC9\\uDFCB]", description: "[\\uDC00-\\uDC19\\uDC34-\\uDC4D\\uDC68-\\uDC81\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB5\\uDCD0-\\uDCE9\\uDD04\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD38\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD6C-\\uDD85\\uDDA0-\\uDDB9\\uDDD4-\\uDDED\\uDE08-\\uDE21\\uDE3C-\\uDE55\\uDE70-\\uDE89\\uDEA8-\\uDEC0\\uDEE2-\\uDEFA\\uDF1C-\\uDF34\\uDF56-\\uDF6E\\uDF90-\\uDFA8\\uDFCA\\uDC1A-\\uDC33\\uDC4E-\\uDC54\\uDC56-\\uDC67\\uDC82-\\uDC9B\\uDCB6-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDCCF\\uDCEA-\\uDD03\\uDD1E-\\uDD37\\uDD52-\\uDD6B\\uDD86-\\uDD9F\\uDDBA-\\uDDD3\\uDDEE-\\uDE07\\uDE22-\\uDE3B\\uDE56-\\uDE6F\\uDE8A-\\uDEA5\\uDEC2-\\uDEDA\\uDEDC-\\uDEE1\\uDEFC-\\uDF14\\uDF16-\\uDF1B\\uDF36-\\uDF4E\\uDF50-\\uDF55\\uDF70-\\uDF88\\uDF8A-\\uDF8F\\uDFAA-\\uDFC2\\uDFC4-\\uDFC9\\uDFCB]" },
        peg$c492 = "\uD804",
        peg$c493 = { type: "literal", value: "\uD804", description: "\"\\uD804\"" },
        peg$c494 = /^[\uDC03-\uDC37\uDC83-\uDCAF]/,
        peg$c495 = { type: "class", value: "[\\uDC03-\\uDC37\\uDC83-\\uDCAF]", description: "[\\uDC03-\\uDC37\\uDC83-\\uDCAF]" },
        peg$c496 = "\uD800",
        peg$c497 = { type: "literal", value: "\uD800", description: "\"\\uD800\"" },
        peg$c498 = /^[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1E\uDF30-\uDF40\uDF42-\uDF49\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]/,
        peg$c499 = { type: "class", value: "[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1E\\uDF30-\\uDF40\\uDF42-\\uDF49\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDD40-\\uDD74\\uDF41\\uDF4A\\uDFD1-\\uDFD5]", description: "[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1E\\uDF30-\\uDF40\\uDF42-\\uDF49\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDD40-\\uDD74\\uDF41\\uDF4A\\uDFD1-\\uDFD5]" },
        peg$c500 = "\uD80C",
        peg$c501 = { type: "literal", value: "\uD80C", description: "\"\\uD80C\"" },
        peg$c502 = /^[\uDC00-\uDFFF]/,
        peg$c503 = { type: "class", value: "[\\uDC00-\\uDFFF]", description: "[\\uDC00-\\uDFFF]" },
        peg$c504 = "\uD801",
        peg$c505 = { type: "literal", value: "\uD801", description: "\"\\uD801\"" },
        peg$c506 = /^[\uDC00-\uDC9D]/,
        peg$c507 = { type: "class", value: "[\\uDC00-\\uDC9D]", description: "[\\uDC00-\\uDC9D]" },
        peg$c508 = "\uD86E",
        peg$c509 = { type: "literal", value: "\uD86E", description: "\"\\uD86E\"" },
        peg$c510 = /^[\uDC1D]/,
        peg$c511 = { type: "class", value: "[\\uDC1D]", description: "[\\uDC1D]" },
        peg$c512 = "\uD803",
        peg$c513 = { type: "literal", value: "\uD803", description: "\"\\uD803\"" },
        peg$c514 = /^[\uDC00-\uDC48]/,
        peg$c515 = { type: "class", value: "[\\uDC00-\\uDC48]", description: "[\\uDC00-\\uDC48]" },
        peg$c516 = "\uD840",
        peg$c517 = { type: "literal", value: "\uD840", description: "\"\\uD840\"" },
        peg$c518 = /^[\uDC00]/,
        peg$c519 = { type: "class", value: "[\\uDC00]", description: "[\\uDC00]" },
        peg$c520 = "\uD87E",
        peg$c521 = { type: "literal", value: "\uD87E", description: "\"\\uD87E\"" },
        peg$c522 = /^[\uDC00-\uDE1D]/,
        peg$c523 = { type: "class", value: "[\\uDC00-\\uDE1D]", description: "[\\uDC00-\\uDE1D]" },
        peg$c524 = "\uD86D",
        peg$c525 = { type: "literal", value: "\uD86D", description: "\"\\uD86D\"" },
        peg$c526 = /^[\uDF34\uDF40]/,
        peg$c527 = { type: "class", value: "[\\uDF34\\uDF40]", description: "[\\uDF34\\uDF40]" },
        peg$c528 = "\uD81A",
        peg$c529 = { type: "literal", value: "\uD81A", description: "\"\\uD81A\"" },
        peg$c530 = /^[\uDC00-\uDE38]/,
        peg$c531 = { type: "class", value: "[\\uDC00-\\uDE38]", description: "[\\uDC00-\\uDE38]" },
        peg$c532 = "\uD802",
        peg$c533 = { type: "literal", value: "\uD802", description: "\"\\uD802\"" },
        peg$c534 = /^[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDD00-\uDD15\uDD20-\uDD39\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72]/,
        peg$c535 = { type: "class", value: "[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72]", description: "[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72]" },
        peg$c536 = "\uD80D",
        peg$c537 = { type: "literal", value: "\uD80D", description: "\"\\uD80D\"" },
        peg$c538 = /^[\uDC00-\uDC2E]/,
        peg$c539 = { type: "class", value: "[\\uDC00-\\uDC2E]", description: "[\\uDC00-\\uDC2E]" },
        peg$c540 = /^[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0900-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1DC0-\u1DE6\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F\uA67C\uA67D\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BE-\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062-\u1064\u1067-\u106D\u1083\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u19B0-\u19C0\u19C8\u19C9\u1A19-\u1A1B\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF2\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAA7B\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]/,
        peg$c541 = { type: "class", value: "[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0900-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]", description: "[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0900-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]" },
        peg$c542 = "\uDB40",
        peg$c543 = { type: "literal", value: "\uDB40", description: "\"\\uDB40\"" },
        peg$c544 = /^[\uDD00-\uDDEF]/,
        peg$c545 = { type: "class", value: "[\\uDD00-\\uDDEF]", description: "[\\uDD00-\\uDDEF]" },
        peg$c546 = "\uD834",
        peg$c547 = { type: "literal", value: "\uD834", description: "\"\\uD834\"" },
        peg$c548 = /^[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44\uDD65\uDD66\uDD6D-\uDD72]/,
        peg$c549 = { type: "class", value: "[\\uDD67-\\uDD69\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44\\uDD65\\uDD66\\uDD6D-\\uDD72]", description: "[\\uDD67-\\uDD69\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44\\uDD65\\uDD66\\uDD6D-\\uDD72]" },
        peg$c550 = /^[\uDC01\uDC38-\uDC46\uDC80\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8]/,
        peg$c551 = { type: "class", value: "[\\uDC01\\uDC38-\\uDC46\\uDC80\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8]", description: "[\\uDC01\\uDC38-\\uDC46\\uDC80\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8]" },
        peg$c552 = /^[\uDDFD]/,
        peg$c553 = { type: "class", value: "[\\uDDFD]", description: "[\\uDDFD]" },
        peg$c554 = /^[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F]/,
        peg$c555 = { type: "class", value: "[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F]", description: "[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F]" },
        peg$c556 = /^[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]/,
        peg$c557 = { type: "class", value: "[0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]", description: "[0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]" },
        peg$c558 = /^[\uDFCE-\uDFFF]/,
        peg$c559 = { type: "class", value: "[\\uDFCE-\\uDFFF]", description: "[\\uDFCE-\\uDFFF]" },
        peg$c560 = /^[\uDC66-\uDC6F]/,
        peg$c561 = { type: "class", value: "[\\uDC66-\\uDC6F]", description: "[\\uDC66-\\uDC6F]" },
        peg$c562 = /^[\uDCA0-\uDCA9]/,
        peg$c563 = { type: "class", value: "[\\uDCA0-\\uDCA9]", description: "[\\uDCA0-\\uDCA9]" },
        peg$c564 = /^[_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F]/,
        peg$c565 = { type: "class", value: "[_\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]", description: "[_\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]" },
        peg$c566 = "\u200C",
        peg$c567 = { type: "literal", value: "\u200C", description: "\"\\u200C\"" },
        peg$c568 = "\u200D",
        peg$c569 = { type: "literal", value: "\u200D", description: "\"\\u200D\"" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$cache = {},
        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parseprogram() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 0,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseTERMINATOR();
      if (s1 === peg$FAILED) {
        s1 = peg$c1;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsetoplevelBlock();
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c2(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsetoplevelBlock() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 204 + 1,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsetoplevelStatement();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseTERMINATOR();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsetoplevelStatement();
              if (s7 !== peg$FAILED) {
                peg$reportedPos = s3;
                s4 = peg$c4(s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseTERMINATOR();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsetoplevelStatement();
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s3;
                  s4 = peg$c4(s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseTERMINATOR();
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c5(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsetoplevelStatement() {
      var s0, s1, s2;

      var key    = peg$currPos * 204 + 2,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parsereturn();
      if (s2 === peg$FAILED) {
        s2 = peg$parsecontinue();
        if (s2 === peg$FAILED) {
          s2 = peg$parsebreak();
        }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = peg$c6;
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsestatement();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c4(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseblock() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 204 + 3,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsestatement();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseTERMINATOR();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsestatement();
              if (s7 !== peg$FAILED) {
                peg$reportedPos = s3;
                s4 = peg$c4(s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseTERMINATOR();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsestatement();
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s3;
                  s4 = peg$c4(s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseTERMINATOR();
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c5(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsestatement() {
      var s0;

      var key    = peg$currPos * 204 + 4,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parseexpression();
      if (s0 === peg$FAILED) {
        s0 = peg$parsereturn();
        if (s0 === peg$FAILED) {
          s0 = peg$parsecontinue();
          if (s0 === peg$FAILED) {
            s0 = peg$parsebreak();
            if (s0 === peg$FAILED) {
              s0 = peg$parsethrow();
              if (s0 === peg$FAILED) {
                s0 = peg$parsedebugger();
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseexpression() {
      var s0;

      var key    = peg$currPos * 204 + 5,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parseexpressionworthy();
      if (s0 === peg$FAILED) {
        s0 = peg$parseseqExpression();
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesecondaryStatement() {
      var s0;

      var key    = peg$currPos * 204 + 6,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsesecondaryExpression();
      if (s0 === peg$FAILED) {
        s0 = peg$parsereturn();
        if (s0 === peg$FAILED) {
          s0 = peg$parsecontinue();
          if (s0 === peg$FAILED) {
            s0 = peg$parsebreak();
            if (s0 === peg$FAILED) {
              s0 = peg$parsethrow();
              if (s0 === peg$FAILED) {
                s0 = peg$parsedebugger();
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesecondaryExpression() {
      var s0;

      var key    = peg$currPos * 204 + 7,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parseexpressionworthy();
      if (s0 === peg$FAILED) {
        s0 = peg$parseassignmentExpression();
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesecondaryExpressionNoImplicitObjectCall() {
      var s0;

      var key    = peg$currPos * 204 + 8,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parseexpressionworthy();
      if (s0 === peg$FAILED) {
        s0 = peg$parseassignmentExpressionNoImplicitObjectCall();
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseexpressionworthy() {
      var s0;

      var key    = peg$currPos * 204 + 9,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsefunctionLiteral();
      if (s0 === peg$FAILED) {
        s0 = peg$parseconditional();
        if (s0 === peg$FAILED) {
          s0 = peg$parsewhile();
          if (s0 === peg$FAILED) {
            s0 = peg$parseloop();
            if (s0 === peg$FAILED) {
              s0 = peg$parsetry();
              if (s0 === peg$FAILED) {
                s0 = peg$parseforOf();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseforIn();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseswitch();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseimplicitObjectLiteral();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseclass();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseseqExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 204 + 10,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsepostfixControlFlowExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 59) {
            s4 = peg$c7;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c8); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parseTERMINATOR();
            if (s5 === peg$FAILED) {
              s5 = peg$c1;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseexpression();
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s2;
                  s3 = peg$c9(s7);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c0;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c1;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c10(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsepostfixControlFlowExpression() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 11,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsesecondaryStatement();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsepostfixControlFlowOp();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsepostfixControlFlowOp();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c11(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsepostfixControlFlowOp() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;

      var key    = peg$currPos * 204 + 12,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseIF();
      if (s1 === peg$FAILED) {
        s1 = peg$parseUNLESS();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseassignmentExpression();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c12(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseWHILE();
        if (s1 === peg$FAILED) {
          s1 = peg$parseUNTIL();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseassignmentExpression();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c12(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseFOR();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parseAssignable();
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s6 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s7 = peg$c13;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c14); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseAssignable();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse_();
                        if (s10 !== peg$FAILED) {
                          peg$reportedPos = s6;
                          s7 = peg$c15(s9);
                          s6 = s7;
                        } else {
                          peg$currPos = s6;
                          s6 = peg$c0;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$c0;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c0;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c0;
                  }
                  if (s6 === peg$FAILED) {
                    s6 = peg$c1;
                  }
                  if (s6 !== peg$FAILED) {
                    peg$reportedPos = s3;
                    s4 = peg$c16(s4, s6);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c0;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$c1;
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseIN();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseassignmentExpression();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$currPos;
                      s8 = peg$parse_();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseBY();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parse_();
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parseassignmentExpression();
                            if (s11 !== peg$FAILED) {
                              peg$reportedPos = s7;
                              s8 = peg$c15(s11);
                              s7 = s8;
                            } else {
                              peg$currPos = s7;
                              s7 = peg$c0;
                            }
                          } else {
                            peg$currPos = s7;
                            s7 = peg$c0;
                          }
                        } else {
                          peg$currPos = s7;
                          s7 = peg$c0;
                        }
                      } else {
                        peg$currPos = s7;
                        s7 = peg$c0;
                      }
                      if (s7 === peg$FAILED) {
                        s7 = peg$c1;
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$currPos;
                        s9 = peg$parse_();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parseWHEN();
                          if (s10 !== peg$FAILED) {
                            s11 = peg$parse_();
                            if (s11 !== peg$FAILED) {
                              s12 = peg$parseassignmentExpression();
                              if (s12 !== peg$FAILED) {
                                peg$reportedPos = s8;
                                s9 = peg$c15(s12);
                                s8 = s9;
                              } else {
                                peg$currPos = s8;
                                s8 = peg$c0;
                              }
                            } else {
                              peg$currPos = s8;
                              s8 = peg$c0;
                            }
                          } else {
                            peg$currPos = s8;
                            s8 = peg$c0;
                          }
                        } else {
                          peg$currPos = s8;
                          s8 = peg$c0;
                        }
                        if (s8 === peg$FAILED) {
                          s8 = peg$c1;
                        }
                        if (s8 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c17(s3, s6, s7, s8);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseFOR();
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseOWN();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    s4 = [s4, s5];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c0;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$c1;
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseAssignable();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parse_();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$currPos;
                      if (input.charCodeAt(peg$currPos) === 44) {
                        s7 = peg$c13;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c14); }
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parse_();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parseAssignable();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parse_();
                            if (s10 !== peg$FAILED) {
                              peg$reportedPos = s6;
                              s7 = peg$c15(s9);
                              s6 = s7;
                            } else {
                              peg$currPos = s6;
                              s6 = peg$c0;
                            }
                          } else {
                            peg$currPos = s6;
                            s6 = peg$c0;
                          }
                        } else {
                          peg$currPos = s6;
                          s6 = peg$c0;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$c0;
                      }
                      if (s6 === peg$FAILED) {
                        s6 = peg$c1;
                      }
                      if (s6 !== peg$FAILED) {
                        s7 = peg$parseOF();
                        if (s7 !== peg$FAILED) {
                          s8 = peg$parse_();
                          if (s8 !== peg$FAILED) {
                            s9 = peg$parseassignmentExpression();
                            if (s9 !== peg$FAILED) {
                              s10 = peg$currPos;
                              s11 = peg$parse_();
                              if (s11 !== peg$FAILED) {
                                s12 = peg$parseWHEN();
                                if (s12 !== peg$FAILED) {
                                  s13 = peg$parse_();
                                  if (s13 !== peg$FAILED) {
                                    s14 = peg$parseassignmentExpression();
                                    if (s14 !== peg$FAILED) {
                                      peg$reportedPos = s10;
                                      s11 = peg$c15(s14);
                                      s10 = s11;
                                    } else {
                                      peg$currPos = s10;
                                      s10 = peg$c0;
                                    }
                                  } else {
                                    peg$currPos = s10;
                                    s10 = peg$c0;
                                  }
                                } else {
                                  peg$currPos = s10;
                                  s10 = peg$c0;
                                }
                              } else {
                                peg$currPos = s10;
                                s10 = peg$c0;
                              }
                              if (s10 === peg$FAILED) {
                                s10 = peg$c1;
                              }
                              if (s10 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c18(s3, s4, s6, s9, s10);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseassignmentExpression() {
      var s0;

      var key    = peg$currPos * 204 + 13,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parseassignmentOp();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecompoundAssignmentOp();
        if (s0 === peg$FAILED) {
          s0 = peg$parseexistsAssignmentOp();
          if (s0 === peg$FAILED) {
            s0 = peg$parsebinaryExpression();
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseassignmentOp() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      var key    = peg$currPos * 204 + 14,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseAssignable();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c19;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c20); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 61) {
              s5 = peg$c19;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c20); }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = peg$c6;
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = peg$parseTERMINDENT();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsesecondaryExpression();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseDEDENT();
                  if (s8 !== peg$FAILED) {
                    peg$reportedPos = s5;
                    s6 = peg$c9(s7);
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
              if (s5 === peg$FAILED) {
                s5 = peg$currPos;
                s6 = peg$parseTERMINATOR();
                if (s6 === peg$FAILED) {
                  s6 = peg$c1;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsesecondaryExpression();
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s5;
                      s6 = peg$c9(s8);
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c0;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c21(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecompoundAssignmentOp() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      var key    = peg$currPos * 204 + 15,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseCompoundAssignable();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 63) {
            s4 = peg$c22;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c23); }
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = peg$c6;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseCompoundAssignmentOperators();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s5 = peg$c19;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c20); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$currPos;
                s7 = peg$parseTERMINDENT();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsesecondaryExpression();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseDEDENT();
                    if (s9 !== peg$FAILED) {
                      peg$reportedPos = s6;
                      s7 = peg$c9(s8);
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c0;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c0;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$c0;
                }
                if (s6 === peg$FAILED) {
                  s6 = peg$currPos;
                  s7 = peg$parseTERMINATOR();
                  if (s7 === peg$FAILED) {
                    s7 = peg$c1;
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsesecondaryExpression();
                      if (s9 !== peg$FAILED) {
                        peg$reportedPos = s6;
                        s7 = peg$c9(s9);
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$c0;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c0;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c0;
                  }
                }
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c24(s1, s4, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseCompoundAssignmentOperators() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 16,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c25) {
        s1 = peg$c25;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c26); }
      }
      if (s1 === peg$FAILED) {
        s1 = peg$parseAND();
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c27) {
            s1 = peg$c27;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c28); }
          }
          if (s1 === peg$FAILED) {
            s1 = peg$parseOR();
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c29) {
                s1 = peg$c29;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c30); }
              }
              if (s1 === peg$FAILED) {
                if (peg$c31.test(input.charAt(peg$currPos))) {
                  s1 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c32); }
                }
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 43) {
                    s2 = peg$c33;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c34); }
                  }
                  if (s2 !== peg$FAILED) {
                    s3 = peg$currPos;
                    peg$silentFails++;
                    if (input.charCodeAt(peg$currPos) === 43) {
                      s4 = peg$c33;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c34); }
                    }
                    peg$silentFails--;
                    if (s4 === peg$FAILED) {
                      s3 = peg$c6;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$c0;
                    }
                    if (s3 !== peg$FAILED) {
                      s2 = [s2, s3];
                      s1 = s2;
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c0;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c0;
                  }
                  if (s1 === peg$FAILED) {
                    s1 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 45) {
                      s2 = peg$c35;
                      peg$currPos++;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c36); }
                    }
                    if (s2 !== peg$FAILED) {
                      s3 = peg$currPos;
                      peg$silentFails++;
                      if (input.charCodeAt(peg$currPos) === 45) {
                        s4 = peg$c35;
                        peg$currPos++;
                      } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c36); }
                      }
                      peg$silentFails--;
                      if (s4 === peg$FAILED) {
                        s3 = peg$c6;
                      } else {
                        peg$currPos = s3;
                        s3 = peg$c0;
                      }
                      if (s3 !== peg$FAILED) {
                        s2 = [s2, s3];
                        s1 = s2;
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c0;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c0;
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c37) {
                        s1 = peg$c37;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c38); }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 3) === peg$c39) {
                          s1 = peg$c39;
                          peg$currPos += 3;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c40); }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 2) === peg$c41) {
                            s1 = peg$c41;
                            peg$currPos += 2;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c42); }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseexistsAssignmentOp() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      var key    = peg$currPos * 204 + 17,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseCompoundAssignable();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c43) {
            s3 = peg$c43;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c44); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = peg$parseTERMINDENT();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsesecondaryExpression();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseDEDENT();
                  if (s8 !== peg$FAILED) {
                    peg$reportedPos = s5;
                    s6 = peg$c9(s7);
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
              if (s5 === peg$FAILED) {
                s5 = peg$currPos;
                s6 = peg$parseTERMINATOR();
                if (s6 === peg$FAILED) {
                  s6 = peg$c1;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsesecondaryExpression();
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s5;
                      s6 = peg$c9(s8);
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c0;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c45(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseassignmentExpressionNoImplicitObjectCall() {
      var s0;

      var key    = peg$currPos * 204 + 18,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parseassignmentOpNoImplicitObjectCall();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecompoundAssignmentOpNoImplicitObjectCall();
        if (s0 === peg$FAILED) {
          s0 = peg$parseexistsAssignmentOpNoImplicitObjectCall();
          if (s0 === peg$FAILED) {
            s0 = peg$parsebinaryExpressionNoImplicitObjectCall();
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseassignmentOpNoImplicitObjectCall() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      var key    = peg$currPos * 204 + 19,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseAssignable();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c19;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c20); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 61) {
              s5 = peg$c19;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c20); }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = peg$c6;
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = peg$parseTERMINDENT();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsesecondaryExpressionNoImplicitObjectCall();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseDEDENT();
                  if (s8 !== peg$FAILED) {
                    peg$reportedPos = s5;
                    s6 = peg$c9(s7);
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
              if (s5 === peg$FAILED) {
                s5 = peg$currPos;
                s6 = peg$parseTERMINATOR();
                if (s6 === peg$FAILED) {
                  s6 = peg$c1;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsesecondaryExpressionNoImplicitObjectCall();
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s5;
                      s6 = peg$c9(s8);
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c0;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c21(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecompoundAssignmentOpNoImplicitObjectCall() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      var key    = peg$currPos * 204 + 20,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseCompoundAssignable();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 63) {
            s4 = peg$c22;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c23); }
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = peg$c6;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseCompoundAssignmentOperators();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s5 = peg$c19;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c20); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$currPos;
                s7 = peg$parseTERMINDENT();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsesecondaryExpressionNoImplicitObjectCall();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseDEDENT();
                    if (s9 !== peg$FAILED) {
                      peg$reportedPos = s6;
                      s7 = peg$c9(s8);
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c0;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c0;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$c0;
                }
                if (s6 === peg$FAILED) {
                  s6 = peg$currPos;
                  s7 = peg$parseTERMINATOR();
                  if (s7 === peg$FAILED) {
                    s7 = peg$c1;
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parsesecondaryExpressionNoImplicitObjectCall();
                      if (s9 !== peg$FAILED) {
                        peg$reportedPos = s6;
                        s7 = peg$c9(s9);
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$c0;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c0;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c0;
                  }
                }
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c24(s1, s4, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseexistsAssignmentOpNoImplicitObjectCall() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      var key    = peg$currPos * 204 + 21,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseCompoundAssignable();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c43) {
            s3 = peg$c43;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c44); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = peg$parseTERMINDENT();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsesecondaryExpressionNoImplicitObjectCall();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseDEDENT();
                  if (s8 !== peg$FAILED) {
                    peg$reportedPos = s5;
                    s6 = peg$c9(s7);
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
              if (s5 === peg$FAILED) {
                s5 = peg$currPos;
                s6 = peg$parseTERMINATOR();
                if (s6 === peg$FAILED) {
                  s6 = peg$c1;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsesecondaryExpressionNoImplicitObjectCall();
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s5;
                      s6 = peg$c9(s8);
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c0;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c45(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsebinaryExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      var key    = peg$currPos * 204 + 22,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseprefixExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsebinaryOperator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseTERMINATOR();
            if (s6 === peg$FAILED) {
              s6 = peg$c1;
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parse_();
              if (s7 !== peg$FAILED) {
                s8 = peg$parseexpressionworthy();
                if (s8 === peg$FAILED) {
                  s8 = peg$parseprefixExpression();
                }
                if (s8 !== peg$FAILED) {
                  peg$reportedPos = s3;
                  s4 = peg$c46(s5, s8);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsebinaryOperator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseTERMINATOR();
              if (s6 === peg$FAILED) {
                s6 = peg$c1;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseexpressionworthy();
                  if (s8 === peg$FAILED) {
                    s8 = peg$parseprefixExpression();
                  }
                  if (s8 !== peg$FAILED) {
                    peg$reportedPos = s3;
                    s4 = peg$c46(s5, s8);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c0;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c47(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsebinaryOperator() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 23,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseCompoundAssignmentOperators();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 61) {
          s4 = peg$c19;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c20); }
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c48) {
          s0 = peg$c48;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c49); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c50) {
            s0 = peg$c50;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c51); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 60) {
              s0 = peg$c52;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c53); }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 62) {
                s0 = peg$c54;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c55); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c56) {
                  s0 = peg$c56;
                  peg$currPos += 2;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c57); }
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$parseIS();
                  if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c58) {
                      s0 = peg$c58;
                      peg$currPos += 2;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c59); }
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseISNT();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseEXTENDS();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseINSTANCEOF();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseIN();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseOF();
                              if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$parseNOT();
                                if (s1 !== peg$FAILED) {
                                  s2 = peg$parse_();
                                  if (s2 !== peg$FAILED) {
                                    s3 = peg$parseINSTANCEOF();
                                    if (s3 === peg$FAILED) {
                                      s3 = peg$parseIN();
                                      if (s3 === peg$FAILED) {
                                        s3 = peg$parseOF();
                                      }
                                    }
                                    if (s3 !== peg$FAILED) {
                                      peg$reportedPos = s0;
                                      s1 = peg$c60(s3);
                                      s0 = s1;
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$c0;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$c0;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsebinaryExpressionNoImplicitObjectCall() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      var key    = peg$currPos * 204 + 24,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseprefixExpressionNoImplicitObjectCall();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsebinaryOperator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseTERMINATOR();
            if (s6 === peg$FAILED) {
              s6 = peg$c1;
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parse_();
              if (s7 !== peg$FAILED) {
                s8 = peg$parseexpressionworthy();
                if (s8 === peg$FAILED) {
                  s8 = peg$parseprefixExpressionNoImplicitObjectCall();
                }
                if (s8 !== peg$FAILED) {
                  peg$reportedPos = s3;
                  s4 = peg$c46(s5, s8);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsebinaryOperator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseTERMINATOR();
              if (s6 === peg$FAILED) {
                s6 = peg$c1;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseexpressionworthy();
                  if (s8 === peg$FAILED) {
                    s8 = peg$parseprefixExpressionNoImplicitObjectCall();
                  }
                  if (s8 !== peg$FAILED) {
                    peg$reportedPos = s3;
                    s4 = peg$c46(s5, s8);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c0;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c47(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseprefixExpression() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 25,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsepostfixExpression();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseDO();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsenfe();
            if (s3 === peg$FAILED) {
              s3 = peg$parseexpressionworthy();
              if (s3 === peg$FAILED) {
                s3 = peg$parseprefixExpression();
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c61(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$currPos;
          s3 = peg$parsePrefixOperators();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s2;
              s3 = peg$c62(s3);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$currPos;
              s3 = peg$parsePrefixOperators();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  peg$reportedPos = s2;
                  s3 = peg$c62(s3);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c0;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            }
          } else {
            s1 = peg$c0;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseexpressionworthy();
            if (s2 === peg$FAILED) {
              s2 = peg$parseprefixExpression();
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c63(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsePrefixOperators() {
      var s0;

      var key    = peg$currPos * 204 + 26,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (input.substr(peg$currPos, 2) === peg$c64) {
        s0 = peg$c64;
        peg$currPos += 2;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c65); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c66) {
          s0 = peg$c66;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c67); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 43) {
            s0 = peg$c33;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c34); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s0 = peg$c35;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c36); }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 33) {
                s0 = peg$c68;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c69); }
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parseNOT();
                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 126) {
                    s0 = peg$c70;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c71); }
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseDO();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parseTYPEOF();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseDELETE();
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenfe() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 204 + 27,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parseunassignable();
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = peg$c6;
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseAssignable();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s4 = peg$c19;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c20); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsefunctionLiteral();
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c72(s2, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseprefixExpressionNoImplicitObjectCall() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 28,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsepostfixExpressionNoImplicitObjectCall();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseDO();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsenfe();
            if (s3 === peg$FAILED) {
              s3 = peg$parseexpressionworthy();
              if (s3 === peg$FAILED) {
                s3 = peg$parseprefixExpressionNoImplicitObjectCall();
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c61(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$currPos;
          s3 = peg$parsePrefixOperators();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s2;
              s3 = peg$c62(s3);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
          if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$currPos;
              s3 = peg$parsePrefixOperators();
              if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                  peg$reportedPos = s2;
                  s3 = peg$c62(s3);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c0;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            }
          } else {
            s1 = peg$c0;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseexpressionworthy();
            if (s2 === peg$FAILED) {
              s2 = peg$parseprefixExpressionNoImplicitObjectCall();
            }
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c63(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsepostfixExpression() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 29,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseleftHandSideExpression();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsePostfixOperators();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsePostfixOperators();
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c73(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsePostfixOperators() {
      var s0;

      var key    = peg$currPos * 204 + 30,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (input.charCodeAt(peg$currPos) === 63) {
        s0 = peg$c22;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c23); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 4) === peg$c74) {
          s0 = peg$c74;
          peg$currPos += 4;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c75); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c64) {
            s0 = peg$c64;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c65); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c66) {
              s0 = peg$c66;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c67); }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsepostfixExpressionNoImplicitObjectCall() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 31,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseleftHandSideExpressionNoImplicitObjectCall();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsePostfixOperators();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsePostfixOperators();
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c73(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseleftHandSideExpression() {
      var s0;

      var key    = peg$currPos * 204 + 32,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsecallExpression();
      if (s0 === peg$FAILED) {
        s0 = peg$parsenewExpression();
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseargumentList() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 204 + 33,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 63) {
        s1 = peg$c22;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c23); }
      }
      if (s1 === peg$FAILED) {
        s1 = peg$c1;
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 40) {
          s2 = peg$c76;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c77); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseargumentListContents();
            if (s4 === peg$FAILED) {
              s4 = peg$c1;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 41) {
                  s6 = peg$c78;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c79); }
                }
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c80(s1, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseargumentListContents() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 204 + 34,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseargument();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c13;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c14); }
          }
          if (s5 === peg$FAILED) {
            s5 = peg$parseTERMINATOR();
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseargument();
              if (s7 !== peg$FAILED) {
                peg$reportedPos = s3;
                s4 = peg$c15(s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c13;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c14); }
            }
            if (s5 === peg$FAILED) {
              s5 = peg$parseTERMINATOR();
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseargument();
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s3;
                  s4 = peg$c15(s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s3 = peg$c13;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c14); }
          }
          if (s3 === peg$FAILED) {
            s3 = peg$parseTERMINATOR();
          }
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c81(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseTERMINDENT();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseargumentListContents();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseDEDENT();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseTERMINATOR();
              if (s4 === peg$FAILED) {
                s4 = peg$c1;
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c15(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseargument() {
      var s0;

      var key    = peg$currPos * 204 + 35,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsespread();
      if (s0 === peg$FAILED) {
        s0 = peg$parseexpression();
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesecondaryArgumentList() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      var key    = peg$currPos * 204 + 36,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$currPos;
        if (peg$c82.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c83); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parse__();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c6;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsesecondaryArgument();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s7 = peg$c13;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c14); }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parseTERMINATOR();
                  if (s9 === peg$FAILED) {
                    s9 = peg$c1;
                  }
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parse_();
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parsesecondaryArgument();
                      if (s11 !== peg$FAILED) {
                        peg$reportedPos = s5;
                        s6 = peg$c15(s11);
                        s5 = s6;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$c0;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c0;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$c0;
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s7 = peg$c13;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c14); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseTERMINATOR();
                    if (s9 === peg$FAILED) {
                      s9 = peg$c1;
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parsesecondaryArgument();
                        if (s11 !== peg$FAILED) {
                          peg$reportedPos = s5;
                          s6 = peg$c15(s11);
                          s5 = s6;
                        } else {
                          peg$currPos = s5;
                          s5 = peg$c0;
                        }
                      } else {
                        peg$currPos = s5;
                        s5 = peg$c0;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c0;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 44) {
                s6 = peg$c13;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c14); }
              }
              if (s6 === peg$FAILED) {
                s6 = peg$c1;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parseTERMINDENT();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseimplicitObjectLiteral();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseDEDENT();
                    if (s9 !== peg$FAILED) {
                      peg$reportedPos = s5;
                      s6 = peg$c62(s8);
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c0;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
              if (s5 === peg$FAILED) {
                s5 = peg$c1;
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c84(s3, s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseTERMINDENT();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseimplicitObjectLiteral();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseDEDENT();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c85(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesecondaryArgument() {
      var s0;

      var key    = peg$currPos * 204 + 37,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsespread();
      if (s0 === peg$FAILED) {
        s0 = peg$parsesingleLineImplicitObjectLiteral();
        if (s0 === peg$FAILED) {
          s0 = peg$parsesecondaryExpression();
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseleftHandSideExpressionNoImplicitObjectCall() {
      var s0;

      var key    = peg$currPos * 204 + 38,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsecallExpressionNoImplicitObjectCall();
      if (s0 === peg$FAILED) {
        s0 = peg$parsenewExpressionNoImplicitObjectCall();
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesecondaryArgumentListNoImplicitObjectCall() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      var key    = peg$currPos * 204 + 39,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$currPos;
        if (peg$c82.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c83); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parse__();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c6;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsesecondaryArgumentNoImplicitObjectCall();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s7 = peg$c13;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c14); }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parseTERMINATOR();
                  if (s9 === peg$FAILED) {
                    s9 = peg$c1;
                  }
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parse_();
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parsesecondaryArgumentNoImplicitObjectCall();
                      if (s11 !== peg$FAILED) {
                        peg$reportedPos = s5;
                        s6 = peg$c9(s11);
                        s5 = s6;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$c0;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c0;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$c0;
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s7 = peg$c13;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c14); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseTERMINATOR();
                    if (s9 === peg$FAILED) {
                      s9 = peg$c1;
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parsesecondaryArgumentNoImplicitObjectCall();
                        if (s11 !== peg$FAILED) {
                          peg$reportedPos = s5;
                          s6 = peg$c9(s11);
                          s5 = s6;
                        } else {
                          peg$currPos = s5;
                          s5 = peg$c0;
                        }
                      } else {
                        peg$currPos = s5;
                        s5 = peg$c0;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c0;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c81(s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesecondaryArgumentNoImplicitObjectCall() {
      var s0;

      var key    = peg$currPos * 204 + 40,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsespreadNoImplicitObjectCall();
      if (s0 === peg$FAILED) {
        s0 = peg$parsesecondaryExpressionNoImplicitObjectCall();
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecallExpression() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 41,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsememberExpression();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsecallExpressionAccesses();
        if (s2 === peg$FAILED) {
          s2 = peg$c1;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 63) {
            s4 = peg$c22;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c23); }
          }
          if (s4 === peg$FAILED) {
            s4 = peg$c1;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsesecondaryArgumentList();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c86(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecallExpressionAccesses() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 42,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseTERMINDENT();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsecallExpressionAccesses();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDEDENT();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c87(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseargumentList();
        if (s2 === peg$FAILED) {
          s2 = peg$parseMemberAccessOps();
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseargumentList();
            if (s2 === peg$FAILED) {
              s2 = peg$parseMemberAccessOps();
            }
          }
        } else {
          s1 = peg$c0;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsecallExpressionAccesses();
          if (s2 === peg$FAILED) {
            s2 = peg$c1;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c88(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecallExpressionNoImplicitObjectCall() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 43,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsememberExpressionNoImplicitObjectCall();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseargumentList();
        if (s3 === peg$FAILED) {
          s3 = peg$parseMemberAccessOps();
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseargumentList();
          if (s3 === peg$FAILED) {
            s3 = peg$parseMemberAccessOps();
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 63) {
            s4 = peg$c22;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c23); }
          }
          if (s4 === peg$FAILED) {
            s4 = peg$c1;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsesecondaryArgumentListNoImplicitObjectCall();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c86(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenewExpression() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 44,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsememberExpression();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseNEW();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseexpressionworthy();
            if (s3 === peg$FAILED) {
              s3 = peg$parsenewExpression();
              if (s3 === peg$FAILED) {
                s3 = peg$parseprefixExpression();
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c89(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenewExpressionNoImplicitObjectCall() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 45,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsememberExpressionNoImplicitObjectCall();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseNEW();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseexpressionworthy();
            if (s3 === peg$FAILED) {
              s3 = peg$parsenewExpressionNoImplicitObjectCall();
              if (s3 === peg$FAILED) {
                s3 = peg$parseprefixExpressionNoImplicitObjectCall();
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c89(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsememberExpression() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 46,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseprimaryExpression();
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        s2 = peg$parseNEW();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsememberExpression();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseargumentList();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s1;
                s2 = peg$c90(s4, s5);
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$c0;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c0;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c0;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseMemberAccessOps();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseMemberAccessOps();
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c91(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseNEW();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsememberExpression();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsesecondaryArgumentList();
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c92(s3, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsememberAccess() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 47,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseprimaryExpression();
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        s2 = peg$parseNEW();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsememberExpression();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseargumentList();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s1;
                s2 = peg$c90(s4, s5);
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$c0;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c0;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c0;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseargumentList();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseMemberAccessOps();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 === peg$FAILED) {
          s3 = peg$parseMemberAccessOps();
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parseargumentList();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseMemberAccessOps();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$parseMemberAccessOps();
            }
          }
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c93(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsecontextVar();
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseMemberAccessOps() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      var key    = peg$currPos * 204 + 48,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseTERMINDENT();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s2 = peg$c94;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c95); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseidentifierName();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseMemberAccessOps();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseMemberAccessOps();
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseDEDENT();
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c96(s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseTERMINATOR();
        if (s1 === peg$FAILED) {
          s1 = peg$c1;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 46) {
              s3 = peg$c94;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c95); }
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseTERMINATOR();
              if (s4 === peg$FAILED) {
                s4 = peg$c1;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseidentifierName();
                  if (s6 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c96(s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c97) {
            s1 = peg$c97;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c98); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseidentifierName();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c99(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c100;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c101); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              if (s2 !== peg$FAILED) {
                s3 = peg$parseexpression();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parse_();
                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s5 = peg$c102;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c103); }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c104(s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c105) {
                s1 = peg$c105;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c106); }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parseexpression();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s5 = peg$c102;
                        peg$currPos++;
                      } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c103); }
                      }
                      if (s5 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c107(s3);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c108) {
                  s1 = peg$c108;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c109); }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parse_();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseidentifierName();
                    if (s3 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c110(s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 3) === peg$c111) {
                    s1 = peg$c111;
                    peg$currPos += 3;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c112); }
                  }
                  if (s1 !== peg$FAILED) {
                    s2 = peg$parse_();
                    if (s2 !== peg$FAILED) {
                      s3 = peg$parseexpression();
                      if (s3 !== peg$FAILED) {
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 93) {
                            s5 = peg$c102;
                            peg$currPos++;
                          } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c103); }
                          }
                          if (s5 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c113(s3);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 3) === peg$c114) {
                      s1 = peg$c114;
                      peg$currPos += 3;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c115); }
                    }
                    if (s1 !== peg$FAILED) {
                      s2 = peg$parse_();
                      if (s2 !== peg$FAILED) {
                        s3 = peg$parseidentifierName();
                        if (s3 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c116(s3);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 4) === peg$c117) {
                        s1 = peg$c117;
                        peg$currPos += 4;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c118); }
                      }
                      if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                          s3 = peg$parseexpression();
                          if (s3 !== peg$FAILED) {
                            s4 = peg$parse_();
                            if (s4 !== peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 93) {
                                s5 = peg$c102;
                                peg$currPos++;
                              } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c103); }
                              }
                              if (s5 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c119(s3);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 91) {
                          s1 = peg$c100;
                          peg$currPos++;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c101); }
                        }
                        if (s1 !== peg$FAILED) {
                          s2 = peg$parse_();
                          if (s2 !== peg$FAILED) {
                            s3 = peg$parseassignmentExpression();
                            if (s3 === peg$FAILED) {
                              s3 = peg$c1;
                            }
                            if (s3 !== peg$FAILED) {
                              s4 = peg$parse_();
                              if (s4 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c120) {
                                  s5 = peg$c120;
                                  peg$currPos += 2;
                                } else {
                                  s5 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c121); }
                                }
                                if (s5 !== peg$FAILED) {
                                  if (input.charCodeAt(peg$currPos) === 46) {
                                    s6 = peg$c94;
                                    peg$currPos++;
                                  } else {
                                    s6 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c95); }
                                  }
                                  if (s6 === peg$FAILED) {
                                    s6 = peg$c1;
                                  }
                                  if (s6 !== peg$FAILED) {
                                    s7 = peg$parse_();
                                    if (s7 !== peg$FAILED) {
                                      s8 = peg$parseassignmentExpression();
                                      if (s8 === peg$FAILED) {
                                        s8 = peg$c1;
                                      }
                                      if (s8 !== peg$FAILED) {
                                        s9 = peg$parse_();
                                        if (s9 !== peg$FAILED) {
                                          if (input.charCodeAt(peg$currPos) === 93) {
                                            s10 = peg$c102;
                                            peg$currPos++;
                                          } else {
                                            s10 = peg$FAILED;
                                            if (peg$silentFails === 0) { peg$fail(peg$c103); }
                                          }
                                          if (s10 !== peg$FAILED) {
                                            peg$reportedPos = s0;
                                            s1 = peg$c122(s3, s6, s8);
                                            s0 = s1;
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$c0;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$c0;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$c0;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$c0;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$c0;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsememberExpressionNoImplicitObjectCall() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 49,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseprimaryExpression();
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        s2 = peg$parseNEW();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsememberExpressionNoImplicitObjectCall();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseargumentList();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s1;
                s2 = peg$c90(s4, s5);
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$c0;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c0;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c0;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseMemberAccessOps();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseMemberAccessOps();
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c91(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseNEW();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsememberExpressionNoImplicitObjectCall();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsesecondaryArgumentListNoImplicitObjectCall();
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c92(s3, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseprimaryExpression() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 204 + 50,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsemacro();
      if (s0 === peg$FAILED) {
        s0 = peg$parseNumbers();
        if (s0 === peg$FAILED) {
          s0 = peg$parsebool();
          if (s0 === peg$FAILED) {
            s0 = peg$parsenull();
            if (s0 === peg$FAILED) {
              s0 = peg$parseundefined();
              if (s0 === peg$FAILED) {
                s0 = peg$parsecontextVar();
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parseTHIS();
                  if (s1 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 64) {
                      s1 = peg$c123;
                      peg$currPos++;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c124); }
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c125();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseidentifier();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parserange();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsearrayLiteral();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseobjectLiteral();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parseinterpolation();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parseJSLiteral();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parsestring();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parseregexp();
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    if (input.charCodeAt(peg$currPos) === 40) {
                                      s1 = peg$c76;
                                      peg$currPos++;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$c77); }
                                    }
                                    if (s1 !== peg$FAILED) {
                                      s2 = peg$parseTERMINDENT();
                                      if (s2 !== peg$FAILED) {
                                        s3 = peg$parseexpression();
                                        if (s3 !== peg$FAILED) {
                                          s4 = peg$parseDEDENT();
                                          if (s4 !== peg$FAILED) {
                                            s5 = peg$parseTERMINATOR();
                                            if (s5 === peg$FAILED) {
                                              s5 = peg$c1;
                                            }
                                            if (s5 !== peg$FAILED) {
                                              if (input.charCodeAt(peg$currPos) === 41) {
                                                s6 = peg$c78;
                                                peg$currPos++;
                                              } else {
                                                s6 = peg$FAILED;
                                                if (peg$silentFails === 0) { peg$fail(peg$c79); }
                                              }
                                              if (s6 !== peg$FAILED) {
                                                peg$reportedPos = s0;
                                                s1 = peg$c126(s3);
                                                s0 = s1;
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$c0;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$c0;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$c0;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$c0;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$c0;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$c0;
                                    }
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$currPos;
                                      if (input.charCodeAt(peg$currPos) === 40) {
                                        s1 = peg$c76;
                                        peg$currPos++;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) { peg$fail(peg$c77); }
                                      }
                                      if (s1 !== peg$FAILED) {
                                        s2 = peg$parse_();
                                        if (s2 !== peg$FAILED) {
                                          s3 = peg$parseexpression();
                                          if (s3 !== peg$FAILED) {
                                            s4 = peg$parse_();
                                            if (s4 !== peg$FAILED) {
                                              s5 = peg$parseTERMINATOR();
                                              if (s5 === peg$FAILED) {
                                                s5 = peg$c1;
                                              }
                                              if (s5 !== peg$FAILED) {
                                                s6 = peg$parse_();
                                                if (s6 !== peg$FAILED) {
                                                  if (input.charCodeAt(peg$currPos) === 41) {
                                                    s7 = peg$c78;
                                                    peg$currPos++;
                                                  } else {
                                                    s7 = peg$FAILED;
                                                    if (peg$silentFails === 0) { peg$fail(peg$c79); }
                                                  }
                                                  if (s7 !== peg$FAILED) {
                                                    peg$reportedPos = s0;
                                                    s1 = peg$c126(s3);
                                                    s0 = s1;
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$c0;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$c0;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$c0;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$c0;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$c0;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$c0;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$c0;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecontextVar() {
      var s0, s1, s2;

      var key    = peg$currPos * 204 + 51,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 64) {
        s2 = peg$c123;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c124); }
      }
      if (s2 !== peg$FAILED) {
        peg$reportedPos = s1;
        s2 = peg$c125();
      }
      s1 = s2;
      if (s1 !== peg$FAILED) {
        s2 = peg$parseidentifierName();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c127(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseJSLiteral() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 52,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 96) {
        s1 = peg$c128;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c129); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = [];
        if (peg$c130.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c131); }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c130.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c131); }
          }
        }
        if (s3 !== peg$FAILED) {
          s3 = input.substring(s2, peg$currPos);
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 96) {
            s3 = peg$c128;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c129); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c132(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsespread() {
      var s0, s1, s2;

      var key    = peg$currPos * 204 + 53,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsepostfixExpression();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c133) {
          s2 = peg$c133;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c134); }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c135(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsespreadNoImplicitObjectCall() {
      var s0, s1, s2;

      var key    = peg$currPos * 204 + 54,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsepostfixExpressionNoImplicitObjectCall();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c133) {
          s2 = peg$c133;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c134); }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c135(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseconditional() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 55,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseIF();
      if (s1 === peg$FAILED) {
        s1 = peg$parseUNLESS();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseassignmentExpressionNoImplicitObjectCall();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseconditionalBody();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseelseClause();
              if (s5 === peg$FAILED) {
                s5 = peg$c1;
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c136(s1, s3, s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseconditionalBody() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 56,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseTERMINDENT();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseblock();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseDEDENT();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c137(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseTERMINATOR();
        if (s1 === peg$FAILED) {
          s1 = peg$c1;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseTHEN();
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s5 = peg$parsestatement();
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c138(s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseTHEN();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c139();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseelseClause() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 57,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseTERMINATOR();
        if (s2 === peg$FAILED) {
          s2 = peg$c1;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseELSE();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsefunctionBody();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c140(s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewhile() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 58,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseWHILE();
      if (s1 === peg$FAILED) {
        s1 = peg$parseUNTIL();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseassignmentExpressionNoImplicitObjectCall();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseconditionalBody();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c141(s1, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseloop() {
      var s0, s1, s2;

      var key    = peg$currPos * 204 + 59,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseLOOP();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseconditionalBody();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c142(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsetry() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 60,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseTRY();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsetryBody();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecatchClause();
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsefinallyClause();
            if (s4 === peg$FAILED) {
              s4 = peg$c1;
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c143(s2, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsetryBody() {
      var s0, s1;

      var key    = peg$currPos * 204 + 61,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsefunctionBody();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c137(s1);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecatchClause() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 204 + 62,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseTERMINATOR();
      if (s1 === peg$FAILED) {
        s1 = peg$c1;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseCATCH();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAssignable();
              if (s5 === peg$FAILED) {
                s5 = peg$c1;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseconditionalBody();
                if (s6 === peg$FAILED) {
                  s6 = peg$c1;
                }
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c144(s5, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsefinallyClause() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 63,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseTERMINATOR();
      if (s1 === peg$FAILED) {
        s1 = peg$c1;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseFINALLY();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsetryBody();
            if (s4 === peg$FAILED) {
              s4 = peg$c1;
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c145(s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseclass() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 204 + 64,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseCLASS();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseAssignable();
          if (s4 !== peg$FAILED) {
            peg$reportedPos = s2;
            s3 = peg$c15(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c1;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseEXTENDS();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsesecondaryExpressionNoImplicitObjectCall();
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s3;
                  s4 = peg$c9(s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseclassBody();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c146(s2, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseclassBody() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 65,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseTERMINDENT();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseclassBlock();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseDEDENT();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c140(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseTHEN();
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseclassStatement();
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c4(s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseTHEN();
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$c1;
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseclassBlock() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 204 + 66,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseclassStatement();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseTERMINATOR();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseclassStatement();
              if (s7 !== peg$FAILED) {
                peg$reportedPos = s3;
                s4 = peg$c4(s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseTERMINATOR();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseclassStatement();
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s3;
                  s4 = peg$c4(s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseTERMINATOR();
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c5(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseclassStatement() {
      var s0;

      var key    = peg$currPos * 204 + 67,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parseconstructor();
      if (s0 === peg$FAILED) {
        s0 = peg$parseclassProtoAssignment();
        if (s0 === peg$FAILED) {
          s0 = peg$parsestaticAssignment();
          if (s0 === peg$FAILED) {
            s0 = peg$parseexpression();
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseconstructor() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      var key    = peg$currPos * 204 + 68,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseObjectInitialiserKeys();
      if (s2 !== peg$FAILED) {
        peg$reportedPos = peg$currPos;
        s3 = peg$c147(s2);
        if (s3) {
          s3 = peg$c6;
        } else {
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s3 = peg$c148;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c149); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = peg$parseTERMINDENT();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseexpression();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseDEDENT();
                  if (s8 !== peg$FAILED) {
                    peg$reportedPos = s5;
                    s6 = peg$c9(s7);
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
              if (s5 === peg$FAILED) {
                s5 = peg$currPos;
                s6 = peg$parseTERMINATOR();
                if (s6 === peg$FAILED) {
                  s6 = peg$c1;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseexpression();
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s5;
                      s6 = peg$c9(s8);
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c0;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c150(s2, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsestaticAssignment() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      var key    = peg$currPos * 204 + 69,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsecontextVar();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s3 = peg$c148;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c149); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = peg$parseTERMINDENT();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseexpression();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseDEDENT();
                  if (s8 !== peg$FAILED) {
                    peg$reportedPos = s5;
                    s6 = peg$c151(s7);
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
              if (s5 === peg$FAILED) {
                s5 = peg$currPos;
                s6 = peg$parseTERMINATOR();
                if (s6 === peg$FAILED) {
                  s6 = peg$c1;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseexpression();
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s5;
                      s6 = peg$c151(s8);
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c0;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c152(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseclassProtoAssignment() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      var key    = peg$currPos * 204 + 70,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseObjectInitialiserKeys();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s3 = peg$c148;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c149); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = peg$parseTERMINDENT();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseexpression();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseDEDENT();
                  if (s8 !== peg$FAILED) {
                    peg$reportedPos = s5;
                    s6 = peg$c151(s7);
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
              if (s5 === peg$FAILED) {
                s5 = peg$currPos;
                s6 = peg$parsesingleLineImplicitObjectLiteral();
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s5;
                  s6 = peg$c151(s6);
                }
                s5 = s6;
                if (s5 === peg$FAILED) {
                  s5 = peg$currPos;
                  s6 = peg$parseTERMINATOR();
                  if (s6 === peg$FAILED) {
                    s6 = peg$c1;
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parse_();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parsesecondaryExpression();
                      if (s8 !== peg$FAILED) {
                        peg$reportedPos = s5;
                        s6 = peg$c151(s8);
                        s5 = s6;
                      } else {
                        peg$currPos = s5;
                        s5 = peg$c0;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$c0;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c153(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseforOf() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15;

      var key    = peg$currPos * 204 + 71,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseFOR();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseOWN();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseAssignable();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                  s7 = peg$c13;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c14); }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseAssignable();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        peg$reportedPos = s6;
                        s7 = peg$c15(s9);
                        s6 = s7;
                      } else {
                        peg$currPos = s6;
                        s6 = peg$c0;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c0;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c0;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$c0;
                }
                if (s6 === peg$FAILED) {
                  s6 = peg$c1;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseOF();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parse_();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseassignmentExpressionNoImplicitObjectCall();
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parse_();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$currPos;
                          s12 = peg$parseWHEN();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parse_();
                            if (s13 !== peg$FAILED) {
                              s14 = peg$parseassignmentExpressionNoImplicitObjectCall();
                              if (s14 !== peg$FAILED) {
                                s15 = peg$parse_();
                                if (s15 !== peg$FAILED) {
                                  peg$reportedPos = s11;
                                  s12 = peg$c9(s14);
                                  s11 = s12;
                                } else {
                                  peg$currPos = s11;
                                  s11 = peg$c0;
                                }
                              } else {
                                peg$currPos = s11;
                                s11 = peg$c0;
                              }
                            } else {
                              peg$currPos = s11;
                              s11 = peg$c0;
                            }
                          } else {
                            peg$currPos = s11;
                            s11 = peg$c0;
                          }
                          if (s11 === peg$FAILED) {
                            s11 = peg$c1;
                          }
                          if (s11 !== peg$FAILED) {
                            s12 = peg$parseconditionalBody();
                            if (s12 !== peg$FAILED) {
                              peg$reportedPos = s0;
                              s1 = peg$c154(s3, s4, s6, s9, s11, s12);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseforIn() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

      var key    = peg$currPos * 204 + 72,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseFOR();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parseAssignable();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 44) {
                s7 = peg$c13;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c14); }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parseAssignable();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parse_();
                    if (s10 !== peg$FAILED) {
                      peg$reportedPos = s6;
                      s7 = peg$c15(s9);
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c0;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c0;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$c0;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$c0;
              }
              if (s6 === peg$FAILED) {
                s6 = peg$c1;
              }
              if (s6 !== peg$FAILED) {
                peg$reportedPos = s3;
                s4 = peg$c16(s4, s6);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseIN();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseassignmentExpressionNoImplicitObjectCall();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$currPos;
                    s9 = peg$parseBY();
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parseassignmentExpressionNoImplicitObjectCall();
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_();
                          if (s12 !== peg$FAILED) {
                            peg$reportedPos = s8;
                            s9 = peg$c9(s11);
                            s8 = s9;
                          } else {
                            peg$currPos = s8;
                            s8 = peg$c0;
                          }
                        } else {
                          peg$currPos = s8;
                          s8 = peg$c0;
                        }
                      } else {
                        peg$currPos = s8;
                        s8 = peg$c0;
                      }
                    } else {
                      peg$currPos = s8;
                      s8 = peg$c0;
                    }
                    if (s8 === peg$FAILED) {
                      s8 = peg$c1;
                    }
                    if (s8 !== peg$FAILED) {
                      s9 = peg$currPos;
                      s10 = peg$parseWHEN();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parse_();
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parseassignmentExpressionNoImplicitObjectCall();
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parse_();
                            if (s13 !== peg$FAILED) {
                              peg$reportedPos = s9;
                              s10 = peg$c9(s12);
                              s9 = s10;
                            } else {
                              peg$currPos = s9;
                              s9 = peg$c0;
                            }
                          } else {
                            peg$currPos = s9;
                            s9 = peg$c0;
                          }
                        } else {
                          peg$currPos = s9;
                          s9 = peg$c0;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$c0;
                      }
                      if (s9 === peg$FAILED) {
                        s9 = peg$c1;
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseconditionalBody();
                        if (s10 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c155(s3, s6, s8, s9, s10);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseswitch() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 73,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseSWITCH();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseexpressionworthy();
          if (s3 === peg$FAILED) {
            s3 = peg$parseassignmentExpression();
          }
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseswitchBody();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c156(s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseswitchBody() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 74,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseTERMINDENT();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseswitchBlock();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseDEDENT();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c157(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseTHEN();
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              s4 = peg$parsecase();
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c158(s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseTHEN();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c159();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseswitchBlock() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 204 + 75,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsecase();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseTERMINATOR();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsecase();
              if (s7 !== peg$FAILED) {
                peg$reportedPos = s3;
                s4 = peg$c160(s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseTERMINATOR();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsecase();
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s3;
                  s4 = peg$c160(s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseTERMINATOR();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseelseClause();
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s3;
                  s4 = peg$c9(s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseTERMINATOR();
            if (s4 === peg$FAILED) {
              s4 = peg$c1;
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c161(s1, s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecase() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 76,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseWHEN();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecaseConditions();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseconditionalBody();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c162(s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecaseConditions() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 204 + 77,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseassignmentExpressionNoImplicitObjectCall();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c13;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c14); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseassignmentExpressionNoImplicitObjectCall();
              if (s7 !== peg$FAILED) {
                peg$reportedPos = s3;
                s4 = peg$c160(s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c13;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c14); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseassignmentExpressionNoImplicitObjectCall();
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s3;
                  s4 = peg$c160(s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c163(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsefunctionLiteral() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      var key    = peg$currPos * 204 + 78,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c76;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c77); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$currPos;
          s5 = peg$parseTERMINDENT();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseparameterList();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseDEDENT();
              if (s7 !== peg$FAILED) {
                s8 = peg$parseTERMINATOR();
                if (s8 !== peg$FAILED) {
                  peg$reportedPos = s4;
                  s5 = peg$c164(s6);
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$c0;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$c0;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          if (s4 === peg$FAILED) {
            s4 = peg$parseparameterList();
          }
          if (s4 === peg$FAILED) {
            s4 = peg$c1;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s6 = peg$c78;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c79); }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s1;
                  s2 = peg$c164(s4);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$c0;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c0;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c0;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c0;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$c1;
      }
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c165) {
          s2 = peg$c165;
          peg$currPos += 2;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c166); }
        }
        if (s2 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c167) {
            s2 = peg$c167;
            peg$currPos += 2;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c168); }
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsefunctionBody();
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c169(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsefunctionBody() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 79,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseTERMINDENT();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseblock();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseDEDENT();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c140(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsestatement();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c4(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseparameter() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 80,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseAssignable();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c19;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c20); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsesecondaryExpression();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c170(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parserest();
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parserest() {
      var s0, s1, s2;

      var key    = peg$currPos * 204 + 81,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseAssignable();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c133) {
          s2 = peg$c133;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c134); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c1;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c171(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseparameterList() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 204 + 82,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseparameter();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s5 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s6 = peg$c13;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c14); }
          }
          if (s6 !== peg$FAILED) {
            s7 = peg$parseTERMINATOR();
            if (s7 === peg$FAILED) {
              s7 = peg$c1;
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$c0;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$c0;
          }
          if (s5 === peg$FAILED) {
            s5 = peg$parseTERMINATOR();
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseparameter();
              if (s7 !== peg$FAILED) {
                peg$reportedPos = s3;
                s4 = peg$c9(s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s6 = peg$c13;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c14); }
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parseTERMINATOR();
              if (s7 === peg$FAILED) {
                s7 = peg$c1;
              }
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$c0;
            }
            if (s5 === peg$FAILED) {
              s5 = peg$parseTERMINATOR();
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseparameter();
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s3;
                  s4 = peg$c9(s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c81(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parserange() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      var key    = peg$currPos * 204 + 83,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c100;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c101); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsesecondaryExpression();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c120) {
                s5 = peg$c120;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c121); }
              }
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s6 = peg$c94;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c95); }
                }
                if (s6 === peg$FAILED) {
                  s6 = peg$c1;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsesecondaryExpression();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parse_();
                      if (s9 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 93) {
                          s10 = peg$c102;
                          peg$currPos++;
                        } else {
                          s10 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c103); }
                        }
                        if (s10 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c172(s3, s6, s8);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsearrayLiteral() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 84,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c100;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c101); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsearrayLiteralBody();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseTERMINATOR();
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s5 = peg$c102;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c103); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c173(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsearrayLiteralBody() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 85,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseTERMINDENT();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsearrayLiteralMemberList();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDEDENT();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c174(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsearrayLiteralMemberList();
          if (s2 === peg$FAILED) {
            s2 = peg$c1;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c175(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsearrayLiteralMemberList() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      var key    = peg$currPos * 204 + 86,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsearrayLiteralMember();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          s5 = peg$parsearrayLiteralMemberSeparator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsearrayLiteralMember();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  peg$reportedPos = s4;
                  s5 = peg$c9(s7);
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$c0;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$c0;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            s5 = peg$parsearrayLiteralMemberSeparator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsearrayLiteralMember();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    peg$reportedPos = s4;
                    s5 = peg$c9(s7);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$c0;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$c0;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$c0;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsearrayLiteralMemberSeparator();
            if (s4 === peg$FAILED) {
              s4 = peg$c1;
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c81(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsearrayLiteralMember() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 87,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsespread();
      if (s0 === peg$FAILED) {
        s0 = peg$parseexpression();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseTERMINDENT();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseimplicitObjectLiteral();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDEDENT();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c62(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsearrayLiteralMemberSeparator() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 88,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseTERMINATOR();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s4 = peg$c13;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c14); }
          }
          if (s4 === peg$FAILED) {
            s4 = peg$c1;
          }
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$c0;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c13;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c14); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseTERMINATOR();
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s2 = [s2, s3, s4];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$c0;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c0;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
        if (s1 !== peg$FAILED) {
          s1 = input.substring(s0, peg$currPos);
        }
        s0 = s1;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseobjectLiteral() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 89,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c176;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c177); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseobjectLiteralBody();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseTERMINATOR();
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s5 = peg$c178;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c179); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c180(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseobjectLiteralBody() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 90,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseTERMINDENT();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseobjectLiteralMemberList();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDEDENT();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c174(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseobjectLiteralMemberList();
          if (s2 === peg$FAILED) {
            s2 = peg$c1;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c175(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseobjectLiteralMemberList() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      var key    = peg$currPos * 204 + 91,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseobjectLiteralMember();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          s5 = peg$parsearrayLiteralMemberSeparator();
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseobjectLiteralMember();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  peg$reportedPos = s4;
                  s5 = peg$c9(s7);
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$c0;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$c0;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            s5 = peg$parsearrayLiteralMemberSeparator();
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseobjectLiteralMember();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    peg$reportedPos = s4;
                    s5 = peg$c9(s7);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$c0;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$c0;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$c0;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s4 = peg$c13;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c14); }
            }
            if (s4 === peg$FAILED) {
              s4 = peg$c1;
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c81(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseobjectLiteralMember() {
      var s0, s1;

      var key    = peg$currPos * 204 + 92,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parseimplicitObjectLiteralMember();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsecontextVar();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c181(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseObjectInitialiserKeys();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c182(s1);
          }
          s0 = s1;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseObjectInitialiserKeys() {
      var s0, s1;

      var key    = peg$currPos * 204 + 93,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseidentifierName();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c183(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$parsestring();
        if (s0 === peg$FAILED) {
          s0 = peg$parseNumbers();
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseimplicitObjectLiteral() {
      var s0, s1;

      var key    = peg$currPos * 204 + 94,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseimplicitObjectLiteralMemberList();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c180(s1);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseimplicitObjectLiteralMemberList() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 95,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseimplicitObjectLiteralMember();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseimplicitObjectLiteralMemberSeparator();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseimplicitObjectLiteralMember();
          if (s5 !== peg$FAILED) {
            peg$reportedPos = s3;
            s4 = peg$c9(s5);
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseimplicitObjectLiteralMemberSeparator();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseimplicitObjectLiteralMember();
            if (s5 !== peg$FAILED) {
              peg$reportedPos = s3;
              s4 = peg$c9(s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c81(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseimplicitObjectLiteralMemberSeparator() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 96,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseTERMINATOR();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c13;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c14); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c1;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s2 = peg$c13;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c14); }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseTERMINATOR();
            if (s3 === peg$FAILED) {
              s3 = peg$c1;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parse_();
              if (s4 !== peg$FAILED) {
                s1 = [s1, s2, s3, s4];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseimplicitObjectLiteralMember() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 97,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseObjectInitialiserKeys();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s3 = peg$c148;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c149); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseimplicitObjectLiteralMemberValue();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c184(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseimplicitObjectLiteralMemberValue() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 98,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsesingleLineImplicitObjectLiteral();
      if (s0 === peg$FAILED) {
        s0 = peg$parseexpression();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseTERMINDENT();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseexpression();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDEDENT();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c62(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesingleLineImplicitObjectLiteral() {
      var s0, s1;

      var key    = peg$currPos * 204 + 99,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsesingleLineImplicitObjectLiteralMemberList();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c180(s1);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesingleLineImplicitObjectLiteralMemberList() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 100,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseimplicitObjectLiteralMember();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parsesingleLineImplicitObjectLiteralMemberSeparator();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseimplicitObjectLiteralMember();
          if (s5 !== peg$FAILED) {
            peg$reportedPos = s3;
            s4 = peg$c9(s5);
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parsesingleLineImplicitObjectLiteralMemberSeparator();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseimplicitObjectLiteralMember();
            if (s5 !== peg$FAILED) {
              peg$reportedPos = s3;
              s4 = peg$c9(s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c81(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesingleLineImplicitObjectLiteralMemberSeparator() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 101,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c13;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c14); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsemacro() {
      var s0, s1;

      var key    = peg$currPos * 204 + 102,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 8) === peg$c185) {
        s1 = peg$c185;
        peg$currPos += 8;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c186); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c187();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 12) === peg$c188) {
          s1 = peg$c188;
          peg$currPos += 12;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c189); }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c190();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 8) === peg$c191) {
            s1 = peg$c191;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c192); }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c193();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 8) === peg$c194) {
              s1 = peg$c194;
              peg$currPos += 8;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c195); }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c196();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 14) === peg$c197) {
                s1 = peg$c197;
                peg$currPos += 14;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c198); }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c199();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 18) === peg$c200) {
                  s1 = peg$c200;
                  peg$currPos += 18;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c201); }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c202();
                }
                s0 = s1;
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsebool() {
      var s0, s1;

      var key    = peg$currPos * 204 + 103,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseTRUE();
      if (s1 === peg$FAILED) {
        s1 = peg$parseYES();
        if (s1 === peg$FAILED) {
          s1 = peg$parseON();
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c203();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseFALSE();
        if (s1 === peg$FAILED) {
          s1 = peg$parseNO();
          if (s1 === peg$FAILED) {
            s1 = peg$parseOFF();
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c204();
        }
        s0 = s1;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseNumbers() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 104,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c205) {
        s1 = peg$c205;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c206); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = [];
        s4 = peg$parsebit();
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsebit();
          }
        } else {
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s3 = input.substring(s2, peg$currPos);
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c207(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c208) {
          s1 = peg$c208;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c209); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];
          s4 = peg$parseoctalDigit();
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseoctalDigit();
            }
          } else {
            s3 = peg$c0;
          }
          if (s3 !== peg$FAILED) {
            s3 = input.substring(s2, peg$currPos);
          }
          s2 = s3;
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c210(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c211) {
            s1 = peg$c211;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c212); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = [];
            s4 = peg$parsehexDigit();
            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parsehexDigit();
              }
            } else {
              s3 = peg$c0;
            }
            if (s3 !== peg$FAILED) {
              s3 = input.substring(s2, peg$currPos);
            }
            s2 = s3;
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c213(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedecimal();
            if (s1 !== peg$FAILED) {
              if (peg$c214.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c215); }
              }
              if (s2 !== peg$FAILED) {
                if (peg$c216.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c217); }
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$c1;
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parsedecimal();
                  if (s4 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c218(s1, s2, s3, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$parsedecimal();
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsedecimal() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 204 + 105,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseinteger();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 46) {
          s4 = peg$c94;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c95); }
        }
        if (s4 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parsedecimalDigit();
          if (s6 !== peg$FAILED) {
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsedecimalDigit();
            }
          } else {
            s5 = peg$c0;
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 === peg$FAILED) {
          s3 = peg$c1;
        }
        if (s3 !== peg$FAILED) {
          s3 = input.substring(s2, peg$currPos);
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c219(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseinteger() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 106,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (input.charCodeAt(peg$currPos) === 48) {
        s0 = peg$c220;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c221); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (peg$c222.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c223); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsedecimalDigit();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsedecimalDigit();
          }
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$c0;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
        if (s1 !== peg$FAILED) {
          s1 = input.substring(s0, peg$currPos);
        }
        s0 = s1;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsedecimalDigit() {
      var s0;

      var key    = peg$currPos * 204 + 107,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c224.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c225); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsehexDigit() {
      var s0;

      var key    = peg$currPos * 204 + 108,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c226.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c227); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseoctalDigit() {
      var s0;

      var key    = peg$currPos * 204 + 109,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c228.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c229); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsebit() {
      var s0;

      var key    = peg$currPos * 204 + 110,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c230.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c231); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsestring() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      var key    = peg$currPos * 204 + 111,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c232) {
        s1 = peg$c232;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c233); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsestringData();
        if (s3 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c234;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c235); }
          }
          if (s3 === peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 34) {
              s5 = peg$c236;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c237); }
            }
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s6 = peg$c236;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c237); }
              }
              if (s6 === peg$FAILED) {
                s6 = peg$c1;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 34) {
                  s8 = peg$c236;
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c237); }
                }
                peg$silentFails--;
                if (s8 === peg$FAILED) {
                  s7 = peg$c6;
                } else {
                  peg$currPos = s7;
                  s7 = peg$c0;
                }
                if (s7 !== peg$FAILED) {
                  s5 = [s5, s6, s7];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$c0;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$c0;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
            if (s4 !== peg$FAILED) {
              s4 = input.substring(s3, peg$currPos);
            }
            s3 = s4;
          }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsestringData();
            if (s3 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s3 = peg$c234;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c235); }
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 34) {
                  s5 = peg$c236;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c237); }
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 34) {
                    s6 = peg$c236;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c237); }
                  }
                  if (s6 === peg$FAILED) {
                    s6 = peg$c1;
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$currPos;
                    peg$silentFails++;
                    if (input.charCodeAt(peg$currPos) === 34) {
                      s8 = peg$c236;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c237); }
                    }
                    peg$silentFails--;
                    if (s8 === peg$FAILED) {
                      s7 = peg$c6;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$c0;
                    }
                    if (s7 !== peg$FAILED) {
                      s5 = [s5, s6, s7];
                      s4 = s5;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$c0;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$c0;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$c0;
                }
                if (s4 !== peg$FAILED) {
                  s4 = input.substring(s3, peg$currPos);
                }
                s3 = s4;
              }
            }
          }
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c232) {
            s3 = peg$c232;
            peg$currPos += 3;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c233); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c238(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c239) {
          s1 = peg$c239;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c240); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsestringData();
          if (s3 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c236;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c237); }
            }
            if (s3 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 35) {
                s3 = peg$c241;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c242); }
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 39) {
                  s5 = peg$c234;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c235); }
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 39) {
                    s6 = peg$c234;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c235); }
                  }
                  if (s6 === peg$FAILED) {
                    s6 = peg$c1;
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$currPos;
                    peg$silentFails++;
                    if (input.charCodeAt(peg$currPos) === 39) {
                      s8 = peg$c234;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c235); }
                    }
                    peg$silentFails--;
                    if (s8 === peg$FAILED) {
                      s7 = peg$c6;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$c0;
                    }
                    if (s7 !== peg$FAILED) {
                      s5 = [s5, s6, s7];
                      s4 = s5;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$c0;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$c0;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$c0;
                }
                if (s4 !== peg$FAILED) {
                  s4 = input.substring(s3, peg$currPos);
                }
                s3 = s4;
              }
            }
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsestringData();
              if (s3 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 34) {
                  s3 = peg$c236;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c237); }
                }
                if (s3 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 35) {
                    s3 = peg$c241;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c242); }
                  }
                  if (s3 === peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 39) {
                      s5 = peg$c234;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c235); }
                    }
                    if (s5 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 39) {
                        s6 = peg$c234;
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c235); }
                      }
                      if (s6 === peg$FAILED) {
                        s6 = peg$c1;
                      }
                      if (s6 !== peg$FAILED) {
                        s7 = peg$currPos;
                        peg$silentFails++;
                        if (input.charCodeAt(peg$currPos) === 39) {
                          s8 = peg$c234;
                          peg$currPos++;
                        } else {
                          s8 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c235); }
                        }
                        peg$silentFails--;
                        if (s8 === peg$FAILED) {
                          s7 = peg$c6;
                        } else {
                          peg$currPos = s7;
                          s7 = peg$c0;
                        }
                        if (s7 !== peg$FAILED) {
                          s5 = [s5, s6, s7];
                          s4 = s5;
                        } else {
                          peg$currPos = s4;
                          s4 = peg$c0;
                        }
                      } else {
                        peg$currPos = s4;
                        s4 = peg$c0;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$c0;
                    }
                    if (s4 !== peg$FAILED) {
                      s4 = input.substring(s3, peg$currPos);
                    }
                    s3 = s4;
                  }
                }
              }
            }
          } else {
            s2 = peg$c0;
          }
          if (s2 !== peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c239) {
              s3 = peg$c239;
              peg$currPos += 3;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c240); }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c238(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c236;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c237); }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsestringData();
            if (s3 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s3 = peg$c234;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c235); }
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsestringData();
              if (s3 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s3 = peg$c234;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c235); }
                }
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c236;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c237); }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c243(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 39) {
              s1 = peg$c234;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c235); }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsestringData();
              if (s3 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 34) {
                  s3 = peg$c236;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c237); }
                }
                if (s3 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 35) {
                    s3 = peg$c241;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c242); }
                  }
                }
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsestringData();
                if (s3 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 34) {
                    s3 = peg$c236;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c237); }
                  }
                  if (s3 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 35) {
                      s3 = peg$c241;
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c242); }
                    }
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s3 = peg$c234;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c235); }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c243(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsestringData() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 112,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c244.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c245); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseUnicodeEscapeSequence();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c246) {
            s1 = peg$c246;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c247); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$currPos;
            s4 = peg$parsehexDigit();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsehexDigit();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
            if (s3 !== peg$FAILED) {
              s3 = input.substring(s2, peg$currPos);
            }
            s2 = s3;
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c248(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c249) {
              s1 = peg$c249;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c250); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;
              s3 = peg$parsedecimalDigit();
              peg$silentFails--;
              if (s3 === peg$FAILED) {
                s2 = peg$c6;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c251();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c249) {
                s1 = peg$c249;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c250); }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                peg$silentFails++;
                s3 = peg$parsedecimalDigit();
                peg$silentFails--;
                if (s3 !== peg$FAILED) {
                  peg$currPos = s2;
                  s2 = peg$c6;
                } else {
                  s2 = peg$c0;
                }
                if (s2 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c252();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c253) {
                  s1 = peg$c253;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c254); }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c255();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c256) {
                    s1 = peg$c256;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c257); }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c258();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c259) {
                      s1 = peg$c259;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c260); }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c261();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c262) {
                        s1 = peg$c262;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c263); }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c264();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c265) {
                          s1 = peg$c265;
                          peg$currPos += 2;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c266); }
                        }
                        if (s1 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c267();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          if (input.substr(peg$currPos, 2) === peg$c268) {
                            s1 = peg$c268;
                            peg$currPos += 2;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c269); }
                          }
                          if (s1 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c270();
                          }
                          s0 = s1;
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 92) {
                              s1 = peg$c271;
                              peg$currPos++;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c272); }
                            }
                            if (s1 !== peg$FAILED) {
                              if (input.length > peg$currPos) {
                                s2 = input.charAt(peg$currPos);
                                peg$currPos++;
                              } else {
                                s2 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c273); }
                              }
                              if (s2 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c160(s2);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                            if (s0 === peg$FAILED) {
                              s0 = peg$currPos;
                              if (input.charCodeAt(peg$currPos) === 35) {
                                s1 = peg$c241;
                                peg$currPos++;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c242); }
                              }
                              if (s1 !== peg$FAILED) {
                                s2 = peg$currPos;
                                peg$silentFails++;
                                if (input.charCodeAt(peg$currPos) === 123) {
                                  s3 = peg$c176;
                                  peg$currPos++;
                                } else {
                                  s3 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c177); }
                                }
                                peg$silentFails--;
                                if (s3 === peg$FAILED) {
                                  s2 = peg$c6;
                                } else {
                                  peg$currPos = s2;
                                  s2 = peg$c0;
                                }
                                if (s2 !== peg$FAILED) {
                                  peg$reportedPos = s0;
                                  s1 = peg$c160(s1);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$c0;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseinterpolation() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

      var key    = peg$currPos * 204 + 113,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c232) {
        s1 = peg$c232;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c233); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = [];
        s5 = peg$parsestringData();
        if (s5 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s5 = peg$c234;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c235); }
          }
          if (s5 === peg$FAILED) {
            s5 = peg$currPos;
            s6 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 34) {
              s7 = peg$c236;
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c237); }
            }
            if (s7 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s8 = peg$c236;
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c237); }
              }
              if (s8 === peg$FAILED) {
                s8 = peg$c1;
              }
              if (s8 !== peg$FAILED) {
                s9 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 34) {
                  s10 = peg$c236;
                  peg$currPos++;
                } else {
                  s10 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c237); }
                }
                peg$silentFails--;
                if (s10 === peg$FAILED) {
                  s9 = peg$c6;
                } else {
                  peg$currPos = s9;
                  s9 = peg$c0;
                }
                if (s9 !== peg$FAILED) {
                  s7 = [s7, s8, s9];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$c0;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$c0;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$c0;
            }
            if (s6 !== peg$FAILED) {
              s6 = input.substring(s5, peg$currPos);
            }
            s5 = s6;
          }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$parsestringData();
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s5 = peg$c234;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c235); }
              }
              if (s5 === peg$FAILED) {
                s5 = peg$currPos;
                s6 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 34) {
                  s7 = peg$c236;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c237); }
                }
                if (s7 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 34) {
                    s8 = peg$c236;
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c237); }
                  }
                  if (s8 === peg$FAILED) {
                    s8 = peg$c1;
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$currPos;
                    peg$silentFails++;
                    if (input.charCodeAt(peg$currPos) === 34) {
                      s10 = peg$c236;
                      peg$currPos++;
                    } else {
                      s10 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c237); }
                    }
                    peg$silentFails--;
                    if (s10 === peg$FAILED) {
                      s9 = peg$c6;
                    } else {
                      peg$currPos = s9;
                      s9 = peg$c0;
                    }
                    if (s9 !== peg$FAILED) {
                      s7 = [s7, s8, s9];
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c0;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c0;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$c0;
                }
                if (s6 !== peg$FAILED) {
                  s6 = input.substring(s5, peg$currPos);
                }
                s5 = s6;
              }
            }
          }
        } else {
          s4 = peg$c0;
        }
        if (s4 !== peg$FAILED) {
          peg$reportedPos = s3;
          s4 = peg$c243(s4);
        }
        s3 = s4;
        if (s3 === peg$FAILED) {
          s3 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c274) {
            s4 = peg$c274;
            peg$currPos += 2;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c275); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$parseexpression();
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 125) {
                    s8 = peg$c178;
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c179); }
                  }
                  if (s8 !== peg$FAILED) {
                    peg$reportedPos = s3;
                    s4 = peg$c9(s6);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c0;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parsestringData();
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s5 = peg$c234;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c235); }
              }
              if (s5 === peg$FAILED) {
                s5 = peg$currPos;
                s6 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 34) {
                  s7 = peg$c236;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c237); }
                }
                if (s7 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 34) {
                    s8 = peg$c236;
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c237); }
                  }
                  if (s8 === peg$FAILED) {
                    s8 = peg$c1;
                  }
                  if (s8 !== peg$FAILED) {
                    s9 = peg$currPos;
                    peg$silentFails++;
                    if (input.charCodeAt(peg$currPos) === 34) {
                      s10 = peg$c236;
                      peg$currPos++;
                    } else {
                      s10 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c237); }
                    }
                    peg$silentFails--;
                    if (s10 === peg$FAILED) {
                      s9 = peg$c6;
                    } else {
                      peg$currPos = s9;
                      s9 = peg$c0;
                    }
                    if (s9 !== peg$FAILED) {
                      s7 = [s7, s8, s9];
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c0;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$c0;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$c0;
                }
                if (s6 !== peg$FAILED) {
                  s6 = input.substring(s5, peg$currPos);
                }
                s5 = s6;
              }
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parsestringData();
                if (s5 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 39) {
                    s5 = peg$c234;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c235); }
                  }
                  if (s5 === peg$FAILED) {
                    s5 = peg$currPos;
                    s6 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 34) {
                      s7 = peg$c236;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c237); }
                    }
                    if (s7 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 34) {
                        s8 = peg$c236;
                        peg$currPos++;
                      } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c237); }
                      }
                      if (s8 === peg$FAILED) {
                        s8 = peg$c1;
                      }
                      if (s8 !== peg$FAILED) {
                        s9 = peg$currPos;
                        peg$silentFails++;
                        if (input.charCodeAt(peg$currPos) === 34) {
                          s10 = peg$c236;
                          peg$currPos++;
                        } else {
                          s10 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c237); }
                        }
                        peg$silentFails--;
                        if (s10 === peg$FAILED) {
                          s9 = peg$c6;
                        } else {
                          peg$currPos = s9;
                          s9 = peg$c0;
                        }
                        if (s9 !== peg$FAILED) {
                          s7 = [s7, s8, s9];
                          s6 = s7;
                        } else {
                          peg$currPos = s6;
                          s6 = peg$c0;
                        }
                      } else {
                        peg$currPos = s6;
                        s6 = peg$c0;
                      }
                    } else {
                      peg$currPos = s6;
                      s6 = peg$c0;
                    }
                    if (s6 !== peg$FAILED) {
                      s6 = input.substring(s5, peg$currPos);
                    }
                    s5 = s6;
                  }
                }
              }
            } else {
              s4 = peg$c0;
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s3;
              s4 = peg$c243(s4);
            }
            s3 = s4;
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c274) {
                s4 = peg$c274;
                peg$currPos += 2;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c275); }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseexpression();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parse_();
                    if (s7 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 125) {
                        s8 = peg$c178;
                        peg$currPos++;
                      } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c179); }
                      }
                      if (s8 !== peg$FAILED) {
                        peg$reportedPos = s3;
                        s4 = peg$c9(s6);
                        s3 = s4;
                      } else {
                        peg$currPos = s3;
                        s3 = peg$c0;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$c0;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c0;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            }
          }
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c232) {
            s3 = peg$c232;
            peg$currPos += 3;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c233); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c276(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c236;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c237); }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = [];
          s5 = peg$parsestringData();
          if (s5 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s5 = peg$c234;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c235); }
            }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parsestringData();
              if (s5 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s5 = peg$c234;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c235); }
                }
              }
            }
          } else {
            s4 = peg$c0;
          }
          if (s4 !== peg$FAILED) {
            peg$reportedPos = s3;
            s4 = peg$c243(s4);
          }
          s3 = s4;
          if (s3 === peg$FAILED) {
            s3 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c274) {
              s4 = peg$c274;
              peg$currPos += 2;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c275); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseexpression();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s8 = peg$c178;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c179); }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s3;
                      s4 = peg$c9(s6);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$c0;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c0;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = [];
              s5 = peg$parsestringData();
              if (s5 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s5 = peg$c234;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c235); }
                }
              }
              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parsestringData();
                  if (s5 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 39) {
                      s5 = peg$c234;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c235); }
                    }
                  }
                }
              } else {
                s4 = peg$c0;
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s3;
                s4 = peg$c243(s4);
              }
              s3 = s4;
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c274) {
                  s4 = peg$c274;
                  peg$currPos += 2;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c275); }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseexpression();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parse_();
                      if (s7 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 125) {
                          s8 = peg$c178;
                          peg$currPos++;
                        } else {
                          s8 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c179); }
                        }
                        if (s8 !== peg$FAILED) {
                          peg$reportedPos = s3;
                          s4 = peg$c9(s6);
                          s3 = s4;
                        } else {
                          peg$currPos = s3;
                          s3 = peg$c0;
                        }
                      } else {
                        peg$currPos = s3;
                        s3 = peg$c0;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$c0;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c0;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              }
            }
          } else {
            s2 = peg$c0;
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c236;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c237); }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c277(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseregexp() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 204 + 114,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c278) {
        s1 = peg$c278;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c279); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = [];
        if (peg$c280.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c281); }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            if (peg$c280.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c281); }
            }
          }
        } else {
          s4 = peg$c0;
        }
        if (s4 !== peg$FAILED) {
          peg$reportedPos = s3;
          s4 = peg$c282();
        }
        s3 = s4;
        if (s3 === peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$currPos;
          s5 = [];
          if (peg$c283.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c284); }
          }
          if (s6 !== peg$FAILED) {
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              if (peg$c283.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c284); }
              }
            }
          } else {
            s5 = peg$c0;
          }
          if (s5 !== peg$FAILED) {
            s5 = input.substring(s4, peg$currPos);
          }
          s4 = s5;
          if (s4 !== peg$FAILED) {
            peg$reportedPos = s3;
            s4 = peg$c285(s4);
          }
          s3 = s4;
          if (s3 === peg$FAILED) {
            s3 = peg$parsehereregexpData();
          }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = [];
            if (peg$c280.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c281); }
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                if (peg$c280.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c281); }
                }
              }
            } else {
              s4 = peg$c0;
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s3;
              s4 = peg$c282();
            }
            s3 = s4;
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$currPos;
              s5 = [];
              if (peg$c283.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c284); }
              }
              if (s6 !== peg$FAILED) {
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  if (peg$c283.test(input.charAt(peg$currPos))) {
                    s6 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c284); }
                  }
                }
              } else {
                s5 = peg$c0;
              }
              if (s5 !== peg$FAILED) {
                s5 = input.substring(s4, peg$currPos);
              }
              s4 = s5;
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s3;
                s4 = peg$c285(s4);
              }
              s3 = s4;
              if (s3 === peg$FAILED) {
                s3 = peg$parsehereregexpData();
              }
            }
          }
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c278) {
            s3 = peg$c278;
            peg$currPos += 3;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c279); }
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            if (peg$c286.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c287); }
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$c286.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c287); }
              }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c288(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c289;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c290); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];
          s4 = peg$parseregexpData();
          if (s4 === peg$FAILED) {
            s4 = [];
            if (peg$c291.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c292); }
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                if (peg$c291.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c292); }
                }
              }
            } else {
              s4 = peg$c0;
            }
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseregexpData();
            if (s4 === peg$FAILED) {
              s4 = [];
              if (peg$c291.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c292); }
              }
              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  if (peg$c291.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c292); }
                  }
                }
              } else {
                s4 = peg$c0;
              }
            }
          }
          if (s3 !== peg$FAILED) {
            s3 = input.substring(s2, peg$currPos);
          }
          s2 = s3;
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s3 = peg$c289;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c290); }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              if (peg$c286.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c287); }
              }
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                if (peg$c286.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c287); }
                }
              }
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c293(s2, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseregexpData() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 115,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c100;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c101); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c294.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c295); }
        }
        if (s3 === peg$FAILED) {
          s3 = peg$parseregexpData();
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c294.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c295); }
          }
          if (s3 === peg$FAILED) {
            s3 = peg$parseregexpData();
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s3 = peg$c102;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c103); }
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c271;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c272); }
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c273); }
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsehereregexpData() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 204 + 116,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c100;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c101); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parsehereregexpData();
        if (s4 !== peg$FAILED) {
          peg$reportedPos = s3;
          s4 = peg$c296(s4);
        }
        s3 = s4;
        if (s3 === peg$FAILED) {
          s3 = peg$currPos;
          if (peg$c297.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c298); }
          }
          if (s4 !== peg$FAILED) {
            peg$reportedPos = s3;
            s4 = peg$c299(s4);
          }
          s3 = s4;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parsehereregexpData();
          if (s4 !== peg$FAILED) {
            peg$reportedPos = s3;
            s4 = peg$c296(s4);
          }
          s3 = s4;
          if (s3 === peg$FAILED) {
            s3 = peg$currPos;
            if (peg$c297.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c298); }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s3;
              s4 = peg$c299(s4);
            }
            s3 = s4;
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 93) {
            s3 = peg$c102;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c103); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c300(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s3 = peg$c271;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c272); }
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c273); }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s2 = input.substring(s1, peg$currPos);
        }
        s1 = s2;
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c301(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s3 = peg$c289;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c290); }
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s4 = peg$c289;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c290); }
            }
            if (s4 === peg$FAILED) {
              s4 = peg$c1;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 47) {
                s6 = peg$c289;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c290); }
              }
              peg$silentFails--;
              if (s6 === peg$FAILED) {
                s5 = peg$c6;
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
              if (s5 !== peg$FAILED) {
                s3 = [s3, s4, s5];
                s2 = s3;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
          if (s2 !== peg$FAILED) {
            s2 = input.substring(s1, peg$currPos);
          }
          s1 = s2;
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c302(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 35) {
              s1 = peg$c241;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c242); }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 123) {
                s3 = peg$c176;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c177); }
              }
              peg$silentFails--;
              if (s3 === peg$FAILED) {
                s2 = peg$c6;
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c303(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c274) {
                s1 = peg$c274;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c275); }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parseexpression();
                  if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 125) {
                        s5 = peg$c178;
                        peg$currPos++;
                      } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c179); }
                      }
                      if (s5 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c304(s3);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsethrow() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 117,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseTHROW();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsesecondaryExpression();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c305(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsereturn() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 118,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseRETURN();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsesecondaryExpression();
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c306(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecontinue() {
      var s0, s1;

      var key    = peg$currPos * 204 + 119,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseCONTINUE();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c307();
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsebreak() {
      var s0, s1;

      var key    = peg$currPos * 204 + 120,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseBREAK();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c308();
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsedebugger() {
      var s0, s1;

      var key    = peg$currPos * 204 + 121,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseDEBUGGER();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c309();
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseundefined() {
      var s0, s1;

      var key    = peg$currPos * 204 + 122,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseUNDEFINED();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c310();
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenull() {
      var s0, s1;

      var key    = peg$currPos * 204 + 123,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseNULL();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c311();
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseunassignable() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 124,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 9) === peg$c312) {
        s1 = peg$c312;
        peg$currPos += 9;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c313); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 4) === peg$c314) {
          s1 = peg$c314;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c315); }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c6;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseCompoundAssignable() {
      var s0, s1, s2;

      var key    = peg$currPos * 204 + 125,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsememberAccess();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parseunassignable();
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = peg$c6;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseidentifier();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c316(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseAssignable() {
      var s0, s1, s2;

      var key    = peg$currPos * 204 + 126,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsememberAccess();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parseunassignable();
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = peg$c6;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseidentifier();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c316(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parsepositionalDestructuring();
          if (s0 === peg$FAILED) {
            s0 = peg$parsenamedDestructuring();
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsepositionalDestructuring() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 127,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c100;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c101); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsepositionalDestructuringBody();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseTERMINATOR();
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s5 = peg$c102;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c103); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c173(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsepositionalDestructuringBody() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 128,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseTERMINDENT();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsepositionalDestructuringMemberList();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDEDENT();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c174(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsepositionalDestructuringMemberList();
          if (s2 === peg$FAILED) {
            s2 = peg$c1;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c175(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsepositionalDestructuringMemberList() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 204 + 129,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsepositionalDestructuringMember();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c13;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c14); }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsepositionalDestructuringMember();
              if (s7 !== peg$FAILED) {
                peg$reportedPos = s3;
                s4 = peg$c9(s7);
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c13;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c14); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsepositionalDestructuringMember();
                if (s7 !== peg$FAILED) {
                  peg$reportedPos = s3;
                  s4 = peg$c9(s7);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c81(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsepositionalDestructuringMember() {
      var s0;

      var key    = peg$currPos * 204 + 130,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parserest();
      if (s0 === peg$FAILED) {
        s0 = peg$parseAssignable();
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenamedDestructuring() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 131,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c176;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c177); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenamedDestructuringBody();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseTERMINATOR();
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s5 = peg$c178;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c179); }
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c180(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenamedDestructuringBody() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 132,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseTERMINDENT();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenamedDestructuringMemberList();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseDEDENT();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c174(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsenamedDestructuringMemberList();
          if (s2 === peg$FAILED) {
            s2 = peg$c1;
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c175(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenamedDestructuringMemberList() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      var key    = peg$currPos * 204 + 133,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsenamedDestructuringMember();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseTERMINATOR();
        if (s4 === peg$FAILED) {
          s4 = peg$c1;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_();
          if (s5 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s6 = peg$c13;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c14); }
            }
            if (s6 === peg$FAILED) {
              s6 = peg$parseTERMINATOR();
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parseTERMINATOR();
              if (s7 === peg$FAILED) {
                s7 = peg$c1;
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parsenamedDestructuringMember();
                  if (s9 !== peg$FAILED) {
                    peg$reportedPos = s3;
                    s4 = peg$c9(s9);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c0;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseTERMINATOR();
          if (s4 === peg$FAILED) {
            s4 = peg$c1;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s6 = peg$c13;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c14); }
              }
              if (s6 === peg$FAILED) {
                s6 = peg$parseTERMINATOR();
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parseTERMINATOR();
                if (s7 === peg$FAILED) {
                  s7 = peg$c1;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsenamedDestructuringMember();
                    if (s9 !== peg$FAILED) {
                      peg$reportedPos = s3;
                      s4 = peg$c9(s9);
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$c0;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c0;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c0;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c81(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenamedDestructuringMember() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 134,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseObjectInitialiserKeys();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s3 = peg$c148;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c149); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseAssignable();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c184(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsecontextVar();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c317(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          s2 = peg$parseunassignable();
          peg$silentFails--;
          if (s2 === peg$FAILED) {
            s1 = peg$c6;
          } else {
            peg$currPos = s1;
            s1 = peg$c0;
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseidentifier();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c318(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseidentifier() {
      var s0, s1, s2;

      var key    = peg$currPos * 204 + 135,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      s2 = peg$parsereserved();
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = peg$c6;
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseidentifierName();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c183(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseidentifierName() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 136,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseidentifierStart();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parseidentifierPart();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parseidentifierPart();
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseidentifierStart() {
      var s0;

      var key    = peg$currPos * 204 + 137,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parseUnicodeLetter();
      if (s0 === peg$FAILED) {
        if (peg$c319.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c320); }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseUnicodeEscapeSequence();
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseidentifierPart() {
      var s0;

      var key    = peg$currPos * 204 + 138,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parseidentifierStart();
      if (s0 === peg$FAILED) {
        s0 = peg$parseUnicodeCombiningMark();
        if (s0 === peg$FAILED) {
          s0 = peg$parseUnicodeDigit();
          if (s0 === peg$FAILED) {
            s0 = peg$parseUnicodeConnectorPunctuation();
            if (s0 === peg$FAILED) {
              s0 = peg$parseZWNJ();
              if (s0 === peg$FAILED) {
                s0 = peg$parseZWJ();
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parse__() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 204 + 139,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      s3 = peg$parsewhitespace();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewhitespace();
        }
      } else {
        s2 = peg$c0;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = peg$parseblockComment();
        if (s4 !== peg$FAILED) {
          s5 = [];
          s6 = peg$parsewhitespace();
          if (s6 !== peg$FAILED) {
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsewhitespace();
            }
          } else {
            s5 = peg$c0;
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 === peg$FAILED) {
          s3 = peg$c1;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parse_() {
      var s0;

      var key    = peg$currPos * 204 + 140,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parse__();
      if (s0 === peg$FAILED) {
        s0 = peg$c1;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecomment() {
      var s0;

      var key    = peg$currPos * 204 + 141,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parseblockComment();
      if (s0 === peg$FAILED) {
        s0 = peg$parsesingleLineComment();
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesingleLineComment() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 204 + 142,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s2 = peg$c241;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c242); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$currPos;
        s5 = peg$currPos;
        peg$silentFails++;
        s6 = peg$parseTERM();
        peg$silentFails--;
        if (s6 === peg$FAILED) {
          s5 = peg$c6;
        } else {
          peg$currPos = s5;
          s5 = peg$c0;
        }
        if (s5 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c273); }
          }
          if (s6 !== peg$FAILED) {
            s5 = [s5, s6];
            s4 = s5;
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
        } else {
          peg$currPos = s4;
          s4 = peg$c0;
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$currPos;
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parseTERM();
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = peg$c6;
          } else {
            peg$currPos = s5;
            s5 = peg$c0;
          }
          if (s5 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c273); }
            }
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseblockComment() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      var key    = peg$currPos * 204 + 143,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c321) {
        s2 = peg$c321;
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c322); }
      }
      if (s2 !== peg$FAILED) {
        if (peg$c323.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c324); }
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          if (peg$c323.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c324); }
          }
          if (s5 === peg$FAILED) {
            s5 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 35) {
              s6 = peg$c241;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c242); }
            }
            if (s6 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 35) {
                s7 = peg$c241;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c242); }
              }
              if (s7 === peg$FAILED) {
                s7 = peg$c1;
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 35) {
                  s9 = peg$c241;
                  peg$currPos++;
                } else {
                  s9 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c242); }
                }
                peg$silentFails--;
                if (s9 === peg$FAILED) {
                  s8 = peg$c6;
                } else {
                  peg$currPos = s8;
                  s8 = peg$c0;
                }
                if (s8 !== peg$FAILED) {
                  s6 = [s6, s7, s8];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$c0;
            }
          }
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            if (peg$c323.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c324); }
            }
            if (s5 === peg$FAILED) {
              s5 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 35) {
                s6 = peg$c241;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c242); }
              }
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 35) {
                  s7 = peg$c241;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c242); }
                }
                if (s7 === peg$FAILED) {
                  s7 = peg$c1;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$currPos;
                  peg$silentFails++;
                  if (input.charCodeAt(peg$currPos) === 35) {
                    s9 = peg$c241;
                    peg$currPos++;
                  } else {
                    s9 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c242); }
                  }
                  peg$silentFails--;
                  if (s9 === peg$FAILED) {
                    s8 = peg$c6;
                  } else {
                    peg$currPos = s8;
                    s8 = peg$c0;
                  }
                  if (s8 !== peg$FAILED) {
                    s6 = [s6, s7, s8];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$c0;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
            }
          }
          if (s4 !== peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c321) {
              s5 = peg$c321;
              peg$currPos += 3;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c322); }
            }
            if (s5 !== peg$FAILED) {
              s2 = [s2, s3, s4, s5];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$c0;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c0;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewhitespace() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 144,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c325.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c326); }
      }
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 13) {
          s0 = peg$c327;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c328); }
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s2 = peg$c271;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c272); }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 13) {
              s3 = peg$c327;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c328); }
            }
            if (s3 === peg$FAILED) {
              s3 = peg$c1;
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s4 = peg$c329;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c330); }
              }
              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$c0;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c0;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$c0;
          }
          if (s1 !== peg$FAILED) {
            s1 = input.substring(s0, peg$currPos);
          }
          s0 = s1;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseINDENT() {
      var s0, s1, s2;

      var key    = peg$currPos * 204 + 145,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61423) {
          s2 = peg$c331;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c332); }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c333(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseDEDENT() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 146,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      s3 = peg$parseTERMINATOR();
      if (s3 === peg$FAILED) {
        s3 = peg$c1;
      }
      if (s3 !== peg$FAILED) {
        s4 = peg$parse_();
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c0;
      }
      if (s2 !== peg$FAILED) {
        s2 = input.substring(s1, peg$currPos);
      }
      s1 = s2;
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 61438) {
          s2 = peg$c334;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c335); }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c333(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseTERM() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 147,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 13) {
        s2 = peg$c327;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c328); }
      }
      if (s2 === peg$FAILED) {
        s2 = peg$c1;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 10) {
          s3 = peg$c329;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c330); }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 61439) {
          s1 = peg$c336;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c337); }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c338();
        }
        s0 = s1;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseTERMINATOR() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 204 + 148,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        s4 = peg$parsecomment();
        if (s4 === peg$FAILED) {
          s4 = peg$c1;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseTERM();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseblockComment();
            if (s6 === peg$FAILED) {
              s6 = peg$c1;
            }
            if (s6 !== peg$FAILED) {
              s3 = [s3, s4, s5, s6];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c0;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsecomment();
            if (s4 === peg$FAILED) {
              s4 = peg$c1;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseTERM();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseblockComment();
                if (s6 === peg$FAILED) {
                  s6 = peg$c1;
                }
                if (s6 !== peg$FAILED) {
                  s3 = [s3, s4, s5, s6];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$c0;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c0;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$c0;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseTERMINDENT() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 149,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseTERMINATOR();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseINDENT();
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseAND() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 150,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c339) {
        s2 = peg$c339;
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c340); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBREAK() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 151,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c341) {
        s2 = peg$c341;
        peg$currPos += 5;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c342); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBY() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 152,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c343) {
        s2 = peg$c343;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c344); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseCATCH() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 153,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c345) {
        s2 = peg$c345;
        peg$currPos += 5;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c346); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseCONTINUE() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 154,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 8) === peg$c347) {
        s2 = peg$c347;
        peg$currPos += 8;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c348); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseCLASS() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 155,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c349) {
        s2 = peg$c349;
        peg$currPos += 5;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c350); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseDELETE() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 156,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c351) {
        s2 = peg$c351;
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c352); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseDEBUGGER() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 157,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 8) === peg$c353) {
        s2 = peg$c353;
        peg$currPos += 8;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c354); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseDO() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 158,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c355) {
        s2 = peg$c355;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c356); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseELSE() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 159,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c357) {
        s2 = peg$c357;
        peg$currPos += 4;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c358); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEXTENDS() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 160,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 7) === peg$c359) {
        s2 = peg$c359;
        peg$currPos += 7;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c360); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseFALSE() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 161,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c361) {
        s2 = peg$c361;
        peg$currPos += 5;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c362); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseFINALLY() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 162,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 7) === peg$c363) {
        s2 = peg$c363;
        peg$currPos += 7;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c364); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseFOR() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 163,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c365) {
        s2 = peg$c365;
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c366); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseIF() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 164,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c367) {
        s2 = peg$c367;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c368); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseIN() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 165,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c369) {
        s2 = peg$c369;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c370); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseINSTANCEOF() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 166,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 10) === peg$c371) {
        s2 = peg$c371;
        peg$currPos += 10;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c372); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseIS() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 167,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c373) {
        s2 = peg$c373;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c374); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseISNT() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 168,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c375) {
        s2 = peg$c375;
        peg$currPos += 4;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c376); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseLOOP() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 169,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c377) {
        s2 = peg$c377;
        peg$currPos += 4;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c378); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseNEW() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 170,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c379) {
        s2 = peg$c379;
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c380); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseNO() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 171,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c381) {
        s2 = peg$c381;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c382); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseNOT() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 172,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c383) {
        s2 = peg$c383;
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c384); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseNULL() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 173,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c385) {
        s2 = peg$c385;
        peg$currPos += 4;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c386); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseOF() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 174,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c387) {
        s2 = peg$c387;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c388); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseOFF() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 175,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c389) {
        s2 = peg$c389;
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c390); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseON() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 176,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c391) {
        s2 = peg$c391;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c392); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseOR() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 177,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c393) {
        s2 = peg$c393;
        peg$currPos += 2;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c394); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseOWN() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 178,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c395) {
        s2 = peg$c395;
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c396); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseRETURN() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 179,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c397) {
        s2 = peg$c397;
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c398); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseSWITCH() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 180,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c399) {
        s2 = peg$c399;
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c400); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseTHEN() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 181,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c401) {
        s2 = peg$c401;
        peg$currPos += 4;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c402); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseTHIS() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 182,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c403) {
        s2 = peg$c403;
        peg$currPos += 4;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c404); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseTHROW() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 183,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c405) {
        s2 = peg$c405;
        peg$currPos += 5;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c406); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseTRUE() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 184,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c407) {
        s2 = peg$c407;
        peg$currPos += 4;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c408); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseTRY() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 185,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c409) {
        s2 = peg$c409;
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c410); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseTYPEOF() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 186,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c411) {
        s2 = peg$c411;
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c412); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseUNDEFINED() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 187,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 9) === peg$c413) {
        s2 = peg$c413;
        peg$currPos += 9;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c414); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseUNLESS() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 188,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c415) {
        s2 = peg$c415;
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c416); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseUNTIL() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 189,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c417) {
        s2 = peg$c417;
        peg$currPos += 5;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c418); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseWHEN() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 190,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c419) {
        s2 = peg$c419;
        peg$currPos += 4;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c420); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseWHILE() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 191,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c421) {
        s2 = peg$c421;
        peg$currPos += 5;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c422); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseYES() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 204 + 192,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c423) {
        s2 = peg$c423;
        peg$currPos += 3;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c424); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = peg$c6;
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseSharedKeywords() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 193,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c407) {
        s1 = peg$c407;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c408); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 5) === peg$c361) {
          s1 = peg$c361;
          peg$currPos += 5;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c362); }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c385) {
            s1 = peg$c385;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c386); }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c403) {
              s1 = peg$c403;
              peg$currPos += 4;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c404); }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c379) {
                s1 = peg$c379;
                peg$currPos += 3;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c380); }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c351) {
                  s1 = peg$c351;
                  peg$currPos += 6;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c352); }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 6) === peg$c411) {
                    s1 = peg$c411;
                    peg$currPos += 6;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c412); }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 10) === peg$c371) {
                      s1 = peg$c371;
                      peg$currPos += 10;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c372); }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 2) === peg$c369) {
                        s1 = peg$c369;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c370); }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 6) === peg$c397) {
                          s1 = peg$c397;
                          peg$currPos += 6;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c398); }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 5) === peg$c405) {
                            s1 = peg$c405;
                            peg$currPos += 5;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c406); }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 5) === peg$c341) {
                              s1 = peg$c341;
                              peg$currPos += 5;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c342); }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 8) === peg$c347) {
                                s1 = peg$c347;
                                peg$currPos += 8;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c348); }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 8) === peg$c353) {
                                  s1 = peg$c353;
                                  peg$currPos += 8;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c354); }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 2) === peg$c367) {
                                    s1 = peg$c367;
                                    peg$currPos += 2;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c368); }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 4) === peg$c357) {
                                      s1 = peg$c357;
                                      peg$currPos += 4;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$c358); }
                                    }
                                    if (s1 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 6) === peg$c399) {
                                        s1 = peg$c399;
                                        peg$currPos += 6;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) { peg$fail(peg$c400); }
                                      }
                                      if (s1 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 3) === peg$c365) {
                                          s1 = peg$c365;
                                          peg$currPos += 3;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) { peg$fail(peg$c366); }
                                        }
                                        if (s1 === peg$FAILED) {
                                          if (input.substr(peg$currPos, 5) === peg$c421) {
                                            s1 = peg$c421;
                                            peg$currPos += 5;
                                          } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) { peg$fail(peg$c422); }
                                          }
                                          if (s1 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 2) === peg$c355) {
                                              s1 = peg$c355;
                                              peg$currPos += 2;
                                            } else {
                                              s1 = peg$FAILED;
                                              if (peg$silentFails === 0) { peg$fail(peg$c356); }
                                            }
                                            if (s1 === peg$FAILED) {
                                              if (input.substr(peg$currPos, 3) === peg$c409) {
                                                s1 = peg$c409;
                                                peg$currPos += 3;
                                              } else {
                                                s1 = peg$FAILED;
                                                if (peg$silentFails === 0) { peg$fail(peg$c410); }
                                              }
                                              if (s1 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 5) === peg$c345) {
                                                  s1 = peg$c345;
                                                  peg$currPos += 5;
                                                } else {
                                                  s1 = peg$FAILED;
                                                  if (peg$silentFails === 0) { peg$fail(peg$c346); }
                                                }
                                                if (s1 === peg$FAILED) {
                                                  if (input.substr(peg$currPos, 7) === peg$c363) {
                                                    s1 = peg$c363;
                                                    peg$currPos += 7;
                                                  } else {
                                                    s1 = peg$FAILED;
                                                    if (peg$silentFails === 0) { peg$fail(peg$c364); }
                                                  }
                                                  if (s1 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 5) === peg$c349) {
                                                      s1 = peg$c349;
                                                      peg$currPos += 5;
                                                    } else {
                                                      s1 = peg$FAILED;
                                                      if (peg$silentFails === 0) { peg$fail(peg$c350); }
                                                    }
                                                    if (s1 === peg$FAILED) {
                                                      if (input.substr(peg$currPos, 7) === peg$c359) {
                                                        s1 = peg$c359;
                                                        peg$currPos += 7;
                                                      } else {
                                                        s1 = peg$FAILED;
                                                        if (peg$silentFails === 0) { peg$fail(peg$c360); }
                                                      }
                                                      if (s1 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 5) === peg$c425) {
                                                          s1 = peg$c425;
                                                          peg$currPos += 5;
                                                        } else {
                                                          s1 = peg$FAILED;
                                                          if (peg$silentFails === 0) { peg$fail(peg$c426); }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c6;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseJSKeywords() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 194,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c427) {
        s1 = peg$c427;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c428); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 7) === peg$c429) {
          s1 = peg$c429;
          peg$currPos += 7;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c430); }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c431) {
            s1 = peg$c431;
            peg$currPos += 8;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c432); }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c433) {
              s1 = peg$c433;
              peg$currPos += 3;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c434); }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c435) {
                s1 = peg$c435;
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c436); }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c437) {
                  s1 = peg$c437;
                  peg$currPos += 4;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c438); }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 5) === peg$c439) {
                    s1 = peg$c439;
                    peg$currPos += 5;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c440); }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c441) {
                      s1 = peg$c441;
                      peg$currPos += 3;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c442); }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 4) === peg$c443) {
                        s1 = peg$c443;
                        peg$currPos += 4;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c444); }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 6) === peg$c445) {
                          s1 = peg$c445;
                          peg$currPos += 6;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c446); }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 6) === peg$c447) {
                            s1 = peg$c447;
                            peg$currPos += 6;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c448); }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 6) === peg$c449) {
                              s1 = peg$c449;
                              peg$currPos += 6;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c450); }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 10) === peg$c451) {
                                s1 = peg$c451;
                                peg$currPos += 10;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c452); }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 9) === peg$c453) {
                                  s1 = peg$c453;
                                  peg$currPos += 9;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c454); }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 7) === peg$c455) {
                                    s1 = peg$c455;
                                    peg$currPos += 7;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c456); }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 7) === peg$c457) {
                                      s1 = peg$c457;
                                      peg$currPos += 7;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$c458); }
                                    }
                                    if (s1 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 9) === peg$c459) {
                                        s1 = peg$c459;
                                        peg$currPos += 9;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) { peg$fail(peg$c460); }
                                      }
                                      if (s1 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 6) === peg$c461) {
                                          s1 = peg$c461;
                                          peg$currPos += 6;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) { peg$fail(peg$c462); }
                                        }
                                        if (s1 === peg$FAILED) {
                                          if (input.substr(peg$currPos, 6) === peg$c463) {
                                            s1 = peg$c463;
                                            peg$currPos += 6;
                                          } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) { peg$fail(peg$c464); }
                                          }
                                          if (s1 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 5) === peg$c465) {
                                              s1 = peg$c465;
                                              peg$currPos += 5;
                                            } else {
                                              s1 = peg$FAILED;
                                              if (peg$silentFails === 0) { peg$fail(peg$c466); }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c6;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseCSKeywords() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 204 + 195,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 9) === peg$c413) {
        s1 = peg$c413;
        peg$currPos += 9;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c414); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 4) === peg$c401) {
          s1 = peg$c401;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c402); }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c415) {
            s1 = peg$c415;
            peg$currPos += 6;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c416); }
          }
          if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c417) {
              s1 = peg$c417;
              peg$currPos += 5;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c418); }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c377) {
                s1 = peg$c377;
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c378); }
              }
              if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c389) {
                  s1 = peg$c389;
                  peg$currPos += 3;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c390); }
                }
                if (s1 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c343) {
                    s1 = peg$c343;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c344); }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c419) {
                      s1 = peg$c419;
                      peg$currPos += 4;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c420); }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.substr(peg$currPos, 3) === peg$c339) {
                        s1 = peg$c339;
                        peg$currPos += 3;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c340); }
                      }
                      if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c393) {
                          s1 = peg$c393;
                          peg$currPos += 2;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c394); }
                        }
                        if (s1 === peg$FAILED) {
                          if (input.substr(peg$currPos, 4) === peg$c375) {
                            s1 = peg$c375;
                            peg$currPos += 4;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c376); }
                          }
                          if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c373) {
                              s1 = peg$c373;
                              peg$currPos += 2;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c374); }
                            }
                            if (s1 === peg$FAILED) {
                              if (input.substr(peg$currPos, 3) === peg$c383) {
                                s1 = peg$c383;
                                peg$currPos += 3;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c384); }
                              }
                              if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 3) === peg$c423) {
                                  s1 = peg$c423;
                                  peg$currPos += 3;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c424); }
                                }
                                if (s1 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 2) === peg$c381) {
                                    s1 = peg$c381;
                                    peg$currPos += 2;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c382); }
                                  }
                                  if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 2) === peg$c391) {
                                      s1 = peg$c391;
                                      peg$currPos += 2;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$c392); }
                                    }
                                    if (s1 === peg$FAILED) {
                                      if (input.substr(peg$currPos, 2) === peg$c387) {
                                        s1 = peg$c387;
                                        peg$currPos += 2;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) { peg$fail(peg$c388); }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parseidentifierPart();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c6;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsereserved() {
      var s0, s1;

      var key    = peg$currPos * 204 + 196,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsemacro();
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$parseSharedKeywords();
        if (s0 === peg$FAILED) {
          s0 = peg$parseCSKeywords();
          if (s0 === peg$FAILED) {
            s0 = peg$parseJSKeywords();
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseUnicodeEscapeSequence() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 204 + 197,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c467) {
        s1 = peg$c467;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c468); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsehexDigit();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsehexDigit();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsehexDigit();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsehexDigit();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c469(s2, s3, s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseUnicodeLetter() {
      var s0, s1, s2;

      var key    = peg$currPos * 204 + 198,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c470.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c471); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 55340) {
          s1 = peg$c472;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c473); }
        }
        if (s1 !== peg$FAILED) {
          if (peg$c474.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c475); }
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 55304) {
            s1 = peg$c476;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c477); }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c478.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c479); }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 55401) {
              s1 = peg$c480;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c481); }
            }
            if (s1 !== peg$FAILED) {
              if (peg$c482.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c483); }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 55305) {
                s1 = peg$c484;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c485); }
              }
              if (s1 !== peg$FAILED) {
                if (peg$c486.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c487); }
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 55349) {
                  s1 = peg$c488;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c489); }
                }
                if (s1 !== peg$FAILED) {
                  if (peg$c490.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c491); }
                  }
                  if (s2 !== peg$FAILED) {
                    s1 = [s1, s2];
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 55300) {
                    s1 = peg$c492;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c493); }
                  }
                  if (s1 !== peg$FAILED) {
                    if (peg$c494.test(input.charAt(peg$currPos))) {
                      s2 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c495); }
                    }
                    if (s2 !== peg$FAILED) {
                      s1 = [s1, s2];
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 55296) {
                      s1 = peg$c496;
                      peg$currPos++;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c497); }
                    }
                    if (s1 !== peg$FAILED) {
                      if (peg$c498.test(input.charAt(peg$currPos))) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c499); }
                      }
                      if (s2 !== peg$FAILED) {
                        s1 = [s1, s2];
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.charCodeAt(peg$currPos) === 55308) {
                        s1 = peg$c500;
                        peg$currPos++;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c501); }
                      }
                      if (s1 !== peg$FAILED) {
                        if (peg$c502.test(input.charAt(peg$currPos))) {
                          s2 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s2 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c503); }
                        }
                        if (s2 !== peg$FAILED) {
                          s1 = [s1, s2];
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 55297) {
                          s1 = peg$c504;
                          peg$currPos++;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c505); }
                        }
                        if (s1 !== peg$FAILED) {
                          if (peg$c506.test(input.charAt(peg$currPos))) {
                            s2 = input.charAt(peg$currPos);
                            peg$currPos++;
                          } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c507); }
                          }
                          if (s2 !== peg$FAILED) {
                            s1 = [s1, s2];
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          if (input.charCodeAt(peg$currPos) === 55406) {
                            s1 = peg$c508;
                            peg$currPos++;
                          } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c509); }
                          }
                          if (s1 !== peg$FAILED) {
                            if (peg$c510.test(input.charAt(peg$currPos))) {
                              s2 = input.charAt(peg$currPos);
                              peg$currPos++;
                            } else {
                              s2 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c511); }
                            }
                            if (s2 !== peg$FAILED) {
                              s1 = [s1, s2];
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 55299) {
                              s1 = peg$c512;
                              peg$currPos++;
                            } else {
                              s1 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c513); }
                            }
                            if (s1 !== peg$FAILED) {
                              if (peg$c514.test(input.charAt(peg$currPos))) {
                                s2 = input.charAt(peg$currPos);
                                peg$currPos++;
                              } else {
                                s2 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c515); }
                              }
                              if (s2 !== peg$FAILED) {
                                s1 = [s1, s2];
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                            if (s0 === peg$FAILED) {
                              s0 = peg$currPos;
                              if (input.charCodeAt(peg$currPos) === 55360) {
                                s1 = peg$c516;
                                peg$currPos++;
                              } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c517); }
                              }
                              if (s1 !== peg$FAILED) {
                                if (peg$c518.test(input.charAt(peg$currPos))) {
                                  s2 = input.charAt(peg$currPos);
                                  peg$currPos++;
                                } else {
                                  s2 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c519); }
                                }
                                if (s2 !== peg$FAILED) {
                                  s1 = [s1, s2];
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$c0;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                              if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                if (input.charCodeAt(peg$currPos) === 55422) {
                                  s1 = peg$c520;
                                  peg$currPos++;
                                } else {
                                  s1 = peg$FAILED;
                                  if (peg$silentFails === 0) { peg$fail(peg$c521); }
                                }
                                if (s1 !== peg$FAILED) {
                                  if (peg$c522.test(input.charAt(peg$currPos))) {
                                    s2 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                  } else {
                                    s2 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c523); }
                                  }
                                  if (s2 !== peg$FAILED) {
                                    s1 = [s1, s2];
                                    s0 = s1;
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$c0;
                                }
                                if (s0 === peg$FAILED) {
                                  s0 = peg$currPos;
                                  if (input.charCodeAt(peg$currPos) === 55405) {
                                    s1 = peg$c524;
                                    peg$currPos++;
                                  } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) { peg$fail(peg$c525); }
                                  }
                                  if (s1 !== peg$FAILED) {
                                    if (peg$c526.test(input.charAt(peg$currPos))) {
                                      s2 = input.charAt(peg$currPos);
                                      peg$currPos++;
                                    } else {
                                      s2 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$c527); }
                                    }
                                    if (s2 !== peg$FAILED) {
                                      s1 = [s1, s2];
                                      s0 = s1;
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$c0;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                  }
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    if (input.charCodeAt(peg$currPos) === 55322) {
                                      s1 = peg$c528;
                                      peg$currPos++;
                                    } else {
                                      s1 = peg$FAILED;
                                      if (peg$silentFails === 0) { peg$fail(peg$c529); }
                                    }
                                    if (s1 !== peg$FAILED) {
                                      if (peg$c530.test(input.charAt(peg$currPos))) {
                                        s2 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                      } else {
                                        s2 = peg$FAILED;
                                        if (peg$silentFails === 0) { peg$fail(peg$c531); }
                                      }
                                      if (s2 !== peg$FAILED) {
                                        s1 = [s1, s2];
                                        s0 = s1;
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$c0;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$c0;
                                    }
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$currPos;
                                      if (input.charCodeAt(peg$currPos) === 55298) {
                                        s1 = peg$c532;
                                        peg$currPos++;
                                      } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) { peg$fail(peg$c533); }
                                      }
                                      if (s1 !== peg$FAILED) {
                                        if (peg$c534.test(input.charAt(peg$currPos))) {
                                          s2 = input.charAt(peg$currPos);
                                          peg$currPos++;
                                        } else {
                                          s2 = peg$FAILED;
                                          if (peg$silentFails === 0) { peg$fail(peg$c535); }
                                        }
                                        if (s2 !== peg$FAILED) {
                                          s1 = [s1, s2];
                                          s0 = s1;
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$c0;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$c0;
                                      }
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        if (input.charCodeAt(peg$currPos) === 55309) {
                                          s1 = peg$c536;
                                          peg$currPos++;
                                        } else {
                                          s1 = peg$FAILED;
                                          if (peg$silentFails === 0) { peg$fail(peg$c537); }
                                        }
                                        if (s1 !== peg$FAILED) {
                                          if (peg$c538.test(input.charAt(peg$currPos))) {
                                            s2 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                          } else {
                                            s2 = peg$FAILED;
                                            if (peg$silentFails === 0) { peg$fail(peg$c539); }
                                          }
                                          if (s2 !== peg$FAILED) {
                                            s1 = [s1, s2];
                                            s0 = s1;
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$c0;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$c0;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseUnicodeCombiningMark() {
      var s0, s1, s2;

      var key    = peg$currPos * 204 + 199,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c540.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c541); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 56128) {
          s1 = peg$c542;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c543); }
        }
        if (s1 !== peg$FAILED) {
          if (peg$c544.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c545); }
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 55348) {
            s1 = peg$c546;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c547); }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c548.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c549); }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 55300) {
              s1 = peg$c492;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c493); }
            }
            if (s1 !== peg$FAILED) {
              if (peg$c550.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c551); }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 55296) {
                s1 = peg$c496;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c497); }
              }
              if (s1 !== peg$FAILED) {
                if (peg$c552.test(input.charAt(peg$currPos))) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c553); }
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 55298) {
                  s1 = peg$c532;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c533); }
                }
                if (s1 !== peg$FAILED) {
                  if (peg$c554.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c555); }
                  }
                  if (s2 !== peg$FAILED) {
                    s1 = [s1, s2];
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseUnicodeDigit() {
      var s0, s1, s2;

      var key    = peg$currPos * 204 + 200,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c556.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c557); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 55349) {
          s1 = peg$c488;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c489); }
        }
        if (s1 !== peg$FAILED) {
          if (peg$c558.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c559); }
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 55300) {
            s1 = peg$c492;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c493); }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c560.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c561); }
            }
            if (s2 !== peg$FAILED) {
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 55297) {
              s1 = peg$c504;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c505); }
            }
            if (s1 !== peg$FAILED) {
              if (peg$c562.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c563); }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseUnicodeConnectorPunctuation() {
      var s0;

      var key    = peg$currPos * 204 + 201,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c564.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c565); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseZWNJ() {
      var s0;

      var key    = peg$currPos * 204 + 202,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (input.charCodeAt(peg$currPos) === 8204) {
        s0 = peg$c566;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c567); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseZWJ() {
      var s0;

      var key    = peg$currPos * 204 + 203,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (input.charCodeAt(peg$currPos) === 8205) {
        s0 = peg$c568;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c569); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    // Generated by CoffeeScript 2.0.0-beta9-dev
    var associativities, c, chainableComparisonOps, constructorLookup, createInterpolation, createMemberExpression, CS, foldBinaryExpr, foldl, foldr, id, isValidRegExpFlags, LEFT_ASSOCIATIVE, negatableOps, op, p, postfixConstructorLookup, precedenceHierarchy, precedenceTable, prefixConstructorLookup, r, RIGHT_ASSOCIATIVE, rightAssocOps, rp, stripLeadingWhitespace, stripLeadingWhitespaceInterpolation;
    CS = require('./nodes');
    constructorLookup = {
      '||': CS.LogicalOrOp,
      or: CS.LogicalOrOp,
      '&&': CS.LogicalAndOp,
      and: CS.LogicalAndOp,
      '|': CS.BitOrOp,
      '^': CS.BitXorOp,
      '&': CS.BitAndOp,
      '?': CS.ExistsOp,
      '==': CS.EQOp,
      is: CS.EQOp,
      '!=': CS.NEQOp,
      isnt: CS.NEQOp,
      '<=': CS.LTEOp,
      '>=': CS.GTEOp,
      '<': CS.LTOp,
      '>': CS.GTOp,
      'extends': CS.ExtendsOp,
      'instanceof': CS.InstanceofOp,
      'in': CS.InOp,
      of: CS.OfOp,
      '<<': CS.LeftShiftOp,
      '>>': CS.SignedRightShiftOp,
      '>>>': CS.UnsignedRightShiftOp,
      '+': CS.PlusOp,
      '-': CS.SubtractOp,
      '*': CS.MultiplyOp,
      '/': CS.DivideOp,
      '%': CS.RemOp,
      '**': CS.ExpOp
    };
    negatableOps = [
      'instanceof',
      'in',
      'of'
    ];
    chainableComparisonOps = [
      '<=',
      '>=',
      '<',
      '>',
      '==',
      'is',
      '!=',
      'isnt'
    ];
    rightAssocOps = [
      ';',
      '=',
      '?',
      '**'
    ];
    precedenceHierarchy = [
      [
        'or',
        '||'
      ],
      [
        'and',
        '&&'
      ],
      ['|'],
      ['^'],
      ['&'],
      ['?'],
      [
        'is',
        '==',
        'isnt',
        '!='
      ],
      [
        'instanceof',
        'in',
        'of',
        '<=',
        '>=',
        '<',
        '>'
      ],
      [
        '<<',
        '>>',
        '>>>'
      ],
      [
        '+',
        '-'
      ],
      [
        '*',
        '/',
        '%'
      ],
      ['**']
    ];
    precedenceTable = function () {
      var level, op, ops, table;
      table = {};
      for (var i$ = 0, length$ = precedenceHierarchy.length; i$ < length$; ++i$) {
        ops = precedenceHierarchy[i$];
        level = i$;
        for (var i$1 = 0, length$1 = ops.length; i$1 < length$1; ++i$1) {
          op = ops[i$1];
          table[op] = level;
        }
      }
      return table;
    }();
    RIGHT_ASSOCIATIVE = {};
    LEFT_ASSOCIATIVE = {};
    associativities = function () {
      var op, result, rightAssocOp;
      result = {};
      for (op in precedenceTable) {
        if (!isOwn$(precedenceTable, op))
          continue;
        result[op] = LEFT_ASSOCIATIVE;
      }
      for (var i$ = 0, length$ = rightAssocOps.length; i$ < length$; ++i$) {
        rightAssocOp = rightAssocOps[i$];
        result[rightAssocOp] = RIGHT_ASSOCIATIVE;
      }
      return result;
    }();
    for (var i$ = 0, length$ = negatableOps.length; i$ < length$; ++i$) {
      op = negatableOps[i$];
      (function (op) {
        var fn, negatedOp;
        fn = function (a, b) {
          return new CS.LogicalNotOp(new constructorLookup[op](a, b));
        };
        fn.prototype = constructorLookup[op].prototype;
        negatedOp = 'not ' + op;
        constructorLookup[negatedOp] = fn;
        precedenceTable[negatedOp] = precedenceTable[op];
        return associativities[negatedOp] = associativities[op];
      }(op));
    }
    prefixConstructorLookup = {
      '++': CS.PreIncrementOp,
      '--': CS.PreDecrementOp,
      '+': CS.UnaryPlusOp,
      '-': CS.UnaryNegateOp,
      '!': CS.LogicalNotOp,
      not: CS.LogicalNotOp,
      '~': CS.BitNotOp,
      'do': CS.DoOp,
      'typeof': CS.TypeofOp,
      'delete': CS.DeleteOp
    };
    postfixConstructorLookup = {
      '?': CS.UnaryExistsOp,
      '[..]': CS.ShallowCopyArray,
      '++': CS.PostIncrementOp,
      '--': CS.PostDecrementOp
    };
    foldl = function (fn, memo, list) {
      var item;
      for (var i$1 = 0, length$1 = list.length; i$1 < length$1; ++i$1) {
        item = list[i$1];
        memo = fn(memo, item);
      }
      return memo;
    };
    foldr = function (fn, memo, list) {
      var i, item;
      i = list.length;
      while (i--) {
        item = list[i];
        memo = fn(memo, item);
      }
      return memo;
    };
    foldBinaryExpr = function (parts, ignoreChains) {
      var chainStack, expr, leftOperand, nextOp, nextPrec, operator, prec, rightOperand, stack;
      if (parts.length < 3)
        return parts[0];
      stack = [].slice.call(parts, 0, 3);
      parts = [].slice.call(parts, 3);
      while (parts.length > 0) {
        nextOp = parts[0];
        if (!ignoreChains && stack.length > 2) {
          operator = stack[stack.length - 2];
          if (in$(operator, chainableComparisonOps) && in$(nextOp, chainableComparisonOps)) {
            chainStack = stack.slice(-3);
            stack = stack.slice(0, stack.length - 3);
            while (true) {
              operator = nextOp;
              chainStack.push(parts.shift(), parts.shift());
              nextOp = parts[0];
              if (nextOp) {
                nextPrec = precedenceTable[nextOp];
                prec = precedenceTable[operator];
              }
              if (!(null != nextOp && (nextPrec > prec || in$(nextOp, chainableComparisonOps))))
                break;
            }
            stack.push(new CS.ChainedComparisonOp(foldBinaryExpr(chainStack, true)));
            continue;
          }
        }
        while (stack.length > 2 && (operator = stack[stack.length - 2], (prec = precedenceTable[operator], (nextPrec = precedenceTable[nextOp], nextPrec < prec || in$(operator, chainableComparisonOps) && in$(nextOp, chainableComparisonOps) || nextPrec === prec && associativities[operator] === LEFT_ASSOCIATIVE)))) {
          rightOperand = stack.pop();
          stack.pop();
          leftOperand = stack.pop();
          stack.push(new constructorLookup[operator](leftOperand, rightOperand));
        }
        stack.push(parts.shift());
        stack.push(parts.shift());
      }
      expr = stack.pop();
      while (stack.length > 0) {
        expr = new constructorLookup[(stack.pop())](stack.pop(), expr);
      }
      return expr;
    };
    createInterpolation = function (es) {
      var init;
      init = new CS.String('').g().r('');
      return foldl(function (memo, s) {
        var left;
        if (s instanceof CS.String) {
          left = memo;
          while (left) {
            if (left instanceof CS.String) {
              if (left === init) {
                c(left, s);
                left.raw = s.raw;
                delete left.generated;
              }
              left.data = '' + left.data + s.data;
              return memo;
            } else if (left instanceof CS.ConcatOp) {
              left = left.right;
            } else {
              break;
            }
          }
        }
        return new CS.ConcatOp(memo, s);
      }, init, es);
    };
    createMemberExpression = function (e, accesses) {
      return foldl(function (left, access) {
        var F, o;
        F = function () {
        };
        F.prototype = access.op.prototype;
        o = new F;
        access.op.call.apply(access.op, [
          o,
          left
        ].concat([].slice.call(access.operands)));
        return c(o.r(left.raw + access.raw), e);
      }, e, accesses);
    };
    isValidRegExpFlags = function (flags) {
      var f, flag;
      if (!flags)
        return true;
      if (flags.length > 4)
        return false;
      flags.sort();
      flag = null;
      for (var i$1 = 0, length$1 = flags.length; i$1 < length$1; ++i$1) {
        f = flags[i$1];
        if (flag === f)
          return false;
        flag = f;
      }
      return true;
    };
    stripLeadingWhitespace = function (str) {
      var attempt, cache$, indent, match, matchStr, wholeMatch;
      str = str.trimRight();
      matchStr = str;
      indent = null;
      while (match = /\n+([^\n\S]*)/.exec(matchStr)) {
        cache$ = match;
        wholeMatch = cache$[0];
        attempt = cache$[1];
        matchStr = matchStr.slice(match.index + wholeMatch.length);
        if (!(null != indent) || 0 < attempt.length && attempt.length < indent.length)
          indent = attempt;
      }
      if (indent)
        str = str.replace(new RegExp('\\n' + indent, 'g'), '\n');
      str = str.replace(/^\n/, '');
      return str;
    };
    stripLeadingWhitespaceInterpolation = function (pieces) {
      var attempt, cache$, indent, index, match, matchStr, piece, wholeMatch;
      indent = null;
      for (var i$1 = 0, length$1 = pieces.length; i$1 < length$1; ++i$1) {
        piece = pieces[i$1];
        index = i$1;
        if (piece instanceof CS.String) {
          if (index === pieces.length - 1)
            piece.data = piece.data.replace(/\s+$/, '');
          matchStr = piece.data;
          while (match = /\n+([^\n\S]*)/.exec(matchStr)) {
            cache$ = match;
            wholeMatch = cache$[0];
            attempt = cache$[1];
            matchStr = matchStr.slice(match.index + wholeMatch.length);
            if (!(null != indent) || 0 < attempt.length && attempt.length < indent.length)
              indent = attempt;
          }
        }
      }
      if (indent)
        for (var i$2 = 0, length$2 = pieces.length; i$2 < length$2; ++i$2) {
          piece = pieces[i$2];
          index = i$2;
          if (piece instanceof CS.String) {
            piece.data = piece.data.replace(new RegExp('\\n' + indent, 'g'), '\n');
            if (index === pieces.length - 1)
              piece.data = piece.data.replace(/(\n\s*)+$/, '');
            if (index === 0)
              piece.data = piece.data.replace(/^\n/, '');
          }
        }
      return pieces;
    };
    r = function (node) {
      node.raw = text().replace(/[\uEFEF\uEFFE\uEFFF]/g, '');
      return node;
    };
    p = function (node) {
      node.line = line();
      node.column = column();
      node.offset = offset();
      return node;
    };
    rp = function (node) {
      return r(p(node));
    };
    c = function (to, from) {
      to.line = from.line;
      to.column = from.column;
      to.offset = from.offset;
      return to;
    };
    id = function (x) {
      return x;
    };
    if (!options.raw)
      r = p = rp = id;
    eval('\n  // XXX: The functions below override the default code generated by PEGjs.\n  // CoffeeScriptRedux has a preprocessor that adds control characters to\n  // mark indents/outdents/etc for PEGjs. These characters cause the line,\n  // column, and offset values to differ from the original input source code,\n  // so this section exists to properly hide those control characters when\n  // reporting location information. See #117 & #335.\n\n  var csr$controlCharacterCount = 0;\n\n  function offset() {\n    return peg$reportedPos - csr$controlCharacterCount;\n  }\n\n  function peg$computePosDetails(pos) {\n    function advance(details, startPos, endPos) {\n      var p, ch;\n\n      for (p = startPos; p < endPos; p++) {\n        ch = input.charAt(p);\n        if (ch === "\\n") {\n          if (!details.seenCR) { details.line++; }\n          details.column = 1;\n          details.seenCR = false;\n        } else if (ch === "\\r" || ch === "\\u2028" || ch === "\\u2029") {\n          details.line++;\n          details.column = 1;\n          details.seenCR = true;\n        } else if(!/[\\uEFEF\\uEFFE\\uEFFF]/.test(ch)) {\n          details.column++;\n          details.seenCR = false;\n        } else {\n          csr$controlCharacterCount++;\n        }\n      }\n    }\n\n    if (peg$cachedPos !== pos) {\n      if (peg$cachedPos > pos) {\n        csr$controlCharacterCount = 0;\n        peg$cachedPos = 0;\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n      }\n      advance(peg$cachedPosDetails, peg$cachedPos, pos);\n      peg$cachedPos = pos;\n    }\n\n    return peg$cachedPosDetails;\n  }\n  ');
    function isOwn$(o, p) {
      return {}.hasOwnProperty.call(o, p);
    }
    function in$(member, list) {
      for (var i = 0, length = list.length; i < length; ++i)
        if (i in list && list[i] === member)
          return true;
      return false;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();

},{"../package.json":30,"./nodes":6}],9:[function(require,module,exports){
// Generated by CoffeeScript 2.0.0-beta9-dev
var DEDENT, INDENT, pointToErrorLocation, Preprocessor, StringScanner, TERM, ws;
pointToErrorLocation = require('./helpers').pointToErrorLocation;
StringScanner = require('StringScanner');
this.Preprocessor = Preprocessor = function () {
  ws = '\\t\\x0B\\f\\r \\xA0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF';
  INDENT = '\uEFEF';
  DEDENT = '\uEFFE';
  TERM = '\uEFFF';
  function Preprocessor(param$) {
    if (null == param$)
      param$ = {};
    this.options = param$;
    this.preprocessed = '';
    this.base = null;
    this.indents = [];
    this.context = [];
  }
  Preprocessor.process = function (input, options) {
    if (null == options)
      options = {};
    return new Preprocessor(options).process(input);
  };
  Preprocessor.prototype.err = function (c) {
    var columns, context, lines, token;
    token = function () {
      switch (c) {
      case INDENT:
        return 'INDENT';
      case DEDENT:
        return 'DEDENT';
      case TERM:
        return 'TERM';
      default:
        return '"' + c.replace(/"/g, '\\"') + '"';
      }
    }.call(this);
    lines = this.ss.str.substr(0, this.ss.pos).split(/\n/) || [''];
    columns = null != lines[lines.length - 1] ? lines[lines.length - 1].length : 0;
    context = pointToErrorLocation(this.ss.str, lines.length, columns);
    throw new Error('Unexpected ' + token + '\n' + context);
  };
  Preprocessor.prototype.peek = function () {
    if (this.context.length) {
      return this.context[this.context.length - 1];
    } else {
      return null;
    }
  };
  Preprocessor.prototype.observe = function (c) {
    var top;
    top = this.peek();
    switch (c) {
    case '"""':
    case "'''":
    case '"':
    case "'":
    case '###':
    case '`':
    case '///':
    case '/':
      if (top === c) {
        this.context.pop();
      } else {
        this.context.push(c);
      }
      break;
    case INDENT:
    case '#':
    case '#{':
    case '[':
    case '(':
    case '{':
    case '\\':
    case 'regexp-[':
    case 'regexp-(':
    case 'regexp-{':
    case 'heregexp-#':
    case 'heregexp-[':
    case 'heregexp-(':
    case 'heregexp-{':
      this.context.push(c);
      break;
    case DEDENT:
      if (!(top === INDENT))
        this.err(c);
      this.indents.pop();
      this.context.pop();
      break;
    case '\n':
      if (!(top === '#' || top === 'heregexp-#'))
        this.err(c);
      this.context.pop();
      break;
    case ']':
      if (!(top === '[' || top === 'regexp-[' || top === 'heregexp-['))
        this.err(c);
      this.context.pop();
      break;
    case ')':
      if (!(top === '(' || top === 'regexp-(' || top === 'heregexp-('))
        this.err(c);
      this.context.pop();
      break;
    case '}':
      if (!(top === '#{' || top === '{' || top === 'regexp-{' || top === 'heregexp-{'))
        this.err(c);
      this.context.pop();
      break;
    case 'end-\\':
      if (!(top === '\\'))
        this.err(c);
      this.context.pop();
      break;
    default:
      throw new Error('undefined token observed: ' + c);
    }
    return this.context;
  };
  Preprocessor.prototype.p = function (s) {
    if (null != s)
      this.preprocessed = '' + this.preprocessed + s;
    return s;
  };
  Preprocessor.prototype.scan = function (r) {
    return this.p(this.ss.scan(r));
  };
  Preprocessor.prototype.consumeIndentation = function () {
    var context, indent, indentIndex, lineLen, lines, message;
    if (this.ss.bol() || this.scan(new RegExp('(?:[' + ws + ']*\\n)+'))) {
      this.scan(new RegExp('(?:[' + ws + ']*(\\#\\#?(?!\\#)[^\\n]*)?\\n)+'));
      if (null != this.base) {
        if (!(this.ss.eos() || null != this.scan(this.base))) {
          throw new Error('inconsistent base indentation');
        }
      } else {
        this.base = new RegExp('' + this.scan(new RegExp('[' + ws + ']*')) + '');
      }
      indentIndex = 0;
      while (indentIndex < this.indents.length) {
        indent = this.indents[indentIndex];
        if (this.ss.check(new RegExp('' + indent + ''))) {
          this.scan(new RegExp('' + indent + ''));
        } else if (this.ss.eos() || this.ss.check(new RegExp('[^' + ws + ']'))) {
          --indentIndex;
          this.p('' + DEDENT + TERM);
          this.observe(DEDENT);
        } else {
          lines = this.ss.str.substr(0, this.ss.pos).split(/\n/) || [''];
          message = 'Syntax error on line ' + lines.length + ': indentation is ambiguous';
          lineLen = this.indents.reduce(function (l, r) {
            return l + r.length;
          }, 0);
          context = pointToErrorLocation(this.ss.str, lines.length, lineLen);
          throw new Error('' + message + '\n' + context);
        }
        ++indentIndex;
      }
      if (this.ss.check(new RegExp('[' + ws + ']+[^' + ws + '#]'))) {
        this.indents.push(this.scan(new RegExp('[' + ws + ']+')));
        this.p(INDENT);
        return this.observe(INDENT);
      }
    }
  };
  Preprocessor.prototype.introduceContext = function () {
    var impliedRegexp, lastChar, pos, spaceBefore, tok;
    if (tok = this.scan(/"""|'''|\/\/\/|###|["'`#[({\\]/)) {
      return this.observe(tok);
    } else if (tok = this.scan(/\//)) {
      pos = this.ss.position();
      if (pos > 1) {
        lastChar = this.ss.string()[pos - 2];
        spaceBefore = new RegExp('[' + ws + ']').test(lastChar);
        impliedRegexp = /[;,=><*%^&|[(+!~-]/.test(lastChar);
      }
      if (pos === 1 || impliedRegexp || spaceBefore && !this.ss.check(new RegExp('[' + ws + '=]')) && this.ss.check(/[^\r\n]*\//))
        return this.observe('/');
    }
  };
  Preprocessor.prototype.process = function (input) {
    var tok;
    if (this.options.literate)
      input = input.replace(/^( {0,3}\S)/gm, '    #$1');
    this.ss = new StringScanner(input);
    while (!this.ss.eos()) {
      switch (this.peek()) {
      case null:
      case INDENT:
        this.consumeIndentation();
        this.scan(/[^\n'"\\\/#`[(){}\]]+/);
        if (this.ss.check(/[})\]]/)) {
          while (this.peek() === INDENT) {
            this.p('' + DEDENT + TERM);
            this.observe(DEDENT);
          }
          this.observe(this.scan(/[})\]]/));
        } else {
          this.introduceContext();
        }
        break;
      case '#{':
      case '{':
        this.scan(/[^\n'"\\\/#`[({}]+/);
        if (tok = this.scan(/\}/)) {
          this.observe(tok);
        } else {
          this.consumeIndentation();
          this.introduceContext();
        }
        break;
      case '[':
        this.scan(/[^\n'"\\\/#`[({\]]+/);
        if (tok = this.scan(/\]/)) {
          this.observe(tok);
        } else {
          this.consumeIndentation();
          this.introduceContext();
        }
        break;
      case '(':
        this.scan(/[^\n'"\\\/#`[({)]+/);
        if (tok = this.scan(/\)/)) {
          this.observe(tok);
        } else {
          this.consumeIndentation();
          this.introduceContext();
        }
        break;
      case '\\':
        if (this.scan(/[\s\S]/))
          this.observe('end-\\');
        break;
      case '"""':
        this.scan(/(?:[^"#\\]+|""?(?!")|#(?!{)|\\.)+/);
        this.ss.scan(/\\\n/);
        if (tok = this.scan(/#{|"""/)) {
          this.observe(tok);
        } else if (tok = this.scan(/#{|"""/)) {
          this.observe(tok);
        }
        break;
      case '"':
        this.scan(/(?:[^"#\\]+|#(?!{)|\\.)+/);
        this.ss.scan(/\\\n/);
        if (tok = this.scan(/#{|"/))
          this.observe(tok);
        break;
      case "'''":
        this.scan(/(?:[^'\\]+|''?(?!')|\\.)+/);
        this.ss.scan(/\\\n/);
        if (tok = this.scan(/'''/))
          this.observe(tok);
        break;
      case "'":
        this.scan(/(?:[^'\\]+|\\.)+/);
        this.ss.scan(/\\\n/);
        if (tok = this.scan(/'/))
          this.observe(tok);
        break;
      case '###':
        this.scan(/(?:[^#]+|##?(?!#))+/);
        if (tok = this.scan(/###/))
          this.observe(tok);
        break;
      case '#':
        this.scan(/[^\n]+/);
        if (tok = this.scan(/\n/))
          this.observe(tok);
        break;
      case '`':
        this.scan(/[^`]+/);
        if (tok = this.scan(/`/))
          this.observe(tok);
        break;
      case '///':
        this.scan(/(?:[^[/#\\]+|\/\/?(?!\/)|\\.)+/);
        if (tok = this.scan(/#{|\/\/\/|\\/)) {
          this.observe(tok);
        } else if (this.ss.scan(/#/)) {
          this.observe('heregexp-#');
        } else if (tok = this.scan(/[\[]/)) {
          this.observe('heregexp-' + tok);
        }
        break;
      case 'heregexp-[':
        this.scan(/(?:[^\]\/\\]+|\/\/?(?!\/))+/);
        if (tok = this.scan(/[\]\\]|#{|\/\/\//))
          this.observe(tok);
        break;
      case 'heregexp-#':
        this.ss.scan(/(?:[^\n/]+|\/\/?(?!\/))+/);
        if (tok = this.scan(/\n|\/\/\//))
          this.observe(tok);
        break;
      case '/':
        this.scan(/[^[/\\]+/);
        if (tok = this.scan(/[\/\\]/)) {
          this.observe(tok);
        } else if (tok = this.scan(/\[/)) {
          this.observe('regexp-' + tok);
        }
        break;
      case 'regexp-[':
        this.scan(/[^\]\\]+/);
        if (tok = this.scan(/[\]\\]/))
          this.observe(tok);
      }
    }
    this.scan(new RegExp('[' + ws + '\\n]*$'));
    while (this.context.length) {
      switch (this.peek()) {
      case INDENT:
        this.p('' + DEDENT + TERM);
        this.observe(DEDENT);
        break;
      case '#':
        this.p('\n');
        this.observe('\n');
        break;
      default:
        throw new Error('Unclosed "' + this.peek().replace(/"/g, '\\"') + '" at EOF');
      }
    }
    return this.preprocessed;
  };
  return Preprocessor;
}();

},{"./helpers":3,"StringScanner":12}],10:[function(require,module,exports){
// Generated by CoffeeScript 2.0.0-beta9-dev
var child_process, coffeeBinary, CoffeeScript, fork, fs, path, runModule;
child_process = require('child_process');
fs = require('fs');
path = require('path');
CoffeeScript = require('./module');
runModule = require('./run').runModule;
module.exports = !(null != require.extensions['.coffee']);
require.extensions['.coffee'] = function (module, filename) {
  var csAst, input, js, jsAst;
  input = fs.readFileSync(filename, 'utf8');
  csAst = CoffeeScript.parse(input, { raw: true });
  jsAst = CoffeeScript.compile(csAst);
  js = CoffeeScript.js(jsAst);
  return runModule(module, js, jsAst, filename);
};
require.extensions['.litcoffee'] = function (module, filename) {
  var csAst, input, js, jsAst;
  input = fs.readFileSync(filename, 'utf8');
  csAst = CoffeeScript.parse(input, {
    raw: true,
    literate: true
  });
  jsAst = CoffeeScript.compile(csAst);
  js = CoffeeScript.js(jsAst);
  return runModule(module, js, jsAst, filename);
};
fork = child_process.fork;
if (!fork.coffeePatched) {
  coffeeBinary = path.resolve('bin', 'coffee');
  child_process.fork = function (file, args, options) {
    if (null == args)
      args = [];
    if (null == options)
      options = {};
    if (in$(path.extname(file), [
        '.coffee',
        '.litcoffee'
      ])) {
      if (!Array.isArray(args)) {
        args = [];
        options = args || {};
      }
      options.execPath || (options.execPath = coffeeBinary);
    }
    return fork(file, args, options);
  };
  child_process.fork.coffeePatched = true;
}
delete require.cache[__filename];
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

},{"./module":5,"./run":11,"child_process":32,"fs":32,"path":33}],11:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 2.0.0-beta9-dev
var CoffeeScript, formatSourcePosition, Module, patched, patchStackTrace, path, runMain, runModule, SourceMapConsumer;
path = require('path');
Module = require('module');
CoffeeScript = require('./module');
SourceMapConsumer = require('source-map').SourceMapConsumer;
patched = false;
patchStackTrace = function () {
  if (patched)
    return;
  patched = true;
  if (null != Module._sourceMaps)
    Module._sourceMaps;
  else
    Module._sourceMaps = {};
  return Error.prepareStackTrace = function (err, stack) {
    var frame, frames, getSourceMapping, sourceFiles;
    sourceFiles = {};
    getSourceMapping = function (filename, line, column) {
      var mapString, sourceMap;
      mapString = 'function' === typeof Module._sourceMaps[filename] ? Module._sourceMaps[filename]() : void 0;
      if (mapString) {
        sourceMap = null != sourceFiles[filename] ? sourceFiles[filename] : sourceFiles[filename] = new SourceMapConsumer(mapString);
        return sourceMap.originalPositionFor({
          line: line,
          column: column - 1
        });
      }
    };
    frames = function (accum$) {
      for (var i$ = 0, length$ = stack.length; i$ < length$; ++i$) {
        frame = stack[i$];
        if (frame.getFunction() === exports.runMain)
          break;
        accum$.push('  at ' + formatSourcePosition(frame, getSourceMapping));
      }
      return accum$;
    }.call(this, []);
    return '' + err.toString() + '\n' + frames.join('\n') + '\n';
  };
};
formatSourcePosition = function (frame, getSourceMapping) {
  var as, column, fileLocation, fileName, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;
  fileName = void 0;
  fileLocation = '';
  if (frame.isNative()) {
    fileLocation = 'native';
  } else {
    if (frame.isEval()) {
      fileName = frame.getScriptNameOrSourceURL();
      if (!fileName)
        fileLocation = '' + frame.getEvalOrigin() + ', ';
    } else {
      fileName = frame.getFileName();
    }
    fileName || (fileName = '<anonymous>');
    line = frame.getLineNumber();
    column = frame.getColumnNumber();
    source = getSourceMapping(fileName, line, column);
    fileLocation = source ? null != source.line ? '' + fileName + ':' + source.line + ':' + (source.column + 1) + ', <js>:' + line + ':' + column : '' + fileName + ' <js>:' + line + ':' + column : '' + fileName + ':' + line + ':' + column;
  }
  functionName = frame.getFunctionName();
  isConstructor = frame.isConstructor();
  isMethodCall = !(frame.isToplevel() || isConstructor);
  if (isMethodCall) {
    methodName = frame.getMethodName();
    typeName = frame.getTypeName();
    if (functionName) {
      tp = as = '';
      if (typeName && functionName.indexOf(typeName))
        tp = '' + typeName + '.';
      if (methodName && functionName.indexOf('.' + methodName) !== functionName.length - methodName.length - 1)
        as = ' [as ' + methodName + ']';
      return '' + tp + functionName + as + ' (' + fileLocation + ')';
    } else {
      return '' + typeName + '.' + (methodName || '<anonymous>') + ' (' + fileLocation + ')';
    }
  } else if (isConstructor) {
    return 'new ' + (functionName || '<anonymous>') + ' (' + fileLocation + ')';
  } else if (functionName) {
    return '' + functionName + ' (' + fileLocation + ')';
  } else {
    return fileLocation;
  }
};
runMain = function (csSource, jsSource, jsAst, filename) {
  var mainModule;
  mainModule = new Module('.');
  mainModule.filename = process.argv[1] = filename;
  process.mainModule = mainModule;
  Module._cache[mainModule.filename] = mainModule;
  mainModule.paths = Module._nodeModulePaths(path.dirname(filename));
  return runModule(mainModule, jsSource, jsAst, filename);
};
runModule = function (module, jsSource, jsAst, filename) {
  patchStackTrace();
  Module._sourceMaps[filename] = function () {
    return '' + CoffeeScript.sourceMap(jsAst, filename);
  };
  return module._compile(jsSource, filename);
};
module.exports = {
  runMain: runMain,
  runModule: runModule
};

}).call(this,require("JkpR2F"))
},{"./module":5,"JkpR2F":34,"module":32,"path":33,"source-map":19}],12:[function(require,module,exports){
(function() {
  var StringScanner;
  StringScanner = (function() {
    function StringScanner(str) {
      this.str = str != null ? str : '';
      this.str = '' + this.str;
      this.pos = 0;
      this.lastMatch = {
        reset: function() {
          this.str = null;
          this.captures = [];
          return this;
        }
      }.reset();
      this;
    }
    StringScanner.prototype.bol = function() {
      return this.pos <= 0 || (this.str[this.pos - 1] === "\n");
    };
    StringScanner.prototype.captures = function() {
      return this.lastMatch.captures;
    };
    StringScanner.prototype.check = function(pattern) {
      var matches;
      if (this.str.substr(this.pos).search(pattern) !== 0) {
        this.lastMatch.reset();
        return null;
      }
      matches = this.str.substr(this.pos).match(pattern);
      this.lastMatch.str = matches[0];
      this.lastMatch.captures = matches.slice(1);
      return this.lastMatch.str;
    };
    StringScanner.prototype.checkUntil = function(pattern) {
      var matches, patternPos;
      patternPos = this.str.substr(this.pos).search(pattern);
      if (patternPos < 0) {
        this.lastMatch.reset();
        return null;
      }
      matches = this.str.substr(this.pos + patternPos).match(pattern);
      this.lastMatch.captures = matches.slice(1);
      return this.lastMatch.str = this.str.substr(this.pos, patternPos) + matches[0];
    };
    StringScanner.prototype.clone = function() {
      var clone, prop, value, _ref;
      clone = new this.constructor(this.str);
      clone.pos = this.pos;
      clone.lastMatch = {};
      _ref = this.lastMatch;
      for (prop in _ref) {
        value = _ref[prop];
        clone.lastMatch[prop] = value;
      }
      return clone;
    };
    StringScanner.prototype.concat = function(str) {
      this.str += str;
      return this;
    };
    StringScanner.prototype.eos = function() {
      return this.pos === this.str.length;
    };
    StringScanner.prototype.exists = function(pattern) {
      var matches, patternPos;
      patternPos = this.str.substr(this.pos).search(pattern);
      if (patternPos < 0) {
        this.lastMatch.reset();
        return null;
      }
      matches = this.str.substr(this.pos + patternPos).match(pattern);
      this.lastMatch.str = matches[0];
      this.lastMatch.captures = matches.slice(1);
      return patternPos;
    };
    StringScanner.prototype.getch = function() {
      return this.scan(/./);
    };
    StringScanner.prototype.match = function() {
      return this.lastMatch.str;
    };
    StringScanner.prototype.matches = function(pattern) {
      this.check(pattern);
      return this.matchSize();
    };
    StringScanner.prototype.matched = function() {
      return this.lastMatch.str != null;
    };
    StringScanner.prototype.matchSize = function() {
      if (this.matched()) {
        return this.match().length;
      } else {
        return null;
      }
    };
    StringScanner.prototype.peek = function(len) {
      return this.str.substr(this.pos, len);
    };
    StringScanner.prototype.pointer = function() {
      return this.pos;
    };
    StringScanner.prototype.setPointer = function(pos) {
      pos = +pos;
      if (pos < 0) {
        pos = 0;
      }
      if (pos > this.str.length) {
        pos = this.str.length;
      }
      return this.pos = pos;
    };
    StringScanner.prototype.reset = function() {
      this.lastMatch.reset();
      this.pos = 0;
      return this;
    };
    StringScanner.prototype.rest = function() {
      return this.str.substr(this.pos);
    };
    StringScanner.prototype.scan = function(pattern) {
      var chk;
      chk = this.check(pattern);
      if (chk != null) {
        this.pos += chk.length;
      }
      return chk;
    };
    StringScanner.prototype.scanUntil = function(pattern) {
      var chk;
      chk = this.checkUntil(pattern);
      if (chk != null) {
        this.pos += chk.length;
      }
      return chk;
    };
    StringScanner.prototype.skip = function(pattern) {
      this.scan(pattern);
      return this.matchSize();
    };
    StringScanner.prototype.skipUntil = function(pattern) {
      this.scanUntil(pattern);
      return this.matchSize();
    };
    StringScanner.prototype.string = function() {
      return this.str;
    };
    StringScanner.prototype.terminate = function() {
      this.pos = this.str.length;
      this.lastMatch.reset();
      return this;
    };
    StringScanner.prototype.toString = function() {
      return "#<StringScanner " + (this.eos() ? 'fin' : "" + this.pos + "/" + this.str.length + " @ " + (this.str.length > 8 ? "" + (this.str.substr(0, 5)) + "..." : this.str)) + ">";
    };
    return StringScanner;
  })();
  StringScanner.prototype.beginningOfLine = StringScanner.prototype.bol;
  StringScanner.prototype.clear = StringScanner.prototype.terminate;
  StringScanner.prototype.dup = StringScanner.prototype.clone;
  StringScanner.prototype.endOfString = StringScanner.prototype.eos;
  StringScanner.prototype.exist = StringScanner.prototype.exists;
  StringScanner.prototype.getChar = StringScanner.prototype.getch;
  StringScanner.prototype.position = StringScanner.prototype.pointer;
  StringScanner.StringScanner = StringScanner;
  module.exports = StringScanner;
}).call(this);

},{}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  (function(exports) {
    var TAB, clone, eq, formatInterpolation, formatStringData, generate, indent, levels, needsParensWhenOnLeft, operators, parens, precedence;
    TAB = '  ';
    indent = function(code) {
      var line;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = code.split('\n');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          _results.push("" + TAB + line);
        }
        return _results;
      })()).join('\n');
    };
    parens = function(code) {
      return "(" + code + ")";
    };
    formatStringData = function(data) {
      return data.replace(/[^\x20-\x7e]|['\\]/, function(c) {
        var escape, pad;
        switch (c) {
          case '\0':
            return '\\0';
          case '\b':
            return '\\b';
          case '\t':
            return '\\t';
          case '\n':
            return '\\n';
          case '\f':
            return '\\f';
          case '\r':
            return '\\r';
          case '\'':
            return '\\\'';
          case '\\':
            return '\\\\';
          default:
            escape = (c.charCodeAt(0)).toString(16);
            pad = "0000".slice(escape.length);
            return "\\u" + pad + escape;
        }
      });
    };
    formatInterpolation = function(ast, options) {
      var left, right;
      switch (ast.className) {
        case "ConcatOp":
          left = formatInterpolation(ast.left, options);
          right = formatInterpolation(ast.right, options);
          return "" + left + right;
        case "String":
          return formatStringData(ast.data);
        default:
          return "\#{" + (generate(ast, options)) + "}";
      }
    };
    needsParensWhenOnLeft = function(ast) {
      switch (ast.className) {
        case 'Function':
        case 'BoundFunction':
        case 'NewOp':
          return true;
        case 'Conditional':
        case 'Switch':
        case 'While':
        case 'Block':
          return true;
        case 'PreIncrementOp':
        case 'PreDecrementOp':
        case 'UnaryPlusOp':
        case 'UnaryNegateOp':
        case 'LogicalNotOp':
        case 'BitNotOp':
        case 'DoOp':
        case 'TypeofOp':
        case 'DeleteOp':
          return needsParensWhenOnLeft(ast.expression);
        case 'FunctionApplication':
          return ast["arguments"].length > 0;
        default:
          return false;
      }
    };
    eq = function(nodeA, nodeB) {
      var i, prop, v, val, _i, _len;
      for (prop in nodeA) {
        if (!__hasProp.call(nodeA, prop)) continue;
        val = nodeA[prop];
        if (prop === 'raw' || prop === 'line' || prop === 'column') {
          continue;
        }
        switch (Object.prototype.toString.call(val)) {
          case '[object Object]':
            if (!eq(nodeB[prop], val)) {
              return false;
            }
            break;
          case '[object Array]':
            for (i = _i = 0, _len = val.length; _i < _len; i = ++_i) {
              v = val[i];
              if (!eq(nodeB[prop][i], v)) {
                return false;
              }
            }
            break;
          default:
            if (nodeB[prop] !== val) {
              return false;
            }
        }
      }
      return true;
    };
    clone = function(obj, overrides) {
      var newObj, prop, val;
      if (overrides == null) {
        overrides = {};
      }
      newObj = {};
      for (prop in obj) {
        if (!__hasProp.call(obj, prop)) continue;
        val = obj[prop];
        newObj[prop] = val;
      }
      for (prop in overrides) {
        if (!__hasProp.call(overrides, prop)) continue;
        val = overrides[prop];
        newObj[prop] = val;
      }
      return newObj;
    };
    levels = [['SeqOp'], ['Conditional', 'ForIn', 'ForOf', 'While'], ['FunctionApplication', 'SoakedFunctionApplication'], ['AssignOp', 'CompoundAssignOp', 'ExistsAssignOp'], ['LogicalOrOp'], ['LogicalAndOp'], ['BitOrOp'], ['BitXorOp'], ['BitAndOp'], ['ExistsOp'], ['EQOp', 'NEQOp'], ['LTOp', 'LTEOp', 'GTOp', 'GTEOp', 'InOp', 'OfOp', 'InstanceofOp'], ['LeftShiftOp', 'SignedRightShiftOp', 'UnsignedRightShiftOp'], ['PlusOp', 'SubtractOp'], ['MultiplyOp', 'DivideOp', 'RemOp'], ['UnaryPlusOp', 'UnaryNegateOp', 'LogicalNotOp', 'BitNotOp', 'DoOp', 'TypeofOp', 'PreIncrementOp', 'PreDecrementOp', 'DeleteOp'], ['UnaryExistsOp', 'ShallowCopyArray', 'PostIncrementOp', 'PostDecrementOp', 'Spread'], ['NewOp'], ['MemberAccessOp', 'SoakedMemberAccessOp', 'DynamicMemberAccessOp', 'SoakedDynamicMemberAccessOp', 'ProtoMemberAccessOp', 'DynamicProtoMemberAccessOp', 'SoakedProtoMemberAccessOp', 'SoakedDynamicProtoMemberAccessOp']];
    precedence = {};
    (function() {
      var level, op, ops, _i, _len, _results;
      _results = [];
      for (level = _i = 0, _len = levels.length; _i < _len; level = ++_i) {
        ops = levels[level];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = ops.length; _j < _len1; _j++) {
            op = ops[_j];
            _results1.push(precedence[op] = level);
          }
          return _results1;
        })());
      }
      return _results;
    })();
    operators = {
      SeqOp: ';',
      LogicalOrOp: 'or',
      LogicalAndOp: 'and',
      BitOrOp: '|',
      BitXorOp: '^',
      BitAndOp: '&',
      EQOp: 'is',
      NEQOp: 'isnt',
      LTOp: '<',
      LTEOp: '<=',
      GTOp: '>',
      GTEOp: '>=',
      InOp: 'in',
      OfOp: 'of',
      InstanceofOp: 'instanceof',
      LeftShiftOp: '<<',
      SignedRightShiftOp: '>>',
      UnsignedRightShiftOp: '>>>',
      PlusOp: '+',
      SubtractOp: '-',
      MultiplyOp: '*',
      DivideOp: '/',
      RemOp: '%',
      UnaryPlusOp: '+',
      UnaryNegateOp: '-',
      LogicalNotOp: 'not ',
      BitNotOp: '~',
      DoOp: 'do ',
      NewOp: 'new ',
      TypeofOp: 'typeof ',
      PreIncrementOp: '++',
      PreDecrementOp: '--',
      UnaryExistsOp: '?',
      ShallowCopyArray: '[..]',
      PostIncrementOp: '++',
      PostDecrementOp: '--',
      Spread: '...',
      FunctionApplication: '',
      SoakedFunctionApplication: '?',
      MemberAccessOp: '.',
      SoakedMemberAccessOp: '?.',
      ProtoMemberAccessOp: '::',
      SoakedProtoMemberAccessOp: '?::',
      DynamicMemberAccessOp: '',
      SoakedDynamicMemberAccessOp: '?',
      DynamicProtoMemberAccessOp: '::',
      SoakedDynamicProtoMemberAccessOp: '?::'
    };
    return exports.generate = generate = function(ast, options) {
      var a, absNum, arg, args, expression_, hasAlternate, i, isMultiline, key_, m, memberAccessOps, members_, needsParens, p, parameters, parent, parentClassName, prec, s, sep, src, usedAsExpression, _alternate, _argList, _args, _assignee, _block, _body, _consequent, _ctor, _expr, _fn, _indexingExpr, _left, _op, _paramList, _ref, _ref1, _right;
      if (options == null) {
        options = {};
      }
      needsParens = false;
      if ((_ref = options.precedence) == null) {
        options.precedence = 0;
      }
      if ((_ref1 = options.ancestors) == null) {
        options.ancestors = [];
      }
      parent = options.ancestors[0];
      parentClassName = parent != null ? parent.className : void 0;
      usedAsExpression = (parent != null) && parentClassName !== 'Block';
      src = (function() {
        var _i, _len, _ref2, _ref3, _ref4, _ref5, _ref6;
        switch (ast.className) {
          case 'Program':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            if (ast.body != null) {
              return generate(ast.body, options);
            } else {
              return '';
            }
            break;
          case 'Block':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: 0
            });
            if (ast.statements.length === 0) {
              return generate((new Undefined).g(), options);
            } else {
              sep = parentClassName === 'Program' ? '\n\n' : '\n';
              return ((function() {
                var _i, _len, _ref2, _results;
                _ref2 = ast.statements;
                _results = [];
                for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                  s = _ref2[_i];
                  _results.push(generate(s, options));
                }
                return _results;
              })()).join(sep);
            }
            break;
          case 'Conditional':
            options.ancestors.unshift(ast);
            options.precedence = 0;
            hasAlternate = (ast.consequent != null) && (ast.alternate != null);
            _consequent = generate((_ref2 = ast.consequent) != null ? _ref2 : (new Undefined).g(), options);
            _alternate = hasAlternate ? generate(ast.alternate, options) : "";
            isMultiline = _consequent.length > 90 || _alternate.length > 90 || __indexOf.call(_alternate, '\n') >= 0 || __indexOf.call(_consequent, '\n') >= 0;
            _consequent = isMultiline ? "\n" + (indent(_consequent)) : " then " + _consequent;
            if (hasAlternate) {
              _alternate = isMultiline ? "\nelse\n" + (indent(_alternate)) : " else " + _alternate;
            }
            return "if " + (generate(ast.condition, options)) + _consequent + _alternate;
          case 'Identifier':
            return ast.data;
          case 'Null':
            return 'null';
          case 'This':
            return 'this';
          case 'Undefined':
            return 'undefined';
          case 'Int':
            absNum = ast.data < 0 ? -ast.data : ast.data;
            if (absNum >= 1e12 || (absNum >= 0x10 && 0 === (absNum & (absNum - 1)))) {
              return "0x" + (ast.data.toString(16));
            } else {
              return ast.data.toString(10);
            }
            break;
          case 'Float':
            return ast.data.toString(10);
          case 'String':
            return "'" + (formatStringData(ast.data)) + "'";
          case 'ArrayInitialiser':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: precedence.AssignmentExpression
            });
            members_ = (function() {
              var _i, _len, _ref3, _results;
              _ref3 = ast.members;
              _results = [];
              for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                m = _ref3[_i];
                _results.push(generate(m, options));
              }
              return _results;
            })();
            switch (ast.members.length) {
              case 0:
                return '[]';
              case 1:
              case 2:
                for (i = _i = 0, _len = members_.length; _i < _len; i = ++_i) {
                  m = members_[i];
                  if (i + 1 !== members_.length) {
                    if (needsParensWhenOnLeft(ast.members[i])) {
                      members_[i] = parens(m);
                    }
                  }
                }
                return "[" + (members_.join(', ')) + "]";
              default:
                return "[\n" + (indent(members_.join('\n'))) + "\n]";
            }
            break;
          case 'ObjectInitialiser':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            members_ = (function() {
              var _j, _len1, _ref3, _results;
              _ref3 = ast.members;
              _results = [];
              for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
                m = _ref3[_j];
                _results.push(generate(m, options));
              }
              return _results;
            })();
            switch (ast.members.length) {
              case 0:
                return '{}';
              case 1:
                return "{" + (members_.join(', ')) + "}";
              default:
                return "{\n" + (indent(members_.join('\n'))) + "\n}";
            }
            break;
          case 'ObjectInitialiserMember':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: precedence.AssignmentExpression
            });
            key_ = generate(ast.key, options);
            expression_ = generate(ast.expression, options);
            memberAccessOps = ['MemberAccessOp', 'ProtoMemberAccessOp', 'SoakedMemberAccessOp', 'SoakedProtoMemberAccessOp'];
            if (eq(ast.key, ast.expression)) {
              return "" + key_;
            } else if ((_ref3 = ast.expression.className, __indexOf.call(memberAccessOps, _ref3) >= 0) && ast.key.data === ast.expression.memberName) {
              return "" + expression_;
            } else {
              return "" + key_ + ": " + expression_;
            }
            break;
          case 'Function':
          case 'BoundFunction':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: precedence.AssignmentExpression
            });
            parameters = (function() {
              var _j, _len1, _ref4, _results;
              _ref4 = ast.parameters;
              _results = [];
              for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
                p = _ref4[_j];
                _results.push(generate(p, options));
              }
              return _results;
            })();
            options.precedence = 0;
            _body = !(ast.body != null) || ast.body.className === 'Undefined' ? '' : generate(ast.body, options);
            _paramList = ast.parameters.length > 0 ? "(" + (parameters.join(', ')) + ") " : '';
            _block = _body.length === 0 ? '' : _paramList.length + _body.length < 100 && __indexOf.call(_body, '\n') < 0 ? " " + _body : "\n" + (indent(_body));
            switch (ast.className) {
              case 'Function':
                return "" + _paramList + "->" + _block;
              case 'BoundFunction':
                return "" + _paramList + "=>" + _block;
            }
            break;
          case 'AssignOp':
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _assignee = generate(ast.assignee, options);
            _expr = generate(ast.expression, options);
            return "" + _assignee + " = " + _expr;
          case 'CompoundAssignOp':
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _op = operators[ast.op.prototype.className];
            _assignee = generate(ast.assignee, options);
            _expr = generate(ast.expression, options);
            return "" + _assignee + " " + _op + "= " + _expr;
          case 'SeqOp':
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _left = generate(ast.left, options);
            _right = generate(ast.right, options);
            return "" + _left + "; " + _right;
          case 'LogicalOrOp':
          case 'LogicalAndOp':
          case 'BitOrOp':
          case 'BitXorOp':
          case 'BitAndOp':
          case 'LeftShiftOp':
          case 'SignedRightShiftOp':
          case 'UnsignedRightShiftOp':
          case 'EQOp':
          case 'NEQOp':
          case 'LTOp':
          case 'LTEOp':
          case 'GTOp':
          case 'GTEOp':
          case 'InOp':
          case 'OfOp':
          case 'InstanceofOp':
          case 'PlusOp':
          case 'SubtractOp':
          case 'MultiplyOp':
          case 'DivideOp':
          case 'RemOp':
          case 'ExistsOp':
            _op = operators[ast.className];
            if (((_ref4 = ast.className) === 'InOp' || _ref4 === 'OfOp' || _ref4 === 'InstanceofOp') && parentClassName === 'LogicalNotOp') {
              _op = "not " + _op;
            }
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _left = generate(ast.left, options);
            if (needsParensWhenOnLeft(ast.left)) {
              _left = parens(_left);
            }
            _right = generate(ast.right, options);
            return "" + _left + " " + _op + " " + _right;
          case 'UnaryPlusOp':
          case 'UnaryNegateOp':
          case 'LogicalNotOp':
          case 'BitNotOp':
          case 'DoOp':
          case 'TypeofOp':
          case 'PreIncrementOp':
          case 'PreDecrementOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            if (ast.className === 'LogicalNotOp') {
              if ((_ref5 = ast.expression.className) === 'InOp' || _ref5 === 'OfOp' || _ref5 === 'InstanceofOp') {
                _op = '';
                prec = precedence[ast.expression.className];
              }
              if ('LogicalNotOp' === parentClassName || 'LogicalNotOp' === ast.expression.className) {
                _op = '!';
              }
            }
            needsParens = prec < options.precedence;
            if (parentClassName === ast.className && ((_ref6 = ast.className) === 'UnaryPlusOp' || _ref6 === 'UnaryNegateOp')) {
              needsParens = true;
            }
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            return "" + _op + (generate(ast.expression, options));
          case 'UnaryExistsOp':
          case 'PostIncrementOp':
          case 'PostDecrementOp':
          case 'Spread':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _expr = generate(ast.expression, options);
            if (needsParensWhenOnLeft(ast.expression)) {
              _expr = parens(_expr);
            }
            return "" + _expr + _op;
          case 'NewOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _ctor = generate(ast.ctor, options);
            if (ast["arguments"].length > 0 && needsParensWhenOnLeft(ast.ctor)) {
              _ctor = parens(_ctor);
            }
            options.precedence = precedence['AssignOp'];
            args = (function() {
              var _j, _len1, _ref7, _results;
              _ref7 = ast["arguments"];
              _results = [];
              for (i = _j = 0, _len1 = _ref7.length; _j < _len1; i = ++_j) {
                a = _ref7[i];
                arg = generate(a, options);
                if ((needsParensWhenOnLeft(a)) && i + 1 !== ast["arguments"].length) {
                  arg = parens(arg);
                }
                _results.push(arg);
              }
              return _results;
            })();
            _args = ast["arguments"].length === 0 ? '' : " " + (args.join(', '));
            return "" + _op + _ctor + _args;
          case 'FunctionApplication':
          case 'SoakedFunctionApplication':
            if (ast.className === 'FunctionApplication' && ast["arguments"].length === 0 && !usedAsExpression) {
              return generate(new DoOp(ast["function"]), options);
            } else {
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: precedence[ast.className]
              });
              _op = operators[ast.className];
              _fn = generate(ast["function"], options);
              if (needsParensWhenOnLeft(ast["function"])) {
                _fn = parens(_fn);
              }
              args = (function() {
                var _j, _len1, _ref7, _results;
                _ref7 = ast["arguments"];
                _results = [];
                for (i = _j = 0, _len1 = _ref7.length; _j < _len1; i = ++_j) {
                  a = _ref7[i];
                  arg = generate(a, options);
                  if ((needsParensWhenOnLeft(a)) && i + 1 !== ast["arguments"].length) {
                    arg = parens(arg);
                  }
                  _results.push(arg);
                }
                return _results;
              })();
              _argList = ast["arguments"].length === 0 ? '()' : " " + (args.join(', '));
              return "" + _fn + _op + _argList;
            }
            break;
          case 'MemberAccessOp':
          case 'SoakedMemberAccessOp':
          case 'ProtoMemberAccessOp':
          case 'SoakedProtoMemberAccessOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            if (ast.expression.className === 'This') {
              _expr = '@';
              if (ast.className === 'MemberAccessOp') {
                _op = '';
              }
            } else {
              _expr = generate(ast.expression, options);
              if (needsParensWhenOnLeft(ast.expression)) {
                _expr = parens(_expr);
              }
            }
            return "" + _expr + _op + ast.memberName;
          case 'DynamicMemberAccessOp':
          case 'SoakedDynamicMemberAccessOp':
          case 'DynamicProtoMemberAccessOp':
          case 'SoakedDynamicProtoMemberAccessOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            if (ast.expression.className === 'This') {
              _expr = '@';
            } else {
              _expr = generate(ast.expression, options);
              if (needsParensWhenOnLeft(ast.expression)) {
                _expr = parens(_expr);
              }
            }
            options.precedence = 0;
            _indexingExpr = generate(ast.indexingExpr, options);
            return "" + _expr + _op + "[" + _indexingExpr + "]";
          case 'ConcatOp':
            _left = formatInterpolation(ast.left, options);
            _right = formatInterpolation(ast.right, options);
            return "\"" + _left + _right + "\"";
          default:
            throw new Error("Non-exhaustive patterns in case: " + ast.className);
        }
      })();
      if (needsParens) {
        return parens(src);
      } else {
        return src;
      }
    };
  })(typeof exports !== "undefined" && exports !== null ? exports : this.cscodegen = {});

}).call(this);

},{}],14:[function(require,module,exports){
(function (global){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*global exports:true, generateStatement:true, generateExpression:true, require:true, global:true*/
(function () {
    'use strict';

    var Syntax,
        Precedence,
        BinaryPrecedence,
        SourceNode,
        estraverse,
        esutils,
        isArray,
        base,
        indent,
        json,
        renumber,
        hexadecimal,
        quotes,
        escapeless,
        newline,
        space,
        parentheses,
        semicolons,
        safeConcatenation,
        directive,
        extra,
        parse,
        sourceMap,
        FORMAT_MINIFY,
        FORMAT_DEFAULTS;

    estraverse = require('estraverse');
    esutils = require('esutils');

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ComprehensionBlock: 'ComprehensionBlock',
        ComprehensionExpression: 'ComprehensionExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExportDeclaration: 'ExportDeclaration',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    Precedence = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Unary: 13,
        Postfix: 14,
        Call: 15,
        New: 16,
        Member: 17,
        Primary: 18
    };

    BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '===': Precedence.Equality,
        '!==': Precedence.Equality,
        'is': Precedence.Equality,
        'isnt': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        'in': Precedence.Relational,
        'instanceof': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '>>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative
    };

    function getDefaultOptions() {
        // default options
        return {
            indent: null,
            base: null,
            parse: null,
            comment: false,
            format: {
                indent: {
                    style: '    ',
                    base: 0,
                    adjustMultilineComment: false
                },
                newline: '\n',
                space: ' ',
                json: false,
                renumber: false,
                hexadecimal: false,
                quotes: 'single',
                escapeless: false,
                compact: false,
                parentheses: true,
                semicolons: true,
                safeConcatenation: false
            },
            moz: {
                comprehensionExpressionStartsWithAssignment: false,
                starlessGenerator: false,
                parenthesizedComprehensionBlock: false
            },
            sourceMap: null,
            sourceMapRoot: null,
            sourceMapWithCode: false,
            directive: false,
            verbatim: null
        };
    }

    function stringRepeat(str, num) {
        var result = '';

        for (num |= 0; num > 0; num >>>= 1, str += str) {
            if (num & 1) {
                result += str;
            }
        }

        return result;
    }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function hasLineTerminator(str) {
        return (/[\r\n]/g).test(str);
    }

    function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
    }

    function updateDeeply(target, override) {
        var key, val;

        function isHashObject(target) {
            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }

        for (key in override) {
            if (override.hasOwnProperty(key)) {
                val = override[key];
                if (isHashObject(val)) {
                    if (isHashObject(target[key])) {
                        updateDeeply(target[key], val);
                    } else {
                        target[key] = updateDeeply({}, val);
                    }
                } else {
                    target[key] = val;
                }
            }
        }
        return target;
    }

    function generateNumber(value) {
        var result, point, temp, exponent, pos;

        if (value !== value) {
            throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || (value === 0 && 1 / value < 0)) {
            throw new Error('Numeric literal whose value is negative');
        }

        if (value === 1 / 0) {
            return json ? 'null' : renumber ? '1e400' : '1e+400';
        }

        result = '' + value;
        if (!renumber || result.length < 3) {
            return result;
        }

        point = result.indexOf('.');
        if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {
            point = 0;
            result = result.slice(1);
        }
        temp = result;
        result = result.replace('e+', 'e');
        exponent = 0;
        if ((pos = temp.indexOf('e')) > 0) {
            exponent = +temp.slice(pos + 1);
            temp = temp.slice(0, pos);
        }
        if (point >= 0) {
            exponent -= temp.length - point - 1;
            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {
            --pos;
        }
        if (pos !== 0) {
            exponent -= pos;
            temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
            temp += 'e' + exponent;
        }
        if ((temp.length < result.length ||
                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
                +temp === value) {
            result = temp;
        }

        return result;
    }

    // Generate valid RegExp expression.
    // This function is based on https://github.com/Constellation/iv Engine

    function escapeRegExpCharacter(ch, previousIsBackslash) {
        // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
        if ((ch & ~1) === 0x2028) {
            return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
        } else if (ch === 10 || ch === 13) {  // \n, \r
            return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
        }
        return String.fromCharCode(ch);
    }

    function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;

        result = reg.toString();

        if (reg.source) {
            // extract flag from toString result
            match = result.match(/\/([^/]*)$/);
            if (!match) {
                return result;
            }

            flags = match[1];
            result = '';

            characterInBrack = false;
            previousIsBackslash = false;
            for (i = 0, iz = reg.source.length; i < iz; ++i) {
                ch = reg.source.charCodeAt(i);

                if (!previousIsBackslash) {
                    if (characterInBrack) {
                        if (ch === 93) {  // ]
                            characterInBrack = false;
                        }
                    } else {
                        if (ch === 47) {  // /
                            result += '\\';
                        } else if (ch === 91) {  // [
                            characterInBrack = true;
                        }
                    }
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    previousIsBackslash = ch === 92;  // \
                } else {
                    // if new RegExp("\\\n') is provided, create /\n/
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    // prevent like /\\[/]/
                    previousIsBackslash = false;
                }
            }

            return '/' + result + '/' + flags;
        }

        return result;
    }

    function escapeAllowedCharacter(code, next) {
        var hex, result = '\\';

        switch (code) {
        case 0x08  /* \b */:
            result += 'b';
            break;
        case 0x0C  /* \f */:
            result += 'f';
            break;
        case 0x09  /* \t */:
            result += 't';
            break;
        default:
            hex = code.toString(16).toUpperCase();
            if (json || code > 0xFF) {
                result += 'u' + '0000'.slice(hex.length) + hex;
            } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
                result += '0';
            } else if (code === 0x000B  /* \v */) { // '\v'
                result += 'x0B';
            } else {
                result += 'x' + '00'.slice(hex.length) + hex;
            }
            break;
        }

        return result;
    }

    function escapeDisallowedCharacter(code) {
        var result = '\\';
        switch (code) {
        case 0x5C  /* \ */:
            result += '\\';
            break;
        case 0x0A  /* \n */:
            result += 'n';
            break;
        case 0x0D  /* \r */:
            result += 'r';
            break;
        case 0x2028:
            result += 'u2028';
            break;
        case 0x2029:
            result += 'u2029';
            break;
        default:
            throw new Error('Incorrectly classified character');
        }

        return result;
    }

    function escapeDirective(str) {
        var i, iz, code, quote;

        quote = quotes === 'double' ? '"' : '\'';
        for (i = 0, iz = str.length; i < iz; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                quote = '"';
                break;
            } else if (code === 0x22  /* " */) {
                quote = '\'';
                break;
            } else if (code === 0x5C  /* \ */) {
                ++i;
            }
        }

        return quote + str + quote;
    }

    function escapeString(str) {
        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                ++singleQuotes;
            } else if (code === 0x22  /* " */) {
                ++doubleQuotes;
            } else if (code === 0x2F  /* / */ && json) {
                result += '\\';
            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \ */) {
                result += escapeDisallowedCharacter(code);
                continue;
            } else if ((json && code < 0x20  /* SP */) || !(json || escapeless || (code >= 0x20  /* SP */ && code <= 0x7E  /* ~ */))) {
                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                continue;
            }
            result += String.fromCharCode(code);
        }

        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
        quote = single ? '\'' : '"';

        if (!(single ? singleQuotes : doubleQuotes)) {
            return quote + result + quote;
        }

        str = result;
        result = quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* " */ && !single)) {
                result += '\\';
            }
            result += String.fromCharCode(code);
        }

        return result + quote;
    }

    /**
     * flatten an array to a string, where the array can contain
     * either strings or nested arrays
     */
    function flattenToString(arr) {
        var i, iz, elem, result = '';
        for (i = 0, iz = arr.length; i < iz; ++i) {
            elem = arr[i];
            result += isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
    }

    /**
     * convert generated to a SourceNode when source maps are enabled.
     */
    function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap) {
            // with no source maps, generated is either an
            // array or a string.  if an array, flatten it.
            // if a string, just return it
            if (isArray(generated)) {
                return flattenToString(generated);
            } else {
                return generated;
            }
        }
        if (node == null) {
            if (generated instanceof SourceNode) {
                return generated;
            } else {
                node = {};
            }
        }
        if (node.loc == null) {
            return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
    }

    function noEmptySpace() {
        return (space) ? space : ' ';
    }

    function join(left, right) {
        var leftSource = toSourceNodeWhenNeeded(left).toString(),
            rightSource = toSourceNodeWhenNeeded(right).toString(),
            leftCharCode = leftSource.charCodeAt(leftSource.length - 1),
            rightCharCode = rightSource.charCodeAt(0);

        if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||
        esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode) ||
        leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`
            return [left, noEmptySpace(), right];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||
                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
            return [left, right];
        }
        return [left, space, right];
    }

    function addIndent(stmt) {
        return [base, stmt];
    }

    function withIndent(fn) {
        var previousBase, result;
        previousBase = base;
        base += indent;
        result = fn.call(this, base);
        base = previousBase;
        return result;
    }

    function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
                break;
            }
        }
        return (str.length - 1) - i;
    }

    function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase, sn;

        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;

        // first line doesn't have indentation
        for (i = 1, len = array.length; i < len; ++i) {
            line = array[i];
            j = 0;
            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
                ++j;
            }
            if (spaces > j) {
                spaces = j;
            }
        }

        if (typeof specialBase !== 'undefined') {
            // pattern like
            // {
            //   var t = 20;  /*
            //                 * this is comment
            //                 */
            // }
            previousBase = base;
            if (array[1][spaces] === '*') {
                specialBase += ' ';
            }
            base = specialBase;
        } else {
            if (spaces & 1) {
                // /*
                //  *
                //  */
                // If spaces are odd number, above pattern is considered.
                // We waste 1 space.
                --spaces;
            }
            previousBase = base;
        }

        for (i = 1, len = array.length; i < len; ++i) {
            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
            array[i] = sourceMap ? sn.join('') : sn;
        }

        base = previousBase;

        return array.join('\n');
    }

    function generateComment(comment, specialBase) {
        if (comment.type === 'Line') {
            if (endsWithLineTerminator(comment.value)) {
                return '//' + comment.value;
            } else {
                // Always use LineTerminator
                return '//' + comment.value + '\n';
            }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
        }
        return '/*' + comment.value + '*/';
    }

    function addCommentsToStatement(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment;

        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
            save = result;

            comment = stmt.leadingComments[0];
            result = [];
            if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                result.push('\n');
            }
            result.push(generateComment(comment));
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push('\n');
            }

            for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
                comment = stmt.leadingComments[i];
                fragment = [generateComment(comment)];
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    fragment.push('\n');
                }
                result.push(addIndent(fragment));
            }

            result.push(addIndent(save));
        }

        if (stmt.trailingComments) {
            tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
            specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
            for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
                comment = stmt.trailingComments[i];
                if (tailingToStatement) {
                    // We assume target like following script
                    //
                    // var t = 20;  /**
                    //               * This is comment of t
                    //               */
                    if (i === 0) {
                        // first case
                        result = [result, indent];
                    } else {
                        result = [result, specialBase];
                    }
                    result.push(generateComment(comment, specialBase));
                } else {
                    result = [result, addIndent(generateComment(comment))];
                }
                if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result = [result, '\n'];
                }
            }
        }

        return result;
    }

    function parenthesize(text, current, should) {
        if (current < should) {
            return ['(', text, ')'];
        }
        return text;
    }

    function maybeBlock(stmt, semicolonOptional, functionBody) {
        var result, noLeadingComment;

        noLeadingComment = !extra.comment || !stmt.leadingComments;

        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
            return [space, generateStatement(stmt, { functionBody: functionBody })];
        }

        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
            return ';';
        }

        withIndent(function () {
            result = [newline, addIndent(generateStatement(stmt, { semicolonOptional: semicolonOptional, functionBody: functionBody }))];
        });

        return result;
    }

    function maybeBlockSuffix(stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
            return [result, space];
        }
        if (ends) {
            return [result, base];
        }
        return [result, newline, base];
    }

    function generateVerbatim(expr, option) {
        var i, result;
        result = expr[extra.verbatim].split(/\r\n|\n/);
        for (i = 1; i < result.length; i++) {
            result[i] = newline + base + result[i];
        }

        result = parenthesize(result, Precedence.Sequence, option.precedence);
        return toSourceNodeWhenNeeded(result, expr);
    }

    function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
    }

    function generatePattern(node, options) {
        var result;

        if (node.type === Syntax.Identifier) {
            result = generateIdentifier(node);
        } else {
            result = generateExpression(node, {
                precedence: options.precedence,
                allowIn: options.allowIn,
                allowCall: true
            });
        }

        return result;
    }

    function generateFunctionBody(node) {
        var result, i, len, expr, arrow;

        arrow = node.type === Syntax.ArrowFunctionExpression;

        if (arrow && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
            // arg => { } case
            result = [generateIdentifier(node.params[0])];
        } else {
            result = ['('];
            for (i = 0, len = node.params.length; i < len; ++i) {
                result.push(generatePattern(node.params[i], {
                    precedence: Precedence.Assignment,
                    allowIn: true
                }));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result.push(')');
        }

        if (arrow) {
            result.push(space);
            result.push('=>');
        }

        if (node.expression) {
            result.push(space);
            expr = generateExpression(node.body, {
                precedence: Precedence.Assignment,
                allowIn: true,
                allowCall: true
            });
            if (expr.toString().charAt(0) === '{') {
                expr = ['(', expr, ')'];
            }
            result.push(expr);
        } else {
            result.push(maybeBlock(node.body, false, true));
        }
        return result;
    }

    function generateIterationForStatement(operator, stmt, semicolonIsNotNeeded) {
        var result = ['for' + space + '('];
        withIndent(function () {
            if (stmt.left.type === Syntax.VariableDeclaration) {
                withIndent(function () {
                    result.push(stmt.left.kind + noEmptySpace());
                    result.push(generateStatement(stmt.left.declarations[0], {
                        allowIn: false
                    }));
                });
            } else {
                result.push(generateExpression(stmt.left, {
                    precedence: Precedence.Call,
                    allowIn: true,
                    allowCall: true
                }));
            }

            result = join(result, operator);
            result = [join(
                result,
                generateExpression(stmt.right, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                })
            ), ')'];
        });
        result.push(maybeBlock(stmt.body, semicolonIsNotNeeded));
        return result;
    }

    function generateExpression(expr, option) {
        var result,
            precedence,
            type,
            currentPrecedence,
            i,
            len,
            raw,
            fragment,
            multiline,
            leftCharCode,
            leftSource,
            rightCharCode,
            allowIn,
            allowCall,
            allowUnparenthesizedNew,
            property,
            isGenerator;

        precedence = option.precedence;
        allowIn = option.allowIn;
        allowCall = option.allowCall;
        type = expr.type || option.type;

        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
            return generateVerbatim(expr, option);
        }

        switch (type) {
        case Syntax.SequenceExpression:
            result = [];
            allowIn |= (Precedence.Sequence < precedence);
            for (i = 0, len = expr.expressions.length; i < len; ++i) {
                result.push(generateExpression(expr.expressions[i], {
                    precedence: Precedence.Assignment,
                    allowIn: allowIn,
                    allowCall: true
                }));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result = parenthesize(result, Precedence.Sequence, precedence);
            break;

        case Syntax.AssignmentExpression:
            allowIn |= (Precedence.Assignment < precedence);
            result = parenthesize(
                [
                    generateExpression(expr.left, {
                        precedence: Precedence.Call,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + expr.operator + space,
                    generateExpression(expr.right, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ],
                Precedence.Assignment,
                precedence
            );
            break;

        case Syntax.ArrowFunctionExpression:
            allowIn |= (Precedence.ArrowFunction < precedence);
            result = parenthesize(generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
            break;

        case Syntax.ConditionalExpression:
            allowIn |= (Precedence.Conditional < precedence);
            result = parenthesize(
                [
                    generateExpression(expr.test, {
                        precedence: Precedence.LogicalOR,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + '?' + space,
                    generateExpression(expr.consequent, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + ':' + space,
                    generateExpression(expr.alternate, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ],
                Precedence.Conditional,
                precedence
            );
            break;

        case Syntax.LogicalExpression:
        case Syntax.BinaryExpression:
            currentPrecedence = BinaryPrecedence[expr.operator];

            allowIn |= (currentPrecedence < precedence);

            fragment = generateExpression(expr.left, {
                precedence: currentPrecedence,
                allowIn: allowIn,
                allowCall: true
            });

            leftSource = fragment.toString();

            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPart(expr.operator.charCodeAt(0))) {
                result = [fragment, noEmptySpace(), expr.operator];
            } else {
                result = join(fragment, expr.operator);
            }

            fragment = generateExpression(expr.right, {
                precedence: currentPrecedence + 1,
                allowIn: allowIn,
                allowCall: true
            });

            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
                result.push(noEmptySpace());
                result.push(fragment);
            } else {
                result = join(result, fragment);
            }

            if (expr.operator === 'in' && !allowIn) {
                result = ['(', result, ')'];
            } else {
                result = parenthesize(result, currentPrecedence, precedence);
            }

            break;

        case Syntax.CallExpression:
            result = [generateExpression(expr.callee, {
                precedence: Precedence.Call,
                allowIn: true,
                allowCall: true,
                allowUnparenthesizedNew: false
            })];

            result.push('(');
            for (i = 0, len = expr['arguments'].length; i < len; ++i) {
                result.push(generateExpression(expr['arguments'][i], {
                    precedence: Precedence.Assignment,
                    allowIn: true,
                    allowCall: true
                }));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result.push(')');

            if (!allowCall) {
                result = ['(', result, ')'];
            } else {
                result = parenthesize(result, Precedence.Call, precedence);
            }
            break;

        case Syntax.NewExpression:
            len = expr['arguments'].length;
            allowUnparenthesizedNew = option.allowUnparenthesizedNew === undefined || option.allowUnparenthesizedNew;

            result = join(
                'new',
                generateExpression(expr.callee, {
                    precedence: Precedence.New,
                    allowIn: true,
                    allowCall: false,
                    allowUnparenthesizedNew: allowUnparenthesizedNew && !parentheses && len === 0
                })
            );

            if (!allowUnparenthesizedNew || parentheses || len > 0) {
                result.push('(');
                for (i = 0; i < len; ++i) {
                    result.push(generateExpression(expr['arguments'][i], {
                        precedence: Precedence.Assignment,
                        allowIn: true,
                        allowCall: true
                    }));
                    if (i + 1 < len) {
                        result.push(',' + space);
                    }
                }
                result.push(')');
            }

            result = parenthesize(result, Precedence.New, precedence);
            break;

        case Syntax.MemberExpression:
            result = [generateExpression(expr.object, {
                precedence: Precedence.Call,
                allowIn: true,
                allowCall: allowCall,
                allowUnparenthesizedNew: false
            })];

            if (expr.computed) {
                result.push('[');
                result.push(generateExpression(expr.property, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: allowCall
                }));
                result.push(']');
            } else {
                if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                    fragment = toSourceNodeWhenNeeded(result).toString();
                    // When the following conditions are all true,
                    //   1. No floating point
                    //   2. Don't have exponents
                    //   3. The last character is a decimal digit
                    //   4. Not hexadecimal OR octal number literal
                    // we should add a floating point.
                    if (
                            fragment.indexOf('.') < 0 &&
                            !/[eExX]/.test(fragment) &&
                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'
                            ) {
                        result.push('.');
                    }
                }
                result.push('.');
                result.push(generateIdentifier(expr.property));
            }

            result = parenthesize(result, Precedence.Member, precedence);
            break;

        case Syntax.UnaryExpression:
            fragment = generateExpression(expr.argument, {
                precedence: Precedence.Unary,
                allowIn: true,
                allowCall: true
            });

            if (space === '') {
                result = join(expr.operator, fragment);
            } else {
                result = [expr.operator];
                if (expr.operator.length > 2) {
                    // delete, void, typeof
                    // get `typeof []`, not `typeof[]`
                    result = join(result, fragment);
                } else {
                    // Prevent inserting spaces between operator and argument if it is unnecessary
                    // like, `!cond`
                    leftSource = toSourceNodeWhenNeeded(result).toString();
                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                    rightCharCode = fragment.toString().charCodeAt(0);

                    if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||
                            (esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode))) {
                        result.push(noEmptySpace());
                        result.push(fragment);
                    } else {
                        result.push(fragment);
                    }
                }
            }
            result = parenthesize(result, Precedence.Unary, precedence);
            break;

        case Syntax.YieldExpression:
            if (expr.delegate) {
                result = 'yield*';
            } else {
                result = 'yield';
            }
            if (expr.argument) {
                result = join(
                    result,
                    generateExpression(expr.argument, {
                        precedence: Precedence.Yield,
                        allowIn: true,
                        allowCall: true
                    })
                );
            }
            result = parenthesize(result, Precedence.Yield, precedence);
            break;

        case Syntax.UpdateExpression:
            if (expr.prefix) {
                result = parenthesize(
                    [
                        expr.operator,
                        generateExpression(expr.argument, {
                            precedence: Precedence.Unary,
                            allowIn: true,
                            allowCall: true
                        })
                    ],
                    Precedence.Unary,
                    precedence
                );
            } else {
                result = parenthesize(
                    [
                        generateExpression(expr.argument, {
                            precedence: Precedence.Postfix,
                            allowIn: true,
                            allowCall: true
                        }),
                        expr.operator
                    ],
                    Precedence.Postfix,
                    precedence
                );
            }
            break;

        case Syntax.FunctionExpression:
            isGenerator = expr.generator && !extra.moz.starlessGenerator;
            result = isGenerator ? 'function*' : 'function';

            if (expr.id) {
                result = [result, (isGenerator) ? space : noEmptySpace(),
                          generateIdentifier(expr.id),
                          generateFunctionBody(expr)];
            } else {
                result = [result + space, generateFunctionBody(expr)];
            }

            break;

        case Syntax.ArrayPattern:
        case Syntax.ArrayExpression:
            if (!expr.elements.length) {
                result = '[]';
                break;
            }
            multiline = expr.elements.length > 1;
            result = ['[', multiline ? newline : ''];
            withIndent(function (indent) {
                for (i = 0, len = expr.elements.length; i < len; ++i) {
                    if (!expr.elements[i]) {
                        if (multiline) {
                            result.push(indent);
                        }
                        if (i + 1 === len) {
                            result.push(',');
                        }
                    } else {
                        result.push(multiline ? indent : '');
                        result.push(generateExpression(expr.elements[i], {
                            precedence: Precedence.Assignment,
                            allowIn: true,
                            allowCall: true
                        }));
                    }
                    if (i + 1 < len) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });
            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push(']');
            break;

        case Syntax.Property:
            if (expr.kind === 'get' || expr.kind === 'set') {
                result = [
                    expr.kind, noEmptySpace(),
                    generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    generateFunctionBody(expr.value)
                ];
            } else {
                if (expr.shorthand) {
                    result = generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    });
                } else if (expr.method) {
                    result = [];
                    if (expr.value.generator) {
                        result.push('*');
                    }
                    result.push(generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }));
                    result.push(generateFunctionBody(expr.value));
                } else {
                    result = [
                        generateExpression(expr.key, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        }),
                        ':' + space,
                        generateExpression(expr.value, {
                            precedence: Precedence.Assignment,
                            allowIn: true,
                            allowCall: true
                        })
                    ];
                }
            }
            break;

        case Syntax.ObjectExpression:
            if (!expr.properties.length) {
                result = '{}';
                break;
            }
            multiline = expr.properties.length > 1;

            withIndent(function () {
                fragment = generateExpression(expr.properties[0], {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true,
                    type: Syntax.Property
                });
            });

            if (!multiline) {
                // issues 4
                // Do not transform from
                //   dejavu.Class.declare({
                //       method2: function () {}
                //   });
                // to
                //   dejavu.Class.declare({method2: function () {
                //       }});
                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    result = [ '{', space, fragment, space, '}' ];
                    break;
                }
            }

            withIndent(function (indent) {
                result = [ '{', newline, indent, fragment ];

                if (multiline) {
                    result.push(',' + newline);
                    for (i = 1, len = expr.properties.length; i < len; ++i) {
                        result.push(indent);
                        result.push(generateExpression(expr.properties[i], {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true,
                            type: Syntax.Property
                        }));
                        if (i + 1 < len) {
                            result.push(',' + newline);
                        }
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            break;

        case Syntax.ObjectPattern:
            if (!expr.properties.length) {
                result = '{}';
                break;
            }

            multiline = false;
            if (expr.properties.length === 1) {
                property = expr.properties[0];
                if (property.value.type !== Syntax.Identifier) {
                    multiline = true;
                }
            } else {
                for (i = 0, len = expr.properties.length; i < len; ++i) {
                    property = expr.properties[i];
                    if (!property.shorthand) {
                        multiline = true;
                        break;
                    }
                }
            }
            result = ['{', multiline ? newline : '' ];

            withIndent(function (indent) {
                for (i = 0, len = expr.properties.length; i < len; ++i) {
                    result.push(multiline ? indent : '');
                    result.push(generateExpression(expr.properties[i], {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }));
                    if (i + 1 < len) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });

            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push('}');
            break;

        case Syntax.ThisExpression:
            result = 'this';
            break;

        case Syntax.Identifier:
            result = generateIdentifier(expr);
            break;

        case Syntax.Literal:
            if (expr.hasOwnProperty('raw') && parse) {
                try {
                    raw = parse(expr.raw).body[0].expression;
                    if (raw.type === Syntax.Literal) {
                        if (raw.value === expr.value) {
                            result = expr.raw;
                            break;
                        }
                    }
                } catch (e) {
                    // not use raw property
                }
            }

            if (expr.value === null) {
                result = 'null';
                break;
            }

            if (typeof expr.value === 'string') {
                result = escapeString(expr.value);
                break;
            }

            if (typeof expr.value === 'number') {
                result = generateNumber(expr.value);
                break;
            }

            if (typeof expr.value === 'boolean') {
                result = expr.value ? 'true' : 'false';
                break;
            }

            result = generateRegExp(expr.value);
            break;

        case Syntax.GeneratorExpression:
        case Syntax.ComprehensionExpression:
            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]
            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6
            result = (type === Syntax.GeneratorExpression) ? ['('] : ['['];

            if (extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = generateExpression(expr.body, {
                    precedence: Precedence.Assignment,
                    allowIn: true,
                    allowCall: true
                });

                result.push(fragment);
            }

            if (expr.blocks) {
                withIndent(function () {
                    for (i = 0, len = expr.blocks.length; i < len; ++i) {
                        fragment = generateExpression(expr.blocks[i], {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        });

                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                            result = join(result, fragment);
                        } else {
                            result.push(fragment);
                        }
                    }
                });
            }

            if (expr.filter) {
                result = join(result, 'if' + space);
                fragment = generateExpression(expr.filter, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                });
                if (extra.moz.parenthesizedComprehensionBlock) {
                    result = join(result, [ '(', fragment, ')' ]);
                } else {
                    result = join(result, fragment);
                }
            }

            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = generateExpression(expr.body, {
                    precedence: Precedence.Assignment,
                    allowIn: true,
                    allowCall: true
                });

                result = join(result, fragment);
            }

            result.push((type === Syntax.GeneratorExpression) ? ')' : ']');
            break;

        case Syntax.ComprehensionBlock:
            if (expr.left.type === Syntax.VariableDeclaration) {
                fragment = [
                    expr.left.kind, noEmptySpace(),
                    generateStatement(expr.left.declarations[0], {
                        allowIn: false
                    })
                ];
            } else {
                fragment = generateExpression(expr.left, {
                    precedence: Precedence.Call,
                    allowIn: true,
                    allowCall: true
                });
            }

            fragment = join(fragment, expr.of ? 'of' : 'in');
            fragment = join(fragment, generateExpression(expr.right, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            }));

            if (extra.moz.parenthesizedComprehensionBlock) {
                result = [ 'for' + space + '(', fragment, ')' ];
            } else {
                result = join('for' + space, fragment);
            }
            break;

        default:
            throw new Error('Unknown expression type: ' + expr.type);
        }

        return toSourceNodeWhenNeeded(result, expr);
    }

    function generateStatement(stmt, option) {
        var i,
            len,
            result,
            node,
            allowIn,
            functionBody,
            directiveContext,
            fragment,
            semicolon,
            isGenerator;

        allowIn = true;
        semicolon = ';';
        functionBody = false;
        directiveContext = false;
        if (option) {
            allowIn = option.allowIn === undefined || option.allowIn;
            if (!semicolons && option.semicolonOptional === true) {
                semicolon = '';
            }
            functionBody = option.functionBody;
            directiveContext = option.directiveContext;
        }

        switch (stmt.type) {
        case Syntax.BlockStatement:
            result = ['{', newline];

            withIndent(function () {
                for (i = 0, len = stmt.body.length; i < len; ++i) {
                    fragment = addIndent(generateStatement(stmt.body[i], {
                        semicolonOptional: i === len - 1,
                        directiveContext: functionBody
                    }));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });

            result.push(addIndent('}'));
            break;

        case Syntax.BreakStatement:
            if (stmt.label) {
                result = 'break ' + stmt.label.name + semicolon;
            } else {
                result = 'break' + semicolon;
            }
            break;

        case Syntax.ContinueStatement:
            if (stmt.label) {
                result = 'continue ' + stmt.label.name + semicolon;
            } else {
                result = 'continue' + semicolon;
            }
            break;

        case Syntax.DirectiveStatement:
            if (stmt.raw) {
                result = stmt.raw + semicolon;
            } else {
                result = escapeDirective(stmt.directive) + semicolon;
            }
            break;

        case Syntax.DoWhileStatement:
            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
            result = join('do', maybeBlock(stmt.body));
            result = maybeBlockSuffix(stmt.body, result);
            result = join(result, [
                'while' + space + '(',
                generateExpression(stmt.test, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                }),
                ')' + semicolon
            ]);
            break;

        case Syntax.CatchClause:
            withIndent(function () {
                var guard;

                result = [
                    'catch' + space + '(',
                    generateExpression(stmt.param, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];

                if (stmt.guard) {
                    guard = generateExpression(stmt.guard, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    });

                    result.splice(2, 0, ' if ', guard);
                }
            });
            result.push(maybeBlock(stmt.body));
            break;

        case Syntax.DebuggerStatement:
            result = 'debugger' + semicolon;
            break;

        case Syntax.EmptyStatement:
            result = ';';
            break;

        case Syntax.ExportDeclaration:
            result = 'export ';
            if (stmt.declaration) {
                // FunctionDeclaration or VariableDeclaration
                result = [result, generateStatement(stmt.declaration, { semicolonOptional: semicolon === '' })];
                break;
            }
            break;

        case Syntax.ExpressionStatement:
            result = [generateExpression(stmt.expression, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            })];
            // 12.4 '{', 'function' is not allowed in this position.
            // wrap expression with parentheses
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (fragment.charAt(0) === '{' ||  // ObjectExpression
                    (fragment.slice(0, 8) === 'function' && '* ('.indexOf(fragment.charAt(8)) >= 0) ||  // function or generator
                    (directive && directiveContext && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
                result = ['(', result, ')' + semicolon];
            } else {
                result.push(semicolon);
            }
            break;

        case Syntax.VariableDeclarator:
            if (stmt.init) {
                result = [
                    generateExpression(stmt.id, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space,
                    '=',
                    space,
                    generateExpression(stmt.init, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ];
            } else {
                result = generatePattern(stmt.id, {
                    precedence: Precedence.Assignment,
                    allowIn: allowIn
                });
            }
            break;

        case Syntax.VariableDeclaration:
            result = [stmt.kind];
            // special path for
            // var x = function () {
            // };
            if (stmt.declarations.length === 1 && stmt.declarations[0].init &&
                    stmt.declarations[0].init.type === Syntax.FunctionExpression) {
                result.push(noEmptySpace());
                result.push(generateStatement(stmt.declarations[0], {
                    allowIn: allowIn
                }));
            } else {
                // VariableDeclarator is typed as Statement,
                // but joined with comma (not LineTerminator).
                // So if comment is attached to target node, we should specialize.
                withIndent(function () {
                    node = stmt.declarations[0];
                    if (extra.comment && node.leadingComments) {
                        result.push('\n');
                        result.push(addIndent(generateStatement(node, {
                            allowIn: allowIn
                        })));
                    } else {
                        result.push(noEmptySpace());
                        result.push(generateStatement(node, {
                            allowIn: allowIn
                        }));
                    }

                    for (i = 1, len = stmt.declarations.length; i < len; ++i) {
                        node = stmt.declarations[i];
                        if (extra.comment && node.leadingComments) {
                            result.push(',' + newline);
                            result.push(addIndent(generateStatement(node, {
                                allowIn: allowIn
                            })));
                        } else {
                            result.push(',' + space);
                            result.push(generateStatement(node, {
                                allowIn: allowIn
                            }));
                        }
                    }
                });
            }
            result.push(semicolon);
            break;

        case Syntax.ThrowStatement:
            result = [join(
                'throw',
                generateExpression(stmt.argument, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                })
            ), semicolon];
            break;

        case Syntax.TryStatement:
            result = ['try', maybeBlock(stmt.block)];
            result = maybeBlockSuffix(stmt.block, result);

            if (stmt.handlers) {
                // old interface
                for (i = 0, len = stmt.handlers.length; i < len; ++i) {
                    result = join(result, generateStatement(stmt.handlers[i]));
                    if (stmt.finalizer || i + 1 !== len) {
                        result = maybeBlockSuffix(stmt.handlers[i].body, result);
                    }
                }
            } else {
                stmt.guardedHandlers = stmt.guardedHandlers || [];

                for (i = 0, len = stmt.guardedHandlers.length; i < len; ++i) {
                    result = join(result, generateStatement(stmt.guardedHandlers[i]));
                    if (stmt.finalizer || i + 1 !== len) {
                        result = maybeBlockSuffix(stmt.guardedHandlers[i].body, result);
                    }
                }

                // new interface
                if (stmt.handler) {
                    if (isArray(stmt.handler)) {
                        for (i = 0, len = stmt.handler.length; i < len; ++i) {
                            result = join(result, generateStatement(stmt.handler[i]));
                            if (stmt.finalizer || i + 1 !== len) {
                                result = maybeBlockSuffix(stmt.handler[i].body, result);
                            }
                        }
                    } else {
                        result = join(result, generateStatement(stmt.handler));
                        if (stmt.finalizer) {
                            result = maybeBlockSuffix(stmt.handler.body, result);
                        }
                    }
                }
            }
            if (stmt.finalizer) {
                result = join(result, ['finally', maybeBlock(stmt.finalizer)]);
            }
            break;

        case Syntax.SwitchStatement:
            withIndent(function () {
                result = [
                    'switch' + space + '(',
                    generateExpression(stmt.discriminant, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')' + space + '{' + newline
                ];
            });
            if (stmt.cases) {
                for (i = 0, len = stmt.cases.length; i < len; ++i) {
                    fragment = addIndent(generateStatement(stmt.cases[i], {semicolonOptional: i === len - 1}));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            }
            result.push(addIndent('}'));
            break;

        case Syntax.SwitchCase:
            withIndent(function () {
                if (stmt.test) {
                    result = [
                        join('case', generateExpression(stmt.test, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        })),
                        ':'
                    ];
                } else {
                    result = ['default:'];
                }

                i = 0;
                len = stmt.consequent.length;
                if (len && stmt.consequent[0].type === Syntax.BlockStatement) {
                    fragment = maybeBlock(stmt.consequent[0]);
                    result.push(fragment);
                    i = 1;
                }

                if (i !== len && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                }

                for (; i < len; ++i) {
                    fragment = addIndent(generateStatement(stmt.consequent[i], {semicolonOptional: i === len - 1 && semicolon === ''}));
                    result.push(fragment);
                    if (i + 1 !== len && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });
            break;

        case Syntax.IfStatement:
            withIndent(function () {
                result = [
                    'if' + space + '(',
                    generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            if (stmt.alternate) {
                result.push(maybeBlock(stmt.consequent));
                result = maybeBlockSuffix(stmt.consequent, result);
                if (stmt.alternate.type === Syntax.IfStatement) {
                    result = join(result, ['else ', generateStatement(stmt.alternate, {semicolonOptional: semicolon === ''})]);
                } else {
                    result = join(result, join('else', maybeBlock(stmt.alternate, semicolon === '')));
                }
            } else {
                result.push(maybeBlock(stmt.consequent, semicolon === ''));
            }
            break;

        case Syntax.ForStatement:
            withIndent(function () {
                result = ['for' + space + '('];
                if (stmt.init) {
                    if (stmt.init.type === Syntax.VariableDeclaration) {
                        result.push(generateStatement(stmt.init, {allowIn: false}));
                    } else {
                        result.push(generateExpression(stmt.init, {
                            precedence: Precedence.Sequence,
                            allowIn: false,
                            allowCall: true
                        }));
                        result.push(';');
                    }
                } else {
                    result.push(';');
                }

                if (stmt.test) {
                    result.push(space);
                    result.push(generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }));
                    result.push(';');
                } else {
                    result.push(';');
                }

                if (stmt.update) {
                    result.push(space);
                    result.push(generateExpression(stmt.update, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }));
                    result.push(')');
                } else {
                    result.push(')');
                }
            });

            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        case Syntax.ForInStatement:
            result = generateIterationForStatement('in', stmt, semicolon === '');
            break;

        case Syntax.ForOfStatement:
            result = generateIterationForStatement('of', stmt, semicolon === '');
            break;

        case Syntax.LabeledStatement:
            result = [stmt.label.name + ':', maybeBlock(stmt.body, semicolon === '')];
            break;

        case Syntax.Program:
            len = stmt.body.length;
            result = [safeConcatenation && len > 0 ? '\n' : ''];
            for (i = 0; i < len; ++i) {
                fragment = addIndent(
                    generateStatement(stmt.body[i], {
                        semicolonOptional: !safeConcatenation && i === len - 1,
                        directiveContext: true
                    })
                );
                result.push(fragment);
                if (i + 1 < len && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    result.push(newline);
                }
            }
            break;

        case Syntax.FunctionDeclaration:
            isGenerator = stmt.generator && !extra.moz.starlessGenerator;
            result = [
                (isGenerator ? 'function*' : 'function'),
                (isGenerator ? space : noEmptySpace()),
                generateIdentifier(stmt.id),
                generateFunctionBody(stmt)
            ];
            break;

        case Syntax.ReturnStatement:
            if (stmt.argument) {
                result = [join(
                    'return',
                    generateExpression(stmt.argument, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    })
                ), semicolon];
            } else {
                result = ['return' + semicolon];
            }
            break;

        case Syntax.WhileStatement:
            withIndent(function () {
                result = [
                    'while' + space + '(',
                    generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        case Syntax.WithStatement:
            withIndent(function () {
                result = [
                    'with' + space + '(',
                    generateExpression(stmt.object, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        default:
            throw new Error('Unknown statement type: ' + stmt.type);
        }

        // Attach comments

        if (extra.comment) {
            result = addCommentsToStatement(stmt, result);
        }

        fragment = toSourceNodeWhenNeeded(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
        }

        return toSourceNodeWhenNeeded(result, stmt);
    }

    function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;

        if (options != null) {
            // Obsolete options
            //
            //   `options.indent`
            //   `options.base`
            //
            // Instead of them, we can use `option.format.indent`.
            if (typeof options.indent === 'string') {
                defaultOptions.format.indent.style = options.indent;
            }
            if (typeof options.base === 'number') {
                defaultOptions.format.indent.base = options.base;
            }
            options = updateDeeply(defaultOptions, options);
            indent = options.format.indent.style;
            if (typeof options.base === 'string') {
                base = options.base;
            } else {
                base = stringRepeat(indent, options.format.indent.base);
            }
        } else {
            options = defaultOptions;
            indent = options.format.indent.style;
            base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? 'double' : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
            newline = space = indent = base = '';
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        extra = options;

        if (sourceMap) {
            if (!exports.browser) {
                // We assume environment is node.js
                // And prevent from including source-map by browserify
                SourceNode = require('source-map').SourceNode;
            } else {
                SourceNode = global.sourceMap.SourceNode;
            }
        }

        switch (node.type) {
        case Syntax.BlockStatement:
        case Syntax.BreakStatement:
        case Syntax.CatchClause:
        case Syntax.ContinueStatement:
        case Syntax.DirectiveStatement:
        case Syntax.DoWhileStatement:
        case Syntax.DebuggerStatement:
        case Syntax.EmptyStatement:
        case Syntax.ExpressionStatement:
        case Syntax.ForStatement:
        case Syntax.ForInStatement:
        case Syntax.ForOfStatement:
        case Syntax.FunctionDeclaration:
        case Syntax.IfStatement:
        case Syntax.LabeledStatement:
        case Syntax.Program:
        case Syntax.ReturnStatement:
        case Syntax.SwitchStatement:
        case Syntax.SwitchCase:
        case Syntax.ThrowStatement:
        case Syntax.TryStatement:
        case Syntax.VariableDeclaration:
        case Syntax.VariableDeclarator:
        case Syntax.WhileStatement:
        case Syntax.WithStatement:
            result = generateStatement(node);
            break;

        case Syntax.AssignmentExpression:
        case Syntax.ArrayExpression:
        case Syntax.ArrayPattern:
        case Syntax.BinaryExpression:
        case Syntax.CallExpression:
        case Syntax.ConditionalExpression:
        case Syntax.FunctionExpression:
        case Syntax.Identifier:
        case Syntax.Literal:
        case Syntax.LogicalExpression:
        case Syntax.MemberExpression:
        case Syntax.NewExpression:
        case Syntax.ObjectExpression:
        case Syntax.ObjectPattern:
        case Syntax.Property:
        case Syntax.SequenceExpression:
        case Syntax.ThisExpression:
        case Syntax.UnaryExpression:
        case Syntax.UpdateExpression:
        case Syntax.YieldExpression:

            result = generateExpression(node, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            });
            break;

        default:
            throw new Error('Unknown node type: ' + node.type);
        }

        if (!sourceMap) {
            return result.toString();
        }


        pair = result.toStringWithSourceMap({
            file: options.file,
            sourceRoot: options.sourceMapRoot
        });

        if (options.sourceContent) {
            pair.map.setSourceContent(options.sourceMap,
                                      options.sourceContent);
        }

        if (options.sourceMapWithCode) {
            return pair;
        }

        return pair.map.toString();
    }

    FORMAT_MINIFY = {
        indent: {
            style: '',
            base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: 'auto',
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
    };

    FORMAT_DEFAULTS = getDefaultOptions().format;

    exports.version = require('./package.json').version;
    exports.generate = generate;
    exports.attachComments = estraverse.attachComments;
    exports.browser = false;
    exports.FORMAT_MINIFY = FORMAT_MINIFY;
    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
}());
/* vim: set sw=4 ts=4 et tw=80 : */

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./package.json":18,"estraverse":31,"esutils":17,"source-map":19}],15:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var Regex;

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return isDecimalDigit(ch) || (97 <= ch && ch <= 102) || (65 <= ch && ch <= 70);
    }

    function isOctalDigit(ch) {
        return (ch >= 48 && ch <= 55);   // 0..7
    }

    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch >= 48 && ch <= 57) ||         // 0..9
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStart: isIdentifierStart,
        isIdentifierPart: isIdentifierPart
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],16:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierName(id) {
        var i, iz, ch;

        if (id.length === 0) {
            return false;
        }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStart(ch) || ch === 92) {  // \ (backslash)
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPart(ch) || ch === 92) {  // \ (backslash)
                return false;
            }
        }
        return true;
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierName: isIdentifierName
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":15}],17:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.code = require('./code');
    exports.keyword = require('./keyword');
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":15,"./keyword":16}],18:[function(require,module,exports){
module.exports={
  "name": "escodegen",
  "description": "ECMAScript code generator",
  "homepage": "http://github.com/Constellation/escodegen",
  "main": "escodegen.js",
  "bin": {
    "esgenerate": "./bin/esgenerate.js",
    "escodegen": "./bin/escodegen.js"
  },
  "version": "1.2.0",
  "engines": {
    "node": ">=0.4.0"
  },
  "maintainers": [
    {
      "name": "constellation",
      "email": "utatane.tea@gmail.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/Constellation/escodegen.git"
  },
  "dependencies": {
    "esprima": "~1.0.4",
    "estraverse": "~1.5.0",
    "esutils": "~1.0.0",
    "source-map": "~0.1.30"
  },
  "optionalDependencies": {
    "source-map": "~0.1.30"
  },
  "devDependencies": {
    "esprima-moz": "*",
    "q": "*",
    "bower": "*",
    "semver": "*",
    "chai": "~1.7.2",
    "gulp": "~3.5.0",
    "gulp-mocha": "~0.4.1",
    "gulp-eslint": "~0.1.2",
    "jshint-stylish": "~0.1.5",
    "gulp-jshint": "~1.4.0",
    "commonjs-everywhere": "~0.9.6"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/Constellation/escodegen/raw/master/LICENSE.BSD"
    }
  ],
  "scripts": {
    "test": "gulp travis",
    "unit-test": "gulp test",
    "lint": "gulp lint",
    "release": "node tools/release.js",
    "build-min": "cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
    "build": "cjsify -a path: tools/entry-point.js > escodegen.browser.js"
  },
  "bugs": {
    "url": "https://github.com/Constellation/escodegen/issues"
  },
  "_id": "escodegen@1.2.0",
  "dist": {
    "shasum": "09de7967791cc958b7f89a2ddb6d23451af327e1",
    "tarball": "http://registry.npmjs.org/escodegen/-/escodegen-1.2.0.tgz"
  },
  "_from": "escodegen@>=1.2.0 <1.3.0",
  "_npmVersion": "1.3.21",
  "_npmUser": {
    "name": "constellation",
    "email": "utatane.tea@gmail.com"
  },
  "directories": {},
  "_shasum": "09de7967791cc958b7f89a2ddb6d23451af327e1",
  "_resolved": "https://registry.npmjs.org/escodegen/-/escodegen-1.2.0.tgz",
  "readme": "ERROR: No README data found!"
}

},{}],19:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":25,"./source-map/source-map-generator":26,"./source-map/source-node":27}],20:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":28,"amdefine":29}],21:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  exports.decode = function base64VLQ_decode(aStr, aOutParam) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aStr.slice(i);
  };

});

},{"./base64":22,"amdefine":29}],22:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var charToIntMap = {};
  var intToCharMap = {};

  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .forEach(function (ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 digit to an integer.
   */
  exports.decode = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };

});

},{"amdefine":29}],23:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return mid;
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0 ? -1 : aLow;
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of next lowest value checked if there is no exact hit. This is
   * because mappings between original and generated line/col pairs are single
   * points, and there is an implicit region between each of them, so a miss
   * just means that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    if (aHaystack.length === 0) {
      return -1;
    }
    return recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
  };

});

},{"amdefine":29}],24:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA ||
           util.compareByGeneratedPositions(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList.prototype.unsortedForEach =
    function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList.prototype.add = function MappingList_add(aMapping) {
    var mapping;
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositions);
      this._sorted = true;
    }
    return this._array;
  };

  exports.MappingList = MappingList;

});

},{"./util":28,"amdefine":29}],25:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');

  /**
   * A SourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    sources = sources.map(util.normalize);

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  /**
   * Create a SourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns SourceMapConsumer
   */
  SourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(SourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.toArray().slice();
      smc.__originalMappings = aSourceMap._mappings.toArray().slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._nextCharIsMappingSeparator =
    function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {
      var c = aStr.charAt(0);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var str = aStr;
      var temp = {};
      var mapping;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          base64VLQ.decode(str, temp);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
            // Original source.
            base64VLQ.decode(str, temp);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            base64VLQ.decode(str, temp);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            base64VLQ.decode(str, temp);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
              // Original name.
              base64VLQ.decode(str, temp);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__generatedMappings.sort(util.compareByGeneratedPositions);
      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  SourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  SourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  SourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(needle,
                                    this._generatedMappings,
                                    "generatedLine",
                                    "generatedColumn",
                                    util.compareByGeneratedPositions);

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source != null && this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: util.getArg(mapping, 'name', null)
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  SourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot != null
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  /**
   * Returns all generated line and column information for the original source
   * and line provided. The only argument is an object with the following
   * properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      // When there is no exact match, SourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to Infinity, we thus find the last
      // mapping for the given line, provided such a mapping exists.
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: Infinity
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        while (mapping && mapping.originalLine === needle.originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[--index];
        }
      }

      return mappings.reverse();
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./array-set":20,"./base64-vlq":21,"./binary-search":23,"./util":28,"amdefine":29}],26:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;
  var MappingList = require('./mapping-list').MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name != null && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source)
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      var mappings = this._mappings.toArray();

      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":20,"./base64-vlq":21,"./mapping-list":24,"./util":28,"amdefine":29}],27:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // All even indices of this array are one line of the generated code,
      // while all odd indices are the newlines between two adjacent lines
      // (since `REGEX_NEWLINE` captures its match).
      // Processed fragments are removed from this array, by calling `shiftNextLine`.
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var shiftNextLine = function() {
        var lineContents = remainingLines.shift();
        // The last line of a file might not have a newline.
        var newLine = remainingLines.shift() || "";
        return lineContents + newLine;
      };

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            // No more remaining code, continue
            lastMapping = mapping;
            return;
          }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[0];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLines.length > 0) {
        if (lastMapping) {
          // Associate the remaining code in the current line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.join(""));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath
            ? util.join(aRelativePath, mapping.source)
            : mapping.source;
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":26,"./util":28,"amdefine":29}],28:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consequtive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = (path.charAt(0) === '/');

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // XXX: It is possible to remove this block, and the tests still pass!
    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }

    return aPath.indexOf(aRoot + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }

    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    return mappingA.generatedColumn - mappingB.generatedColumn;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

});

},{"amdefine":29}],29:[function(require,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 1.0.0 Copyright (c) 2011-2015, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                if (callback) {
                    process.nextTick(function () {
                        callback.apply(null, deps);
                    });
                }
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,require("JkpR2F"),"/../node_modules/coffee-script-redux/node_modules/source-map/node_modules/amdefine/amdefine.js")
},{"JkpR2F":34,"path":33}],30:[function(require,module,exports){
module.exports={
  "name": "coffee-script-redux",
  "author": {
    "name": "Michael Ficarra"
  },
  "version": "2.0.0-beta9-dev",
  "homepage": "https://github.com/michaelficarra/CoffeeScriptRedux",
  "bugs": {
    "url": "https://github.com/michaelficarra/CoffeeScriptRedux/issues"
  },
  "description": "Unfancy JavaScript",
  "keywords": [
    "coffeescript",
    "javascript",
    "language",
    "compiler"
  ],
  "main": "./lib/module",
  "bin": {
    "coffee": "./bin/coffee"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/michaelficarra/CoffeeScriptRedux.git"
  },
  "scripts": {
    "build": "make -j build",
    "test": "make -j test"
  },
  "devDependencies": {
    "mocha": "~1.12.0",
    "pegjs": "~0.8.0",
    "pegjs-each-code": "~0.2.0",
    "commonjs-everywhere": "~0.9.0",
    "cluster": "~0.7.7",
    "semver": "~2.1.0"
  },
  "dependencies": {
    "StringScanner": "~0.0.3",
    "nopt": "~2.1.2",
    "esmangle": "~1.0.0",
    "source-map": "0.1.x",
    "escodegen": "~1.2.0",
    "cscodegen": "git+https://github.com/michaelficarra/cscodegen.git#73fd7202ac086c26f18c9d56f025b18b3c6f5383"
  },
  "optionalDependencies": {
    "esmangle": "~1.0.0",
    "source-map": "0.1.x",
    "escodegen": "~1.2.0",
    "cscodegen": "git+https://github.com/michaelficarra/cscodegen.git#73fd7202ac086c26f18c9d56f025b18b3c6f5383"
  },
  "engines": {
    "node": "0.8.x || 0.10.x"
  },
  "licenses": [
    {
      "type": "3-clause BSD",
      "url": "https://raw.github.com/michaelficarra/CoffeeScriptRedux/master/LICENSE"
    }
  ],
  "license": "3-clause BSD",
  "gitHead": "ad91003538d0d4d4d94469df6afcc0c35f56d36c",
  "readme": "CoffeeScript II: The Wrath of Khan\n==================================\n\n```\n          {\n       }   }   {\n      {   {  }  }\n       }   }{  {\n      {  }{  }  }             _____       __  __\n     ( }{ }{  { )            / ____|     / _|/ _|\n   .- { { }  { }} -.        | |     ___ | |_| |_ ___  ___\n  (  ( } { } { } }  )       | |    / _ \\|  _|  _/ _ \\/ _ \\\n  |`-..________ ..-'|       | |___| (_) | | | ||  __/  __/\n  |                 |        \\_____\\___/|_| |_| \\___|\\___|       .-''-.\n  |                 ;--.                                       .' .-.  )\n  |                (__  \\     _____           _       _       / .'  / /\n  |                 | )  )   / ____|         (_)     | |     (_/   / /\n  |                 |/  /   | (___   ___ _ __ _ _ __ | |_         / /\n  |                 (  /     \\___ \\ / __| '__| | '_ \\| __|       / /\n  |                 |/       ____) | (__| |  | | |_) | |_       . '\n  |                 |       |_____/ \\___|_|  |_| .__/ \\__|     / /    _.-')\n   `-.._________..-'                           | |           .' '  _.'.-''\n                                               |_|          /  /.-'_.'\n                                                           /    _.'\n                                                          ( _.-'\n```\n\n### Status\n\nComplete enough to use for nearly every project. See the [roadmap to 2.0](https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Roadmap).\n\n### Getting Started\n\n    npm install -g coffee-script-redux\n    coffee --help\n    coffee --js <input.coffee >output.js\n\nBefore transitioning from Jeremy's compiler, see the\n[intentional deviations from jashkenas/coffee-script](https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Intentional-Deviations-From-jashkenas-coffee-script)\nwiki page.\n\n### Development\n\n    git clone git://github.com/michaelficarra/CoffeeScriptRedux.git && cd CoffeeScriptRedux && npm install\n    make clean && git checkout -- lib && make -j build && make test\n\n### Notable Contributors\n\nI'd like to thank the following financial contributors for their large\ndonations to [the Kickstarter project](https://www.kickstarter.com/projects/michaelficarra/make-a-better-coffeescript-compiler)\nthat funded the initial work on this compiler.\nTogether, you donated over $10,000. Without you, I wouldn't have been able to do this.\n\n* [Groupon](https://www.groupon.com/), who is generously allowing me to work in their offices\n* [Trevor Burnham](http://trevorburnham.com)\n* [Shopify](https://www.shopify.com/)\n* [Abakas](http://abakas.com)\n* [37signals](http://37signals.com)\n* [Brightcove](https://www.brightcove.com/en/)\n* [Gaslight](https://teamgaslight.com/)\n* [Pantheon](https://pantheon.io/)\n* Benbria\n* Sam Stephenson\n* Bevan Hunt\n* Meryn Stol\n* Rob Tsuk\n* Dion Almaer\n* Andrew Davey\n* Thomas Burleson\n* Michael Kedzierski\n* Jeremy Kemper\n* Kyle Cordes\n* Jason R. Lauman\n* Martin Drenovac (Envizion Systems - Aust)\n* Julian Bilcke\n* Michael Edmondson\n\nAnd of course, thank you [Jeremy](https://github.com/jashkenas) (and all the other\n[contributors](https://github.com/jashkenas/coffeescript/graphs/contributors))\nfor making [the original CoffeeScript compiler](https://github.com/jashkenas/coffeescript).\n",
  "readmeFilename": "README.md",
  "_id": "coffee-script-redux@2.0.0-beta9-dev",
  "_shasum": "90124265184e5ea0a3005abde504e9460978d39d",
  "_from": "git://github.com/michaelficarra/CoffeeScriptRedux.git",
  "_resolved": "git://github.com/michaelficarra/CoffeeScriptRedux.git#ad91003538d0d4d4d94469df6afcc0c35f56d36c"
}

},{}],31:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true, define:true*/
(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // and plain browser loading,
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.estraverse = {}));
    }
}(this, function (exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        BREAK,
        SKIP;

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'defaults', 'rest', 'body'],
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'body', 'superClass'],
        ClassExpression: ['id', 'body', 'superClass'],
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],
        FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MethodDefinition: ['key', 'value'],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
    };

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = element.wrap || node.type;
                candidates = VisitorKeys[nodeType];

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (!isArray(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                        continue;
                    }

                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if ((nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === candidates[current]) {
                            element = new Element(candidate[current2], [key, current2], 'Property', null);
                        } else {
                            element = new Element(candidate[current2], [key, current2], null, null);
                        }
                        worklist.push(element);
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = element.wrap || node.type;
            candidates = VisitorKeys[nodeType];

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (!isArray(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                    continue;
                }

                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                    if (!candidate[current2]) {
                        continue;
                    }
                    if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                        element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                    } else {
                        element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                    }
                    worklist.push(element);
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = '1.5.1-dev';
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],32:[function(require,module,exports){

},{}],33:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require("JkpR2F"))
},{"JkpR2F":34}],34:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],35:[function(require,module,exports){
window.aetherCoffeeScriptRedux = require('coffee-script-redux');

},{"coffee-script-redux":5}]},{},[35]);